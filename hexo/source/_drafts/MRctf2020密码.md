title: MRctf2020密码
author: 人生若只如初见
tags: []
categories:
  - ctf
date: 2020-05-29 11:35:00
---
# babyrsa
* 根据主函数可知，首要目的是找到_P和_Q，首先来看_P
* 可以发现
![](https://img-blog.csdnimg.cn/20200329224856124.png)
* 题目已给出P[9],所以直接目的可以手动测试周围素数，直到找到全部（这里是一部分）
![](https://img-blog.csdnimg.cn/20200329225022887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)
* 这里我们可以得到N
* 
```
factor = pow(p, base, n)
```

* 这一句说明我们应该将这个简单RSA解出来，此时按照一般RSA的步骤求得d
![](https://img-blog.csdnimg.cn/20200329225008750.png)
* 这里已经得到N的所有因数，所以此时N的欧拉函数为所有因数减1相乘，即(p1-1)*(p2-1)*(...)*(p17-1)， 到此得到P的值
* 接下来是Q
![](https://img-blog.csdnimg.cn/20200329225330826.png)
* 可以看到的是所有的参数已经给出，但是如果我们按照这个去算会很慢，因为数值是比较大的，所以这里我们用到了快速幂模

```
Q_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
def fastExpMod(b, e, m):
    result = 1
    while e != 0:
        if (e&1) == 1:
            # ei = 1, then mul
            result = (result * b) % m
        e >>= 1
        # b, b^2, b^4, b^8, ... , b^(2^n)
        b = (b*b) % m
    return result
_q=fastExpMod(sub_Q,Q_2 , Q_1)
_q=sympy.nextprime(_q)
```

* 通过这个得到最终的Q的值
* 最后按照常规RSA的解密，完成此题（完整代码）

```
import sympy
import gmpy2 
from Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytes

base=65537

factor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839
n=1
p = [0 for i in range(17)]
p[0]=206027926847308612719677572554991142909
p[1]=206027926847308612719677572554991142911
p[2]=206027926847308612719677572554991142977
p[3]=206027926847308612719677572554991143071
p[4]=206027926847308612719677572554991143103
p[5]=206027926847308612719677572554991143121
p[6]=206027926847308612719677572554991143133
p[7]=206027926847308612719677572554991143317
p[8]=206027926847308612719677572554991143401
p[9]=206027926847308612719677572554991143421
for i in range(10,17):
    p[i]=sympy.nextprime(p[i-1])

for i in range(17):
        x= n*p[i]
        n=x

phi=1
for i in range(0,17):
    phi *=p[i]-1

d1=gmpy2.invert(base,phi)
_p=pow(factor,d1,n)
_p=sympy.nextprime(_p)

Q_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
def fastExpMod(b, e, m):
    result = 1
    while e != 0:
        if (e&1) == 1:
            # ei = 1, then mul
            result = (result * b) % m
        e >>= 1
        # b, b^2, b^4, b^8, ... , b^(2^n)
        b = (b*b) % m
    return result
_q=fastExpMod(sub_Q,Q_2 , Q_1)
_q=sympy.nextprime(_q)


c=  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832
d=gmpy2.invert(base,(_p-1)*(_q-1))
m=pow(c,d,_p*_q)
print long_to_bytes(m)
```

# Easy_RSA
* 与上一题类似，这里我们依旧先从P开始
![](https://img-blog.csdnimg.cn/20200329225948126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)
* 可以看到最终的P需要从Ｐ_n以及P_F_n得到，类似解二元一次方程组，这里我们使用sage来快速解方程
![](https://img-blog.csdnimg.cn/20200329230437741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)
* 接下来解决Q的问题
![](https://img-blog.csdnimg.cn/20200329230512279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)
* 这里我们拿到了N和e*d，这个问题转变为已知N和e*d，分解N,直接上脚本

```
#coding=utf-8
from random import randint
import gmpy2
def oddR(r):
    while r%2==0:
        r=r//2
    return r
    
def bits(b):
    k=[]
    while b:
        if b%2!=0:
            k.append(1)
        else:
            k.append(0)
        b>>=1
    k.reverse()      
    return k
    
def quickmod(a,b,n):      #a^b mod n 快速幂模n运算
    f=1
    k=bits(b)
    for i in range(len(k)):
        f=(f*f)%n
        if k[i]:
            f=(f*a)%n
    return f

def gcd(m,n):
    while(n!=0):
        m,n=n,m%n
    return m

def func(e_d,N):
    k=e_d-1            
    r=oddR(k)           #求出k=2^t*r中的r
    
    while True:
        b=randint(2,N-1)    #获取区间(2,N-1)的一个随机数
        a=quickmod(b,r,N)   
        if a==1:            
            continue    
        y=gcd(a-1,N)
        if a>1 and y>1:    
            q=N//y
            return q
        else:
            r=r*2         
    
def deciphering(e_d,n):    、
    p=func(e_d,n)
    q=n//p
    phi=n-(p+q)+1
    if p*q==n:
        print p
        print q
    else:
        print"error"



n =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947
e_d=  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201
deciphering(e_d,n)
```

* 得到Q，最后依旧是RSA的常规解密
