{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/images/pasted-0.png","path":"images/pasted-0.png","modified":0,"renderable":0},{"_id":"source/images/pasted-1.png","path":"images/pasted-1.png","modified":0,"renderable":0},{"_id":"source/images/pasted-13.png","path":"images/pasted-13.png","modified":0,"renderable":0},{"_id":"source/images/pasted-14.png","path":"images/pasted-14.png","modified":0,"renderable":0},{"_id":"source/images/pasted-18.png","path":"images/pasted-18.png","modified":0,"renderable":0},{"_id":"source/images/pasted-2.png","path":"images/pasted-2.png","modified":0,"renderable":0},{"_id":"source/images/pasted-21.png","path":"images/pasted-21.png","modified":0,"renderable":0},{"_id":"source/images/pasted-22.png","path":"images/pasted-22.png","modified":0,"renderable":0},{"_id":"source/images/pasted-23.png","path":"images/pasted-23.png","modified":0,"renderable":0},{"_id":"source/images/pasted-24.png","path":"images/pasted-24.png","modified":0,"renderable":0},{"_id":"source/images/pasted-25.png","path":"images/pasted-25.png","modified":0,"renderable":0},{"_id":"source/images/pasted-3.png","path":"images/pasted-3.png","modified":0,"renderable":0},{"_id":"source/images/pasted-31.png","path":"images/pasted-31.png","modified":0,"renderable":0},{"_id":"source/images/pasted-32.png","path":"images/pasted-32.png","modified":0,"renderable":0},{"_id":"source/images/pasted-5.png","path":"images/pasted-5.png","modified":0,"renderable":0},{"_id":"source/images/pasted-4.png","path":"images/pasted-4.png","modified":0,"renderable":0},{"_id":"source/images/pasted-6.png","path":"images/pasted-6.png","modified":0,"renderable":0},{"_id":"source/images/pasted-10.png","path":"images/pasted-10.png","modified":0,"renderable":0},{"_id":"source/images/pasted-15.png","path":"images/pasted-15.png","modified":0,"renderable":0},{"_id":"source/images/pasted-16.png","path":"images/pasted-16.png","modified":0,"renderable":0},{"_id":"source/images/pasted-17.png","path":"images/pasted-17.png","modified":0,"renderable":0},{"_id":"source/images/pasted-26.png","path":"images/pasted-26.png","modified":0,"renderable":0},{"_id":"source/images/pasted-27.png","path":"images/pasted-27.png","modified":0,"renderable":0},{"_id":"source/images/pasted-28.png","path":"images/pasted-28.png","modified":0,"renderable":0},{"_id":"source/images/pasted-30.png","path":"images/pasted-30.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/gov.png","path":"img/gov.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/titleTip.js","path":"js/titleTip.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"source/images/pasted-11.png","path":"images/pasted-11.png","modified":0,"renderable":0},{"_id":"source/images/pasted-29.png","path":"images/pasted-29.png","modified":0,"renderable":0},{"_id":"source/images/pasted-9.png","path":"images/pasted-9.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"source/images/pasted-33.png","path":"images/pasted-33.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","path":"css/fonts/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"source/images/pasted-12.png","path":"images/pasted-12.png","modified":0,"renderable":0},{"_id":"source/images/pasted-8.png","path":"images/pasted-8.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1},{"_id":"source/images/pasted-20.png","path":"images/pasted-20.png","modified":0,"renderable":0},{"_id":"source/images/pasted-19.png","path":"images/pasted-19.png","modified":0,"renderable":0},{"_id":"source/images/pasted-7.png","path":"images/pasted-7.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/3-hexo/.gitignore","hash":"46eca80fe689a00cbe4d015c094702af54119021","modified":1590546772270},{"_id":"themes/3-hexo/_config.yml","hash":"fdef695f31f879e2c19d92d18fe05b57c0c8af08","modified":1590633115209},{"_id":"themes/3-hexo/.DS_Store","hash":"0770f9d42bfdd8d420de48fed463015e001cf579","modified":1590546772270},{"_id":"themes/3-hexo/LICENSE","hash":"b04140c5f682db2b300428f97bb164fd7f5f18bd","modified":1590546772271},{"_id":"themes/3-hexo/README.md","hash":"19b8cfe6690c28427492f342e74dda5ed49a1664","modified":1590546772271},{"_id":"source/_discarded/hello-world.md","hash":"f774dbad420f791901a4a78519a5def2730ddc9d","modified":1590572586876},{"_id":"source/_drafts/Ecc椭圆曲线基础.md","hash":"fc22cb9f23a57a707f6cddb0b60c3bb13e433d7d","modified":1590575198960},{"_id":"source/_drafts/MRctf2020密码.md","hash":"55f0c4b6f4205203fd54a8dbae4d627de2bb6ebd","modified":1590723372579},{"_id":"source/_drafts/RsaLsbOrcalePadding.md","hash":"716f27f42cd359b53f8d3df7e2b450759e87738d","modified":1601033275508},{"_id":"source/_drafts/Unicode编码衍生出的编码方案.md","hash":"3d0c2c29f30c00814af12d25210675e360f00af4","modified":1590574518940},{"_id":"source/_drafts/lcg线性同余随机数生成器.md","hash":"4179b4081df47cf9913f6119e5a8f8b0295022ef","modified":1590630673973},{"_id":"source/_drafts/rsa-Factor-Attack-及常用脚本.md","hash":"f89041ae64eb59931d1a77e4359cc99a23569de8","modified":1590678433180},{"_id":"source/_drafts/分组加密的padding.md","hash":"0bcedd5622449f1f6e58184bdc10471e53719e23","modified":1601033685560},{"_id":"source/_drafts/rsa基础学习-1.md","hash":"ce292a7f58dd9facea9acfa7e16254c9a685fda6","modified":1590662852012},{"_id":"source/_drafts/rsa已知e-d分解N.md","hash":"ab62f51685004beda92cb204ddcba5e105801888","modified":1590662698922},{"_id":"source/_drafts/将CRT-中国剩余定理-与RSA结合.md","hash":"256ec8de6e768ae5673ce623d6ae1513baed6412","modified":1601025071282},{"_id":"source/_drafts/rsa当e-2且不互素时处理方式.md","hash":"22bc0700cd2a51876336e2e03b3de139cd6fcdca","modified":1592908518990},{"_id":"source/_drafts/密码学编码-一-ASCII编码.md","hash":"207083664965d77095ae67f1275d53eedabd6e2f","modified":1590573566758},{"_id":"source/_drafts/密码学编码-三-Unicode编码.md","hash":"20b63c6bdcc2ab767d74dea759c82784d6e60da2","modified":1590574137275},{"_id":"source/_drafts/rsa已知高位攻击1.md","hash":"22d6f13dde34b481e7378de2a5134ec9919c18d6","modified":1590561538062},{"_id":"source/_drafts/密码学编码-二-base编码.md","hash":"683e35365035975785948c1ccf641f84aeb2b083","modified":1590573205953},{"_id":"source/_drafts/红黑树的删除和变色.md","hash":"aed54ff912a749deab0a8d622fcdf377a44b9a9e","modified":1590675479278},{"_id":"source/_drafts/网鼎杯2020青龙组crypto.md","hash":"05b615cc26276f5be0e47cc25020ba86aa4a0d26","modified":1592961383710},{"_id":"source/images/pasted-0.png","hash":"8f73d972f4446cea7af015b895b655f8038a5829","modified":1590572633665},{"_id":"source/images/pasted-1.png","hash":"69e0b9549e6a8997f9de00670012da9041d4cbee","modified":1590572667564},{"_id":"source/images/pasted-13.png","hash":"cd7e87874c0c58c9139fb27ab1e6ccc4e61177a2","modified":1590574371745},{"_id":"source/images/pasted-14.png","hash":"102066fb964c9df2320681496e66a7f1402e5130","modified":1590574641210},{"_id":"source/images/pasted-18.png","hash":"789a28e9ee023a69d558377f82f707e8ca9f99c3","modified":1590574845597},{"_id":"source/images/pasted-2.png","hash":"3ba8b0f9fa4f1dd4d9088815b45f0b25af85d97c","modified":1590572690513},{"_id":"source/images/pasted-21.png","hash":"4b5d1b877d8017d19039e5312ef6b5151bba3942","modified":1590662331052},{"_id":"source/images/pasted-22.png","hash":"e57aaa63aa327c7504648535e33fa409f3229141","modified":1590662406166},{"_id":"source/images/pasted-23.png","hash":"58c22b53140e40d230a5ed67ab97c8c62c7d2636","modified":1590662449889},{"_id":"source/images/pasted-24.png","hash":"192f6c4f1f7c5ee6c428e6361281d9fc6853c1a8","modified":1590662538414},{"_id":"source/images/pasted-25.png","hash":"a65f983a0af1d4cd0cb0748e7a3526bc7922d2f7","modified":1590662631505},{"_id":"source/images/pasted-3.png","hash":"7099260abeb62a50b30212897433d2fd69cd815f","modified":1590572707733},{"_id":"source/images/pasted-31.png","hash":"2cc22d27beb87783002d60a8cef72871f4f9b1de","modified":1592960821018},{"_id":"source/images/pasted-32.png","hash":"28b11a463518957260de5c08725ad268dfa04ad9","modified":1592960853803},{"_id":"source/images/pasted-5.png","hash":"1c222f1dbdbda79b7a9e863026ea98dd363e97ac","modified":1590572747980},{"_id":"source/images/pasted-4.png","hash":"7f0d6c9b2d98012606020dc4a084d46bf44b29b4","modified":1590572722101},{"_id":"source/images/pasted-6.png","hash":"103913014b2c2fea6b64086edc8c0f274ba9aed4","modified":1590572762506},{"_id":"source/_posts/Ecc椭圆曲线基础.md","hash":"fc22cb9f23a57a707f6cddb0b60c3bb13e433d7d","modified":1590575198960},{"_id":"source/_posts/MRctf2020密码.md","hash":"55f0c4b6f4205203fd54a8dbae4d627de2bb6ebd","modified":1590723372579},{"_id":"source/_posts/lcg线性同余随机数生成器.md","hash":"4179b4081df47cf9913f6119e5a8f8b0295022ef","modified":1590630673973},{"_id":"source/_posts/RsaLSBOrcalePadding.md","hash":"716f27f42cd359b53f8d3df7e2b450759e87738d","modified":1601033275508},{"_id":"source/_posts/Unicode编码衍生出的编码方案.md","hash":"3d0c2c29f30c00814af12d25210675e360f00af4","modified":1590574518940},{"_id":"source/_posts/rsa已知e-d分解N.md","hash":"ab62f51685004beda92cb204ddcba5e105801888","modified":1590662698922},{"_id":"source/_posts/rsa基础学习-1.md","hash":"ce292a7f58dd9facea9acfa7e16254c9a685fda6","modified":1590662852012},{"_id":"source/_posts/分组加密的padding.md","hash":"0bcedd5622449f1f6e58184bdc10471e53719e23","modified":1601033685560},{"_id":"source/_posts/rsa-Factor-Attack-及常用脚本.md","hash":"f89041ae64eb59931d1a77e4359cc99a23569de8","modified":1590678433180},{"_id":"source/_posts/rsa已知高位攻击1.md","hash":"22d6f13dde34b481e7378de2a5134ec9919c18d6","modified":1590561538062},{"_id":"source/_posts/rsa当e-2且不互素时处理方式.md","hash":"22bc0700cd2a51876336e2e03b3de139cd6fcdca","modified":1592908518990},{"_id":"source/_posts/将CRT-中国剩余定理-与RSA结合.md","hash":"256ec8de6e768ae5673ce623d6ae1513baed6412","modified":1601025071282},{"_id":"source/_posts/密码学编码-一-ASCII编码.md","hash":"207083664965d77095ae67f1275d53eedabd6e2f","modified":1590573566758},{"_id":"source/_posts/密码学编码-二-base编码.md","hash":"683e35365035975785948c1ccf641f84aeb2b083","modified":1590573312302},{"_id":"source/_posts/红黑树的删除和变色.md","hash":"aed54ff912a749deab0a8d622fcdf377a44b9a9e","modified":1590675479278},{"_id":"source/_posts/密码学编码-三-Unicode编码.md","hash":"20b63c6bdcc2ab767d74dea759c82784d6e60da2","modified":1590574137275},{"_id":"themes/3-hexo/languages/en.yml","hash":"616e02c035c86033ab4a97c5ae9e0a9e5f0b8ea3","modified":1590546772272},{"_id":"themes/3-hexo/languages/zh-CN.yml","hash":"83633d45420c96dfac41333aeac3f3616dca5286","modified":1590546772272},{"_id":"themes/3-hexo/layout/index.ejs","hash":"1c185288c2925a652d577965626718e12df07f65","modified":1590546772278},{"_id":"themes/3-hexo/layout/indexs.md","hash":"06b8a38a1458541a309c003ea011b585aca893f4","modified":1590679100198},{"_id":"themes/3-hexo/layout/post.ejs","hash":"a0eaba41e7ec9db5843af482470a45531049b457","modified":1590546772279},{"_id":"source/_posts/网鼎杯2020青龙组crypto.md","hash":"05b615cc26276f5be0e47cc25020ba86aa4a0d26","modified":1592961383710},{"_id":"themes/3-hexo/source/.DS_Store","hash":"fdcc907c46e093a14b153c5dc8c038461997ed3c","modified":1590546772279},{"_id":"source/images/pasted-10.png","hash":"7792b21ca7d34761223df2e2a165f94c56f669f6","modified":1590573866021},{"_id":"source/images/pasted-15.png","hash":"de838f7b5e1239be342fe0d90f72ba36afb0aafe","modified":1590574675518},{"_id":"source/images/pasted-16.png","hash":"b9b50064c7445d63d450cba61e6b97c2cbc0379c","modified":1590574703853},{"_id":"source/images/pasted-17.png","hash":"b9b50064c7445d63d450cba61e6b97c2cbc0379c","modified":1590574707747},{"_id":"source/images/pasted-26.png","hash":"40a74ce21df9db46bf95724970d7a3040f120826","modified":1590663894004},{"_id":"source/images/pasted-27.png","hash":"a9b2a877653d5a6584cdb6b5eeda6187033ce55d","modified":1590663910835},{"_id":"source/images/pasted-28.png","hash":"87479fe016d7142aff27a6eb2177e5d809cb9053","modified":1590664057494},{"_id":"source/images/pasted-30.png","hash":"4788b741b3f03e741cf9b5fa4097bfbbdca20d4e","modified":1590675449943},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"9e1cdec49d5b9b44399348d96ecd7331f3ee7d85","modified":1590546772273},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1590546772273},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"cc1b38b70a025c300803e37914890c194e36a825","modified":1590546772273},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"4c09f47e899fe36bfe36d92b12996219c2b5f622","modified":1590546772275},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"b2a01cc1f0326965f0a186ce3c9b3c991fd4e2c9","modified":1590546772275},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"e6dd90be668195016d6e1c51a6baefb50676e6ab","modified":1590546772276},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"21e5a6a7cf3ed1a970b959523137764e6fd3ca90","modified":1590546772276},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"60a085fab3165ea1fc6370abac0bd6ab1b2f2510","modified":1590546772276},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"645552125146d19f73c5cc488e8ae94c5f175f77","modified":1590546772277},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1590546772277},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ab6329ddd908b0567c18f39ac6a8553c6fec67c5","modified":1590546772277},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"1c59f629b5f113f989eb4ef7226d7433480f54a1","modified":1590546772277},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"d5f97a4f7e1e96dd323cd08c117c2942f325cc42","modified":1590546772278},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1590546772278},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"bebb374c8a505bf0e4dcc9dc63b426f96c015358","modified":1590546772278},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"1c2f8b7d7cf46f219adb3a628bdf380f29ff4a6b","modified":1590546772291},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1590546772287},{"_id":"themes/3-hexo/source/css/style.styl","hash":"29fa7f6619519c2dcfec4efac4314c5af659a92a","modified":1590546772291},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"20131df26a232d3a225f6374e23f33d2ed7f55db","modified":1590575841006},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"345951b44059d11573802f4001c5461ca8473e11","modified":1576673172996},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1590546772294},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1590546772292},{"_id":"themes/3-hexo/source/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1590546772293},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1590546772293},{"_id":"themes/3-hexo/source/js/script.js","hash":"a82414e912b057db4ac95ca6d30df7cd8d95e1aa","modified":1590546772301},{"_id":"themes/3-hexo/source/js/titleTip.js","hash":"7299ac046ddd6e6a4267d435f7b4c8198baaaccc","modified":1590546772302},{"_id":"themes/3-hexo/source/js/search.js","hash":"788c610149a5f9361295f9f0207c8523f37ddb8b","modified":1590546772302},{"_id":"source/images/pasted-11.png","hash":"823444c5aab1c152ea3f3289c1c7c44d3780b8c5","modified":1590573899847},{"_id":"source/images/pasted-29.png","hash":"10db3ccdcd871eb99ddb02c38b511f88c4a2f2a3","modified":1590675415869},{"_id":"source/images/pasted-9.png","hash":"f7ebeb5408cb02545140c3e8538701f846d282d6","modified":1590573805783},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"ba499c1e54087d7347c5a73c2bfeb5955d9706de","modified":1590575737608},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1590546772301},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1590546772300},{"_id":"source/images/pasted-33.png","hash":"20256de654804ab1bbfec4656921107d65ed848a","modified":1599355423901},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"05b09c45b379ffeb4f48c1604044d88829f90799","modified":1590546772273},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1590546772274},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1590546772274},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1590546772274},{"_id":"themes/3-hexo/layout/_partial/comments/livere.ejs","hash":"2d115e79cadedc2d5d8f4b5618559640d986e01f","modified":1590546772274},{"_id":"themes/3-hexo/layout/_partial/comments/utteranc.ejs","hash":"8f2d4f42fbad351677c82e72420224587a5bd666","modified":1590546772275},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"d5fa333970a2eac66937d42eeb16fdb362e121ed","modified":1590546772280},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1590546772280},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1590546772280},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"542c85263a63a832aaac3b021bc661fe6661bcc4","modified":1590546772281},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"9a732af065d0a80c9e420934be0f3582bf0129dc","modified":1590546772281},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"16a81f7b6a38d6a423a9c995c95a40d6c16ead55","modified":1590546772281},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"9e741abd6f71695d360c349e0dffc790f5b1ffc2","modified":1590546772282},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1590546772282},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1590546772282},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"5ddb2e19816fcb4a9be9b2a2dabd12376c8000d1","modified":1590546772282},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1590546772283},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1590546772283},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1590546772283},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1590546772284},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1590546772284},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1590546772285},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"3630aabf2f9c0417f483ebd03d9e429dbc2594e0","modified":1590546772285},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1590546772285},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"553987211d3323a7dfc0b08786b183a3435978c9","modified":1590546772287},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1590546772286},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1590546772287},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1590546772286},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1590546772287},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1590546772287},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1590546772287},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1590546772287},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1590546772289},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1590546772289},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1590546772289},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1590546772289},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1590546772289},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1590546772289},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1590546772289},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1590546772289},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1590546772291},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1590546772291},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1590546772300},{"_id":"source/images/pasted-12.png","hash":"c03ce52d3e3815bf0fa7aadf4fc52ba5b3e55c6b","modified":1590573919540},{"_id":"source/images/pasted-8.png","hash":"5f4c6e7d696b30fe424f63d879f7ba92c54befd3","modified":1590573487486},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"a95b598d998c4723f978ed21614127150075bf40","modified":1590546772299},{"_id":"source/images/pasted-20.png","hash":"8bcd37a68733fa3fa3333ca02203f8d2445ee929","modified":1590630663054},{"_id":"source/images/pasted-19.png","hash":"8bcd37a68733fa3fa3333ca02203f8d2445ee929","modified":1590630659329},{"_id":"source/images/pasted-7.png","hash":"7c4770875501a7aa1978773733d73709085410ce","modified":1590573449739},{"_id":"public/2020/09/24/分组加密的padding/index.html","hash":"d10a2abd2db74772c1335ed3dea8f08480e9c32b","modified":1601033788170},{"_id":"public/2020/09/06/RsaLSBOrcalePadding/index.html","hash":"a463eaac67192e3c9b6742216773f43cf007e47b","modified":1601033788170},{"_id":"public/2020/06/24/网鼎杯2020青龙组crypto/index.html","hash":"970d7c116a60c79c9d7c30d639344828c6833aed","modified":1601033788170},{"_id":"public/2020/06/23/rsa当e-2且不互素时处理方式/index.html","hash":"ee547ca1f00c1eea195e8901db64f861ff70ea78","modified":1601033788170},{"_id":"public/2020/06/01/将CRT-中国剩余定理-与RSA结合/index.html","hash":"4affe9de9366282f5b0e886484cc90b65cb12122","modified":1601033788170},{"_id":"public/2020/05/29/MRctf2020密码/index.html","hash":"1cb8b518071047c80fc86ab456c23790471eca6d","modified":1601033788170},{"_id":"public/2020/05/28/rsa-Factor-Attack-及常用脚本/index.html","hash":"681e5e35064b9dcd4cf5d6ba4e16d569ffe8052c","modified":1601033788170},{"_id":"public/2020/05/28/红黑树的删除和变色/index.html","hash":"fcddca247fd46dee08c20d3582d61b766e95829c","modified":1601033788170},{"_id":"public/2020/05/28/rsa已知e-d分解N/index.html","hash":"e95ecacd41f293b012606aeb7b76e60f8eb89458","modified":1601033788170},{"_id":"public/2020/05/28/lcg线性同余随机数生成器/index.html","hash":"ef53cda6d7b43324293c3d989f10166de765d181","modified":1601033788170},{"_id":"public/2020/05/27/Ecc椭圆曲线基础/index.html","hash":"0d9663d9c8fd7ae310b0b06f613e148a7915ab8a","modified":1601033788170},{"_id":"public/2020/05/27/Unicode编码衍生出的编码方案/index.html","hash":"48109fc656cf8d3c90b902d84b4c192639a4b5cf","modified":1601033788170},{"_id":"public/2020/05/27/密码学编码-三-Unicode编码/index.html","hash":"5f9f2d5fee02e14a5a007c8743bbe6838dc3e353","modified":1601033788170},{"_id":"public/2020/05/27/密码学编码-一-ASCII编码/index.html","hash":"27f9b197cb441912724bca3d846e0329eebfd529","modified":1601033788170},{"_id":"public/2020/05/27/密码学编码-二-base编码/index.html","hash":"dc336b2f4c20734d30b0a960eaed498d6bd00a9d","modified":1601033788170},{"_id":"public/2020/05/27/rsa已知高位攻击1/index.html","hash":"129a018467ff0680d99e2bc0ff731273751bbe61","modified":1601033788170},{"_id":"public/2020/05/27/rsa基础学习-1/index.html","hash":"b2e5b5c2e921d15a03d9536959380c0f6a485167","modified":1601033788170},{"_id":"public/archives/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/archives/page/2/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/archives/2020/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/archives/2020/page/2/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/archives/2020/05/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/archives/2020/05/page/2/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/archives/2020/06/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/archives/2020/09/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/categories/ctf/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/categories/密码学/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/categories/密码学/ECC/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/categories/密码学/page/2/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/categories/密码学/rsa/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/categories/密码学/编码/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/categories/密码学/随机数/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/categories/密码学/算法/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/page/2/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170},{"_id":"public/tags/密码学/index.html","hash":"5496803f9dd1f72c217cee2180c5d155cd5e1a41","modified":1601033455129},{"_id":"public/tags/填充方式/index.html","hash":"5496803f9dd1f72c217cee2180c5d155cd5e1a41","modified":1601033455129},{"_id":"public/images/pasted-1.png","hash":"69e0b9549e6a8997f9de00670012da9041d4cbee","modified":1601033066821},{"_id":"public/images/pasted-13.png","hash":"cd7e87874c0c58c9139fb27ab1e6ccc4e61177a2","modified":1601033066821},{"_id":"public/images/pasted-0.png","hash":"8f73d972f4446cea7af015b895b655f8038a5829","modified":1601033066821},{"_id":"public/images/pasted-14.png","hash":"102066fb964c9df2320681496e66a7f1402e5130","modified":1601033066821},{"_id":"public/images/pasted-18.png","hash":"789a28e9ee023a69d558377f82f707e8ca9f99c3","modified":1601033066821},{"_id":"public/images/pasted-2.png","hash":"3ba8b0f9fa4f1dd4d9088815b45f0b25af85d97c","modified":1601033066821},{"_id":"public/images/pasted-23.png","hash":"58c22b53140e40d230a5ed67ab97c8c62c7d2636","modified":1601033066821},{"_id":"public/images/pasted-22.png","hash":"e57aaa63aa327c7504648535e33fa409f3229141","modified":1601033066821},{"_id":"public/images/pasted-21.png","hash":"4b5d1b877d8017d19039e5312ef6b5151bba3942","modified":1601033066821},{"_id":"public/images/pasted-24.png","hash":"192f6c4f1f7c5ee6c428e6361281d9fc6853c1a8","modified":1601033066821},{"_id":"public/images/pasted-25.png","hash":"a65f983a0af1d4cd0cb0748e7a3526bc7922d2f7","modified":1601033066821},{"_id":"public/images/pasted-3.png","hash":"7099260abeb62a50b30212897433d2fd69cd815f","modified":1601033066821},{"_id":"public/images/pasted-31.png","hash":"2cc22d27beb87783002d60a8cef72871f4f9b1de","modified":1601033066821},{"_id":"public/images/pasted-32.png","hash":"28b11a463518957260de5c08725ad268dfa04ad9","modified":1601033066821},{"_id":"public/images/pasted-5.png","hash":"1c222f1dbdbda79b7a9e863026ea98dd363e97ac","modified":1601033066821},{"_id":"public/images/pasted-4.png","hash":"7f0d6c9b2d98012606020dc4a084d46bf44b29b4","modified":1601033066821},{"_id":"public/images/pasted-6.png","hash":"103913014b2c2fea6b64086edc8c0f274ba9aed4","modified":1601033066821},{"_id":"public/img/alipay.jpg","hash":"20131df26a232d3a225f6374e23f33d2ed7f55db","modified":1601033066821},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1601033066821},{"_id":"public/img/avatar.jpg","hash":"345951b44059d11573802f4001c5461ca8473e11","modified":1601033066821},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1601033066821},{"_id":"public/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1601033066821},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1601033066821},{"_id":"public/img/weixin.jpg","hash":"ba499c1e54087d7347c5a73c2bfeb5955d9706de","modified":1601033066821},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1601033066821},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1601033066821},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1601033066821},{"_id":"public/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1601033066821},{"_id":"public/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1601033066821},{"_id":"public/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1601033066821},{"_id":"public/css/fonts/iconfont.svg","hash":"3630aabf2f9c0417f483ebd03d9e429dbc2594e0","modified":1601033066821},{"_id":"public/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1601033066821},{"_id":"public/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1601033066821},{"_id":"public/images/pasted-10.png","hash":"7792b21ca7d34761223df2e2a165f94c56f669f6","modified":1601033066821},{"_id":"public/images/pasted-15.png","hash":"de838f7b5e1239be342fe0d90f72ba36afb0aafe","modified":1601033066821},{"_id":"public/images/pasted-17.png","hash":"b9b50064c7445d63d450cba61e6b97c2cbc0379c","modified":1601033066821},{"_id":"public/images/pasted-16.png","hash":"b9b50064c7445d63d450cba61e6b97c2cbc0379c","modified":1601033066821},{"_id":"public/images/pasted-26.png","hash":"40a74ce21df9db46bf95724970d7a3040f120826","modified":1601033066821},{"_id":"public/images/pasted-27.png","hash":"a9b2a877653d5a6584cdb6b5eeda6187033ce55d","modified":1601033066821},{"_id":"public/images/pasted-28.png","hash":"87479fe016d7142aff27a6eb2177e5d809cb9053","modified":1601033066821},{"_id":"public/css/mobile.css","hash":"5998f6fc27998596beb1e40e4bc3c43be2ed764c","modified":1601033066821},{"_id":"public/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1601033066821},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1601033066821},{"_id":"public/css/hl_theme/atom-light.css","hash":"d31edb9816dae6b01410028bceb91757a962f780","modified":1601033066821},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1601033066821},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1601033066821},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1601033066821},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1601033066821},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1601033066821},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1601033066821},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1601033066821},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1601033066821},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1601033066821},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1601033066821},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1601033066821},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1601033066821},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1601033066821},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1601033066821},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1601033066821},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1601033066821},{"_id":"public/css/style.css","hash":"6a3cefe3d405eaf28307e26766808d6526e6e993","modified":1601033066821},{"_id":"public/js/script.js","hash":"53b8bfe0ffa5ff153e5d759c6f2de00daadb8a07","modified":1601033066821},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1601033066821},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1601033066821},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1601033066821},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1601033066821},{"_id":"public/images/pasted-30.png","hash":"4788b741b3f03e741cf9b5fa4097bfbbdca20d4e","modified":1601033066821},{"_id":"public/images/pasted-29.png","hash":"10db3ccdcd871eb99ddb02c38b511f88c4a2f2a3","modified":1601033066821},{"_id":"public/js/gitalk.js","hash":"a75ead28e6a1fab2a006cc7332ca2d2e868ce8e1","modified":1601033066821},{"_id":"public/images/pasted-11.png","hash":"823444c5aab1c152ea3f3289c1c7c44d3780b8c5","modified":1601033066821},{"_id":"public/images/pasted-9.png","hash":"f7ebeb5408cb02545140c3e8538701f846d282d6","modified":1601033066821},{"_id":"public/images/pasted-12.png","hash":"c03ce52d3e3815bf0fa7aadf4fc52ba5b3e55c6b","modified":1601033066821},{"_id":"public/images/pasted-33.png","hash":"20256de654804ab1bbfec4656921107d65ed848a","modified":1601033066821},{"_id":"public/images/pasted-8.png","hash":"5f4c6e7d696b30fe424f63d879f7ba92c54befd3","modified":1601033066821},{"_id":"public/images/pasted-20.png","hash":"8bcd37a68733fa3fa3333ca02203f8d2445ee929","modified":1601033066821},{"_id":"public/images/pasted-19.png","hash":"8bcd37a68733fa3fa3333ca02203f8d2445ee929","modified":1601033066821},{"_id":"public/images/pasted-7.png","hash":"7c4770875501a7aa1978773733d73709085410ce","modified":1601033066821},{"_id":"public/categories/密码学/填充方式/index.html","hash":"ddb54dd2ebf92cad0cf6138464c59c643d0c5b61","modified":1601033788170}],"Category":[{"name":"ctf","_id":"ckfi5r17c0002vcu9cqwy6xy7"},{"name":"密码学","_id":"ckfi5r17g0006vcu93u09h45j"},{"name":"ECC","parent":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17p000ivcu93j31gc2w"},{"name":"rsa","parent":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17r000mvcu97qiwh28z"},{"name":"编码","parent":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17v000wvcu9c3fq1njx"},{"name":"随机数","parent":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17w0015vcu9d5v4byma"},{"name":"算法","parent":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17z001kvcu9847a2wmn"},{"name":"填充方式","parent":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5tbdm000004u9b56sd38e"}],"Data":[],"Page":[],"Post":[{"title":"MRctf2020密码","author":"人生若只如初见","date":"2020-05-29T03:35:00.000Z","_content":"# babyrsa\n* 根据主函数可知，首要目的是找到_P和_Q，首先来看_P\n* 可以发现\n![](https://img-blog.csdnimg.cn/20200329224856124.png)\n* 题目已给出P[9],所以直接目的可以手动测试周围素数，直到找到全部（这里是一部分）\n![](https://img-blog.csdnimg.cn/20200329225022887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 这里我们可以得到N\n* \n```\nfactor = pow(p, base, n)\n```\n\n* 这一句说明我们应该将这个简单RSA解出来，此时按照一般RSA的步骤求得d\n![](https://img-blog.csdnimg.cn/20200329225008750.png)\n* 这里已经得到N的所有因数，所以此时N的欧拉函数为所有因数减1相乘，即(p1-1)*(p2-1)*(...)*(p17-1)， 到此得到P的值\n* 接下来是Q\n![](https://img-blog.csdnimg.cn/20200329225330826.png)\n* 可以看到的是所有的参数已经给出，但是如果我们按照这个去算会很慢，因为数值是比较大的，所以这里我们用到了快速幂模\n\n```\nQ_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521\nQ_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743\nsub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651\ndef fastExpMod(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        # b, b^2, b^4, b^8, ... , b^(2^n)\n        b = (b*b) % m\n    return result\n_q=fastExpMod(sub_Q,Q_2 , Q_1)\n_q=sympy.nextprime(_q)\n```\n\n* 通过这个得到最终的Q的值\n* 最后按照常规RSA的解密，完成此题（完整代码）\n\n```\nimport sympy\nimport gmpy2 \nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytes\n\nbase=65537\n\nfactor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839\nn=1\np = [0 for i in range(17)]\np[0]=206027926847308612719677572554991142909\np[1]=206027926847308612719677572554991142911\np[2]=206027926847308612719677572554991142977\np[3]=206027926847308612719677572554991143071\np[4]=206027926847308612719677572554991143103\np[5]=206027926847308612719677572554991143121\np[6]=206027926847308612719677572554991143133\np[7]=206027926847308612719677572554991143317\np[8]=206027926847308612719677572554991143401\np[9]=206027926847308612719677572554991143421\nfor i in range(10,17):\n    p[i]=sympy.nextprime(p[i-1])\n\nfor i in range(17):\n        x= n*p[i]\n        n=x\n\nphi=1\nfor i in range(0,17):\n    phi *=p[i]-1\n\nd1=gmpy2.invert(base,phi)\n_p=pow(factor,d1,n)\n_p=sympy.nextprime(_p)\n\nQ_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521\nQ_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743\nsub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651\ndef fastExpMod(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        # b, b^2, b^4, b^8, ... , b^(2^n)\n        b = (b*b) % m\n    return result\n_q=fastExpMod(sub_Q,Q_2 , Q_1)\n_q=sympy.nextprime(_q)\n\n\nc=  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832\nd=gmpy2.invert(base,(_p-1)*(_q-1))\nm=pow(c,d,_p*_q)\nprint long_to_bytes(m)\n```\n\n# Easy_RSA\n* 与上一题类似，这里我们依旧先从P开始\n![](https://img-blog.csdnimg.cn/20200329225948126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 可以看到最终的P需要从Ｐ_n以及P_F_n得到，类似解二元一次方程组，这里我们使用sage来快速解方程\n![](https://img-blog.csdnimg.cn/20200329230437741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 接下来解决Q的问题\n![](https://img-blog.csdnimg.cn/20200329230512279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 这里我们拿到了N和e*d，这个问题转变为已知N和e*d，分解N,直接上脚本\n\n```\n#coding=utf-8\nfrom random import randint\nimport gmpy2\ndef oddR(r):\n    while r%2==0:\n        r=r//2\n    return r\n    \ndef bits(b):\n    k=[]\n    while b:\n        if b%2!=0:\n            k.append(1)\n        else:\n            k.append(0)\n        b>>=1\n    k.reverse()      \n    return k\n    \ndef quickmod(a,b,n):      #a^b mod n 快速幂模n运算\n    f=1\n    k=bits(b)\n    for i in range(len(k)):\n        f=(f*f)%n\n        if k[i]:\n            f=(f*a)%n\n    return f\n\ndef gcd(m,n):\n    while(n!=0):\n        m,n=n,m%n\n    return m\n\ndef func(e_d,N):\n    k=e_d-1            \n    r=oddR(k)           #求出k=2^t*r中的r\n    \n    while True:\n        b=randint(2,N-1)    #获取区间(2,N-1)的一个随机数\n        a=quickmod(b,r,N)   \n        if a==1:            \n            continue    \n        y=gcd(a-1,N)\n        if a>1 and y>1:    \n            q=N//y\n            return q\n        else:\n            r=r*2         \n    \ndef deciphering(e_d,n):    、\n    p=func(e_d,n)\n    q=n//p\n    phi=n-(p+q)+1\n    if p*q==n:\n        print p\n        print q\n    else:\n        print\"error\"\n\n\n\nn =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947\ne_d=  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201\ndeciphering(e_d,n)\n```\n\n* 得到Q，最后依旧是RSA的常规解密\n","source":"_drafts/MRctf2020密码.md","raw":"title: MRctf2020密码\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - ctf\ndate: 2020-05-29 11:35:00\n---\n# babyrsa\n* 根据主函数可知，首要目的是找到_P和_Q，首先来看_P\n* 可以发现\n![](https://img-blog.csdnimg.cn/20200329224856124.png)\n* 题目已给出P[9],所以直接目的可以手动测试周围素数，直到找到全部（这里是一部分）\n![](https://img-blog.csdnimg.cn/20200329225022887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 这里我们可以得到N\n* \n```\nfactor = pow(p, base, n)\n```\n\n* 这一句说明我们应该将这个简单RSA解出来，此时按照一般RSA的步骤求得d\n![](https://img-blog.csdnimg.cn/20200329225008750.png)\n* 这里已经得到N的所有因数，所以此时N的欧拉函数为所有因数减1相乘，即(p1-1)*(p2-1)*(...)*(p17-1)， 到此得到P的值\n* 接下来是Q\n![](https://img-blog.csdnimg.cn/20200329225330826.png)\n* 可以看到的是所有的参数已经给出，但是如果我们按照这个去算会很慢，因为数值是比较大的，所以这里我们用到了快速幂模\n\n```\nQ_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521\nQ_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743\nsub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651\ndef fastExpMod(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        # b, b^2, b^4, b^8, ... , b^(2^n)\n        b = (b*b) % m\n    return result\n_q=fastExpMod(sub_Q,Q_2 , Q_1)\n_q=sympy.nextprime(_q)\n```\n\n* 通过这个得到最终的Q的值\n* 最后按照常规RSA的解密，完成此题（完整代码）\n\n```\nimport sympy\nimport gmpy2 \nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytes\n\nbase=65537\n\nfactor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839\nn=1\np = [0 for i in range(17)]\np[0]=206027926847308612719677572554991142909\np[1]=206027926847308612719677572554991142911\np[2]=206027926847308612719677572554991142977\np[3]=206027926847308612719677572554991143071\np[4]=206027926847308612719677572554991143103\np[5]=206027926847308612719677572554991143121\np[6]=206027926847308612719677572554991143133\np[7]=206027926847308612719677572554991143317\np[8]=206027926847308612719677572554991143401\np[9]=206027926847308612719677572554991143421\nfor i in range(10,17):\n    p[i]=sympy.nextprime(p[i-1])\n\nfor i in range(17):\n        x= n*p[i]\n        n=x\n\nphi=1\nfor i in range(0,17):\n    phi *=p[i]-1\n\nd1=gmpy2.invert(base,phi)\n_p=pow(factor,d1,n)\n_p=sympy.nextprime(_p)\n\nQ_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521\nQ_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743\nsub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651\ndef fastExpMod(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        # b, b^2, b^4, b^8, ... , b^(2^n)\n        b = (b*b) % m\n    return result\n_q=fastExpMod(sub_Q,Q_2 , Q_1)\n_q=sympy.nextprime(_q)\n\n\nc=  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832\nd=gmpy2.invert(base,(_p-1)*(_q-1))\nm=pow(c,d,_p*_q)\nprint long_to_bytes(m)\n```\n\n# Easy_RSA\n* 与上一题类似，这里我们依旧先从P开始\n![](https://img-blog.csdnimg.cn/20200329225948126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 可以看到最终的P需要从Ｐ_n以及P_F_n得到，类似解二元一次方程组，这里我们使用sage来快速解方程\n![](https://img-blog.csdnimg.cn/20200329230437741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 接下来解决Q的问题\n![](https://img-blog.csdnimg.cn/20200329230512279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 这里我们拿到了N和e*d，这个问题转变为已知N和e*d，分解N,直接上脚本\n\n```\n#coding=utf-8\nfrom random import randint\nimport gmpy2\ndef oddR(r):\n    while r%2==0:\n        r=r//2\n    return r\n    \ndef bits(b):\n    k=[]\n    while b:\n        if b%2!=0:\n            k.append(1)\n        else:\n            k.append(0)\n        b>>=1\n    k.reverse()      \n    return k\n    \ndef quickmod(a,b,n):      #a^b mod n 快速幂模n运算\n    f=1\n    k=bits(b)\n    for i in range(len(k)):\n        f=(f*f)%n\n        if k[i]:\n            f=(f*a)%n\n    return f\n\ndef gcd(m,n):\n    while(n!=0):\n        m,n=n,m%n\n    return m\n\ndef func(e_d,N):\n    k=e_d-1            \n    r=oddR(k)           #求出k=2^t*r中的r\n    \n    while True:\n        b=randint(2,N-1)    #获取区间(2,N-1)的一个随机数\n        a=quickmod(b,r,N)   \n        if a==1:            \n            continue    \n        y=gcd(a-1,N)\n        if a>1 and y>1:    \n            q=N//y\n            return q\n        else:\n            r=r*2         \n    \ndef deciphering(e_d,n):    、\n    p=func(e_d,n)\n    q=n//p\n    phi=n-(p+q)+1\n    if p*q==n:\n        print p\n        print q\n    else:\n        print\"error\"\n\n\n\nn =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947\ne_d=  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201\ndeciphering(e_d,n)\n```\n\n* 得到Q，最后依旧是RSA的常规解密\n","slug":"MRctf2020密码","published":0,"updated":"2020-05-29T03:36:12.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r1760000vcu90xn9c09c","content":"<h1 id=\"babyrsa\"><a href=\"#babyrsa\" class=\"headerlink\" title=\"babyrsa\"></a>babyrsa</h1><ul>\n<li><p>根据主函数可知，首要目的是找到_P和_Q，首先来看_P</p>\n</li>\n<li><p>可以发现<br><img src=\"https://img-blog.csdnimg.cn/20200329224856124.png\" alt=\"\"></p>\n</li>\n<li><p>题目已给出P[9],所以直接目的可以手动测试周围素数，直到找到全部（这里是一部分）<br><img src=\"https://img-blog.csdnimg.cn/20200329225022887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n</li>\n<li><p>这里我们可以得到N</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factor &#x3D; pow(p, base, n)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这一句说明我们应该将这个简单RSA解出来，此时按照一般RSA的步骤求得d<br><img src=\"https://img-blog.csdnimg.cn/20200329225008750.png\" alt=\"\"></p>\n</li>\n<li><p>这里已经得到N的所有因数，所以此时N的欧拉函数为所有因数减1相乘，即(p1-1)<em>(p2-1)</em>(…)*(p17-1)， 到此得到P的值</p>\n</li>\n<li><p>接下来是Q<br><img src=\"https://img-blog.csdnimg.cn/20200329225330826.png\" alt=\"\"></p>\n</li>\n<li><p>可以看到的是所有的参数已经给出，但是如果我们按照这个去算会很慢，因为数值是比较大的，所以这里我们用到了快速幂模</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q_1&#x3D;  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span><br><span class=\"line\">Q_2&#x3D;  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span><br><span class=\"line\">sub_Q&#x3D; 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span><br><span class=\"line\">def fastExpMod(b, e, m):</span><br><span class=\"line\">    result &#x3D; 1</span><br><span class=\"line\">    while e !&#x3D; 0:</span><br><span class=\"line\">        if (e&amp;1) &#x3D;&#x3D; 1:</span><br><span class=\"line\">            # ei &#x3D; 1, then mul</span><br><span class=\"line\">            result &#x3D; (result * b) % m</span><br><span class=\"line\">        e &gt;&gt;&#x3D; 1</span><br><span class=\"line\">        # b, b^2, b^4, b^8, ... , b^(2^n)</span><br><span class=\"line\">        b &#x3D; (b*b) % m</span><br><span class=\"line\">    return result</span><br><span class=\"line\">_q&#x3D;fastExpMod(sub_Q,Q_2 , Q_1)</span><br><span class=\"line\">_q&#x3D;sympy.nextprime(_q)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过这个得到最终的Q的值</li>\n<li>最后按照常规RSA的解密，完成此题（完整代码）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\">import gmpy2 </span><br><span class=\"line\">from Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytes</span><br><span class=\"line\"></span><br><span class=\"line\">base&#x3D;65537</span><br><span class=\"line\"></span><br><span class=\"line\">factor &#x3D; 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839</span><br><span class=\"line\">n&#x3D;1</span><br><span class=\"line\">p &#x3D; [0 for i in range(17)]</span><br><span class=\"line\">p[0]&#x3D;206027926847308612719677572554991142909</span><br><span class=\"line\">p[1]&#x3D;206027926847308612719677572554991142911</span><br><span class=\"line\">p[2]&#x3D;206027926847308612719677572554991142977</span><br><span class=\"line\">p[3]&#x3D;206027926847308612719677572554991143071</span><br><span class=\"line\">p[4]&#x3D;206027926847308612719677572554991143103</span><br><span class=\"line\">p[5]&#x3D;206027926847308612719677572554991143121</span><br><span class=\"line\">p[6]&#x3D;206027926847308612719677572554991143133</span><br><span class=\"line\">p[7]&#x3D;206027926847308612719677572554991143317</span><br><span class=\"line\">p[8]&#x3D;206027926847308612719677572554991143401</span><br><span class=\"line\">p[9]&#x3D;206027926847308612719677572554991143421</span><br><span class=\"line\">for i in range(10,17):</span><br><span class=\"line\">    p[i]&#x3D;sympy.nextprime(p[i-1])</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(17):</span><br><span class=\"line\">        x&#x3D; n*p[i]</span><br><span class=\"line\">        n&#x3D;x</span><br><span class=\"line\"></span><br><span class=\"line\">phi&#x3D;1</span><br><span class=\"line\">for i in range(0,17):</span><br><span class=\"line\">    phi *&#x3D;p[i]-1</span><br><span class=\"line\"></span><br><span class=\"line\">d1&#x3D;gmpy2.invert(base,phi)</span><br><span class=\"line\">_p&#x3D;pow(factor,d1,n)</span><br><span class=\"line\">_p&#x3D;sympy.nextprime(_p)</span><br><span class=\"line\"></span><br><span class=\"line\">Q_1&#x3D;  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span><br><span class=\"line\">Q_2&#x3D;  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span><br><span class=\"line\">sub_Q&#x3D; 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span><br><span class=\"line\">def fastExpMod(b, e, m):</span><br><span class=\"line\">    result &#x3D; 1</span><br><span class=\"line\">    while e !&#x3D; 0:</span><br><span class=\"line\">        if (e&amp;1) &#x3D;&#x3D; 1:</span><br><span class=\"line\">            # ei &#x3D; 1, then mul</span><br><span class=\"line\">            result &#x3D; (result * b) % m</span><br><span class=\"line\">        e &gt;&gt;&#x3D; 1</span><br><span class=\"line\">        # b, b^2, b^4, b^8, ... , b^(2^n)</span><br><span class=\"line\">        b &#x3D; (b*b) % m</span><br><span class=\"line\">    return result</span><br><span class=\"line\">_q&#x3D;fastExpMod(sub_Q,Q_2 , Q_1)</span><br><span class=\"line\">_q&#x3D;sympy.nextprime(_q)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">c&#x3D;  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832</span><br><span class=\"line\">d&#x3D;gmpy2.invert(base,(_p-1)*(_q-1))</span><br><span class=\"line\">m&#x3D;pow(c,d,_p*_q)</span><br><span class=\"line\">print long_to_bytes(m)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Easy-RSA\"><a href=\"#Easy-RSA\" class=\"headerlink\" title=\"Easy_RSA\"></a>Easy_RSA</h1><ul>\n<li>与上一题类似，这里我们依旧先从P开始<br><img src=\"https://img-blog.csdnimg.cn/20200329225948126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>可以看到最终的P需要从Ｐ_n以及P_F_n得到，类似解二元一次方程组，这里我们使用sage来快速解方程<br><img src=\"https://img-blog.csdnimg.cn/20200329230437741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>接下来解决Q的问题<br><img src=\"https://img-blog.csdnimg.cn/20200329230512279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>这里我们拿到了N和e<em>d，这个问题转变为已知N和e</em>d，分解N,直接上脚本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding&#x3D;utf-8</span><br><span class=\"line\">from random import randint</span><br><span class=\"line\">import gmpy2</span><br><span class=\"line\">def oddR(r):</span><br><span class=\"line\">    while r%2&#x3D;&#x3D;0:</span><br><span class=\"line\">        r&#x3D;r&#x2F;&#x2F;2</span><br><span class=\"line\">    return r</span><br><span class=\"line\">    </span><br><span class=\"line\">def bits(b):</span><br><span class=\"line\">    k&#x3D;[]</span><br><span class=\"line\">    while b:</span><br><span class=\"line\">        if b%2!&#x3D;0:</span><br><span class=\"line\">            k.append(1)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            k.append(0)</span><br><span class=\"line\">        b&gt;&gt;&#x3D;1</span><br><span class=\"line\">    k.reverse()      </span><br><span class=\"line\">    return k</span><br><span class=\"line\">    </span><br><span class=\"line\">def quickmod(a,b,n):      #a^b mod n 快速幂模n运算</span><br><span class=\"line\">    f&#x3D;1</span><br><span class=\"line\">    k&#x3D;bits(b)</span><br><span class=\"line\">    for i in range(len(k)):</span><br><span class=\"line\">        f&#x3D;(f*f)%n</span><br><span class=\"line\">        if k[i]:</span><br><span class=\"line\">            f&#x3D;(f*a)%n</span><br><span class=\"line\">    return f</span><br><span class=\"line\"></span><br><span class=\"line\">def gcd(m,n):</span><br><span class=\"line\">    while(n!&#x3D;0):</span><br><span class=\"line\">        m,n&#x3D;n,m%n</span><br><span class=\"line\">    return m</span><br><span class=\"line\"></span><br><span class=\"line\">def func(e_d,N):</span><br><span class=\"line\">    k&#x3D;e_d-1            </span><br><span class=\"line\">    r&#x3D;oddR(k)           #求出k&#x3D;2^t*r中的r</span><br><span class=\"line\">    </span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        b&#x3D;randint(2,N-1)    #获取区间(2,N-1)的一个随机数</span><br><span class=\"line\">        a&#x3D;quickmod(b,r,N)   </span><br><span class=\"line\">        if a&#x3D;&#x3D;1:            </span><br><span class=\"line\">            continue    </span><br><span class=\"line\">        y&#x3D;gcd(a-1,N)</span><br><span class=\"line\">        if a&gt;1 and y&gt;1:    </span><br><span class=\"line\">            q&#x3D;N&#x2F;&#x2F;y</span><br><span class=\"line\">            return q</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            r&#x3D;r*2         </span><br><span class=\"line\">    </span><br><span class=\"line\">def deciphering(e_d,n):    、</span><br><span class=\"line\">    p&#x3D;func(e_d,n)</span><br><span class=\"line\">    q&#x3D;n&#x2F;&#x2F;p</span><br><span class=\"line\">    phi&#x3D;n-(p+q)+1</span><br><span class=\"line\">    if p*q&#x3D;&#x3D;n:</span><br><span class=\"line\">        print p</span><br><span class=\"line\">        print q</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print&quot;error&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">n &#x3D;  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947</span><br><span class=\"line\">e_d&#x3D;  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201</span><br><span class=\"line\">deciphering(e_d,n)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>得到Q，最后依旧是RSA的常规解密</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"babyrsa\"><a href=\"#babyrsa\" class=\"headerlink\" title=\"babyrsa\"></a>babyrsa</h1><ul>\n<li><p>根据主函数可知，首要目的是找到_P和_Q，首先来看_P</p>\n</li>\n<li><p>可以发现<br><img src=\"https://img-blog.csdnimg.cn/20200329224856124.png\" alt=\"\"></p>\n</li>\n<li><p>题目已给出P[9],所以直接目的可以手动测试周围素数，直到找到全部（这里是一部分）<br><img src=\"https://img-blog.csdnimg.cn/20200329225022887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n</li>\n<li><p>这里我们可以得到N</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factor &#x3D; pow(p, base, n)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这一句说明我们应该将这个简单RSA解出来，此时按照一般RSA的步骤求得d<br><img src=\"https://img-blog.csdnimg.cn/20200329225008750.png\" alt=\"\"></p>\n</li>\n<li><p>这里已经得到N的所有因数，所以此时N的欧拉函数为所有因数减1相乘，即(p1-1)<em>(p2-1)</em>(…)*(p17-1)， 到此得到P的值</p>\n</li>\n<li><p>接下来是Q<br><img src=\"https://img-blog.csdnimg.cn/20200329225330826.png\" alt=\"\"></p>\n</li>\n<li><p>可以看到的是所有的参数已经给出，但是如果我们按照这个去算会很慢，因为数值是比较大的，所以这里我们用到了快速幂模</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q_1&#x3D;  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span><br><span class=\"line\">Q_2&#x3D;  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span><br><span class=\"line\">sub_Q&#x3D; 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span><br><span class=\"line\">def fastExpMod(b, e, m):</span><br><span class=\"line\">    result &#x3D; 1</span><br><span class=\"line\">    while e !&#x3D; 0:</span><br><span class=\"line\">        if (e&amp;1) &#x3D;&#x3D; 1:</span><br><span class=\"line\">            # ei &#x3D; 1, then mul</span><br><span class=\"line\">            result &#x3D; (result * b) % m</span><br><span class=\"line\">        e &gt;&gt;&#x3D; 1</span><br><span class=\"line\">        # b, b^2, b^4, b^8, ... , b^(2^n)</span><br><span class=\"line\">        b &#x3D; (b*b) % m</span><br><span class=\"line\">    return result</span><br><span class=\"line\">_q&#x3D;fastExpMod(sub_Q,Q_2 , Q_1)</span><br><span class=\"line\">_q&#x3D;sympy.nextprime(_q)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过这个得到最终的Q的值</li>\n<li>最后按照常规RSA的解密，完成此题（完整代码）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\">import gmpy2 </span><br><span class=\"line\">from Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytes</span><br><span class=\"line\"></span><br><span class=\"line\">base&#x3D;65537</span><br><span class=\"line\"></span><br><span class=\"line\">factor &#x3D; 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839</span><br><span class=\"line\">n&#x3D;1</span><br><span class=\"line\">p &#x3D; [0 for i in range(17)]</span><br><span class=\"line\">p[0]&#x3D;206027926847308612719677572554991142909</span><br><span class=\"line\">p[1]&#x3D;206027926847308612719677572554991142911</span><br><span class=\"line\">p[2]&#x3D;206027926847308612719677572554991142977</span><br><span class=\"line\">p[3]&#x3D;206027926847308612719677572554991143071</span><br><span class=\"line\">p[4]&#x3D;206027926847308612719677572554991143103</span><br><span class=\"line\">p[5]&#x3D;206027926847308612719677572554991143121</span><br><span class=\"line\">p[6]&#x3D;206027926847308612719677572554991143133</span><br><span class=\"line\">p[7]&#x3D;206027926847308612719677572554991143317</span><br><span class=\"line\">p[8]&#x3D;206027926847308612719677572554991143401</span><br><span class=\"line\">p[9]&#x3D;206027926847308612719677572554991143421</span><br><span class=\"line\">for i in range(10,17):</span><br><span class=\"line\">    p[i]&#x3D;sympy.nextprime(p[i-1])</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(17):</span><br><span class=\"line\">        x&#x3D; n*p[i]</span><br><span class=\"line\">        n&#x3D;x</span><br><span class=\"line\"></span><br><span class=\"line\">phi&#x3D;1</span><br><span class=\"line\">for i in range(0,17):</span><br><span class=\"line\">    phi *&#x3D;p[i]-1</span><br><span class=\"line\"></span><br><span class=\"line\">d1&#x3D;gmpy2.invert(base,phi)</span><br><span class=\"line\">_p&#x3D;pow(factor,d1,n)</span><br><span class=\"line\">_p&#x3D;sympy.nextprime(_p)</span><br><span class=\"line\"></span><br><span class=\"line\">Q_1&#x3D;  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span><br><span class=\"line\">Q_2&#x3D;  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span><br><span class=\"line\">sub_Q&#x3D; 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span><br><span class=\"line\">def fastExpMod(b, e, m):</span><br><span class=\"line\">    result &#x3D; 1</span><br><span class=\"line\">    while e !&#x3D; 0:</span><br><span class=\"line\">        if (e&amp;1) &#x3D;&#x3D; 1:</span><br><span class=\"line\">            # ei &#x3D; 1, then mul</span><br><span class=\"line\">            result &#x3D; (result * b) % m</span><br><span class=\"line\">        e &gt;&gt;&#x3D; 1</span><br><span class=\"line\">        # b, b^2, b^4, b^8, ... , b^(2^n)</span><br><span class=\"line\">        b &#x3D; (b*b) % m</span><br><span class=\"line\">    return result</span><br><span class=\"line\">_q&#x3D;fastExpMod(sub_Q,Q_2 , Q_1)</span><br><span class=\"line\">_q&#x3D;sympy.nextprime(_q)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">c&#x3D;  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832</span><br><span class=\"line\">d&#x3D;gmpy2.invert(base,(_p-1)*(_q-1))</span><br><span class=\"line\">m&#x3D;pow(c,d,_p*_q)</span><br><span class=\"line\">print long_to_bytes(m)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Easy-RSA\"><a href=\"#Easy-RSA\" class=\"headerlink\" title=\"Easy_RSA\"></a>Easy_RSA</h1><ul>\n<li>与上一题类似，这里我们依旧先从P开始<br><img src=\"https://img-blog.csdnimg.cn/20200329225948126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>可以看到最终的P需要从Ｐ_n以及P_F_n得到，类似解二元一次方程组，这里我们使用sage来快速解方程<br><img src=\"https://img-blog.csdnimg.cn/20200329230437741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>接下来解决Q的问题<br><img src=\"https://img-blog.csdnimg.cn/20200329230512279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>这里我们拿到了N和e<em>d，这个问题转变为已知N和e</em>d，分解N,直接上脚本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding&#x3D;utf-8</span><br><span class=\"line\">from random import randint</span><br><span class=\"line\">import gmpy2</span><br><span class=\"line\">def oddR(r):</span><br><span class=\"line\">    while r%2&#x3D;&#x3D;0:</span><br><span class=\"line\">        r&#x3D;r&#x2F;&#x2F;2</span><br><span class=\"line\">    return r</span><br><span class=\"line\">    </span><br><span class=\"line\">def bits(b):</span><br><span class=\"line\">    k&#x3D;[]</span><br><span class=\"line\">    while b:</span><br><span class=\"line\">        if b%2!&#x3D;0:</span><br><span class=\"line\">            k.append(1)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            k.append(0)</span><br><span class=\"line\">        b&gt;&gt;&#x3D;1</span><br><span class=\"line\">    k.reverse()      </span><br><span class=\"line\">    return k</span><br><span class=\"line\">    </span><br><span class=\"line\">def quickmod(a,b,n):      #a^b mod n 快速幂模n运算</span><br><span class=\"line\">    f&#x3D;1</span><br><span class=\"line\">    k&#x3D;bits(b)</span><br><span class=\"line\">    for i in range(len(k)):</span><br><span class=\"line\">        f&#x3D;(f*f)%n</span><br><span class=\"line\">        if k[i]:</span><br><span class=\"line\">            f&#x3D;(f*a)%n</span><br><span class=\"line\">    return f</span><br><span class=\"line\"></span><br><span class=\"line\">def gcd(m,n):</span><br><span class=\"line\">    while(n!&#x3D;0):</span><br><span class=\"line\">        m,n&#x3D;n,m%n</span><br><span class=\"line\">    return m</span><br><span class=\"line\"></span><br><span class=\"line\">def func(e_d,N):</span><br><span class=\"line\">    k&#x3D;e_d-1            </span><br><span class=\"line\">    r&#x3D;oddR(k)           #求出k&#x3D;2^t*r中的r</span><br><span class=\"line\">    </span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        b&#x3D;randint(2,N-1)    #获取区间(2,N-1)的一个随机数</span><br><span class=\"line\">        a&#x3D;quickmod(b,r,N)   </span><br><span class=\"line\">        if a&#x3D;&#x3D;1:            </span><br><span class=\"line\">            continue    </span><br><span class=\"line\">        y&#x3D;gcd(a-1,N)</span><br><span class=\"line\">        if a&gt;1 and y&gt;1:    </span><br><span class=\"line\">            q&#x3D;N&#x2F;&#x2F;y</span><br><span class=\"line\">            return q</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            r&#x3D;r*2         </span><br><span class=\"line\">    </span><br><span class=\"line\">def deciphering(e_d,n):    、</span><br><span class=\"line\">    p&#x3D;func(e_d,n)</span><br><span class=\"line\">    q&#x3D;n&#x2F;&#x2F;p</span><br><span class=\"line\">    phi&#x3D;n-(p+q)+1</span><br><span class=\"line\">    if p*q&#x3D;&#x3D;n:</span><br><span class=\"line\">        print p</span><br><span class=\"line\">        print q</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print&quot;error&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">n &#x3D;  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947</span><br><span class=\"line\">e_d&#x3D;  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201</span><br><span class=\"line\">deciphering(e_d,n)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>得到Q，最后依旧是RSA的常规解密</li>\n</ul>\n"},{"title":"Ecc椭圆曲线基础","author":"人生若只如初见","date":"2020-05-27T10:16:00.000Z","_content":"* 一般，椭圆曲线可以用以下二元三阶方程的形式来表示：\n\n```\ny² = x³ + ax + b，其中a、b为系数。\n```\n\n* 它大概的几何形状如下图：\n\n![](/images/pasted-14.png)\n* 而本文要介绍的加法和乘法，就是基于这样一个奇怪的几何图形来做到的。\n* 椭圆曲线加法（非有限域）：在椭圆曲线上取一点P(Xp,Yp)，再取一点Q(Xq,Yq)，连接P、Q两点作一条直线，这条直线将在椭圆曲线上交于第三点G，过G点作垂直于X轴的直线，将过椭圆曲线另一点R（一般是关于X轴对称的点），R点则被定义为P+Q的结果，既P+Q=R：\n\n![](/images/pasted-15.png)\n\n* 当P=Q的情况下，直线将是椭圆曲线在P（Q）点上的切线，而G点是这条切线和曲线的另一个交点，同样，P+Q=R\n\n![](/images/pasted-16.png)\n\n* 通过上述的图片和文字描述，已经在几何图形上给出了椭圆曲线加法的定义，可是如果要公式化，该如何快速计算呢？\n* 这里只提供快速计算公式，不提供证明，证明可以自己再去解方程组推导一下：\n* 计算P+Q=R\n* 当P！=Q时，两点纵坐标相减的值与横坐标相减的值就是直线的斜率：\n\n```\nλ = (Yq - Yp)/(Xq - Xp)\n\n```\n* 当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除：\n\n```\nλ = (3Xp² + a)/2Yp\n```\n* 斜率计算之后，对点R的坐标进行计算，公式如下：\n\n```\nXr = (λ² - Xp - Xq)\nYr = (λ(Xp - Xr) - Yp)\n```\n* 通过上述公式，可以快速计算椭圆曲线上任意两点的加法和，这里给出加法实现的python代码：\n\n```\nif P == Q:\naaa=(3pow(P[0],2) + a)\nbbb=(2G[1])\nk=(aaa/bbb)\nelse:\naaa=(Q[1]-P[1])\nbbb=(Q[0]-P[0])\nk=(aaa/bbb)\n\nRx=(pow(k,2)-P[0] - Q[0])\nRy=(k*(P[0]-Rx) - P[1])\n椭圆曲线加法（有限域）\n```\n\n* 实数范围上光滑的椭圆曲线在密码学应用上并不合适，需要进行有限域下的离散化操作才能使用。\n\n![](/images/pasted-18.png)\n* 现在将上述的椭圆曲线加法计算公式适当修改，以适应有限域下的计算：\n\n\n```\n当P！=Q时，两点纵坐标相减的值与横坐标相减的值需要与p进行取余操作：\n\tλ = (Yq - Yp)/(Xq - Xp) mod p\n\n当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除，结果也需要与p进行取余操作：\n\n\tλ = (3Xp² + a)/2Yp mod p\n\n斜率计算之后，对点R的坐标进行计算，公式如下：\n\n\tXr = (λ² - Xp - Xq) mod p\n\n\tYr = (λ(Xp - Xr) - Yp) mod p\n\n通过比较，有限域下的计算只是对结果进行了取余操作，上述公式看起来已经解决了有限域下的椭圆曲线加法。\n\n但是如果在编写代码，计算实际的例子时，有很大可能会得到错误的结果，其根源在于\n\n\tλ = (Yq - Yp)/(Xq - Xp) mod p或λ = (3Xp² + a)/2Yp mod p\n    \n在进行取余计算之前，除数和被除数之前可能并不是一个整除的关系。如：1/4 mod 23，如果直接进行处理，将会得到结果0。\n\n但是在分数求模计算中，是如下定义的：\n\n\t计算a/b(mod n)\n\n\ta/b (mod n)=a*b^-1(mod n)\n\n计算1/b mod n=b^(-1) mod n\n就是求y，满足：\n\n\tyb = 1 mod n\n\ty是有限域F(n)上x的乘法逆元素\n\n简单点说，假设需要求上述的1/4 mod 23，可以转化为14（-1次方） mod 23，又可以转化为1(4和23的乘法逆元) mod 23。\n而计算乘法逆元，可以通过拓展欧几里得计算得到，这里对拓展欧几里得不作展开，只提供一个简单算法流程描述：\n\t\tExtendedEuclid(d,f) \n\t1 （X1,X2,X3):=(1,0,f) \n\t2   (Y1,Y2,Y3):=(0,1,d) \n\t3  if (Y3=0) then return  d'=null//无逆元 \n\t4  if (Y3=1) then return  d'=Y2  //Y2为逆元 \n\t5  Q:=X3 div Y3 \n\t6  (T1,T2,T3):=(X1-Q*Y1,X2-Q*Y2,X3-Q*Y3) \n\t7 （X1,X2,X3):=(Y1,Y2,Y3) \n\t8  (Y1,Y2,Y3):=(T1,T2,T3) \n\t9  goto 3\n```\n\n* 得到乘法逆元后，椭圆曲线上的加法运算计算就简单了，实现Python代码如下:\n\n```\n#coding:utf-8\n#欧几里得算法求最大公约数\ndef get_gcd(a, b):\n    k = a // b\n    remainder = a % b\n    while remainder != 0:\n        a = b \n        b = remainder\n        k = a // b\n        remainder = a % b\n    return b\n    \n#改进欧几里得算法求线性方程的x与y\ndef get_(a, b):\n    if b == 0:\n        return 1, 0\n    else:\n        k = a // b\n        remainder = a % b       \n        x1, y1 = get_(b, remainder)\n        x, y = y1, x1 - k * y1          \n    return x, y\n\n#返回乘法逆元\ndef yunsle(a,b):\n    #将初始b的绝对值进行保存\n    if b < 0:\n        m = abs(b)\n    else:\n    m = b\n    flag = get_gcd(a, b)\n\n    #判断最大公约数是否为1，若不是则没有逆元\n    if flag == 1:   \n    x, y = get_(a, b)   \n    x0 = x % m #对于Python '%'就是求模运算，因此不需要'+m'\n    #print(x0) #x0就是所求的逆元\n        return x0\n    else:\n    print(\"Do not have!\")\n\n\nif P == Q:\n        aaa=(3*pow(P[0],2) + a)\n        bbb=(2*P[1])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod \nelse:\n        aaa=(Q[1]-P[1])\n        bbb=(Q[0]-P[0])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod \n\nRx=(pow(k,2)-P[0] - Q[0])  % mod\nRy=(k*(P[0]-Rx) - P[1])  % mod\n```\n\n## 椭圆曲线乘法\n\n* 简单介绍完椭圆曲线上定义的加法运算，椭圆曲线上的乘法运算就比较简单了，因为加法可以退化为加法运算，就像算数上的1*3等价与1+1+1。\n\n* 假设我们需要求2P，则可以化简为P+P=2P\n\n* 同理，当我们需要求3P时，可以化简为P+2P=3P，其中2P=P+P\n\n* 最后，我们可以得到规律，当求nP时（n为任意正整数），P+(n-1)P=nP，其中(n-1)P=P+(n-2)P\n\n* 这样，通过上述介绍的椭圆曲线加法公式，完全可以进行椭圆曲线的乘法计算\n* 以本文开头的题目为例，给出Python代码实现：\n\n```\n#coding:utf-8\n#欧几里得算法求最大公约数\ndef get_gcd(a, b):\n    k = a // b\n    remainder = a % b\n    while remainder != 0:\n        a = b \n        b = remainder\n        k = a // b\n        remainder = a % b\n    return b\n    \n#改进欧几里得算法求线性方程的x与y\ndef get_(a, b):\n    if b == 0:\n        return 1, 0\n    else:\n        k = a // b\n        remainder = a % b       \n        x1, y1 = get_(b, remainder)\n        x, y = y1, x1 - k * y1          \n    return x, y\n\n#返回乘法逆元\ndef yunsle(a,b):\n    #将初始b的绝对值进行保存\n    if b < 0:\n        m = abs(b)\n    else:\n    m = b\n    flag = get_gcd(a, b)\n\n    #判断最大公约数是否为1，若不是则没有逆元\n    if flag == 1:   \n    x, y = get_(a, b)   \n    x0 = x % m #对于Python '%'就是求模运算，因此不需要'+m'\n    #print(x0) #x0就是所求的逆元\n        return x0\n    else:\n    print(\"Do not have!\")\n\n\nmod=15424654874903\n#mod=23\na=16546484\n#a=1\nb=4548674875\n#b=1\nG=[6478678675,5636379357093]\n#G=[3,10]\n#次数\nk=546768\ntemp=[6478678675,5636379357093]\n#temp=[3,10]\nfor i in range(0,k):\n    if i == 0:\n        aaa=(3*pow(G[0],2) + a)\n        bbb=(2*G[1])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod\n    else:\n        aaa=(temp[1]-G[1])\n        bbb=(temp[0]-G[0])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod\n\n    #print y\n    Rx=(pow(y,2)-G[0] - temp[0]) % mod\n    Ry=(y*(G[0]-Rx) - G[1]) % mod\n    temp=[Rx,Ry]\n    #print temp\n\nprint temp\n```\n* 参考文献：\n\n[讲解了受限域的曲线下的加法实现计算](http://blog.51cto.com/11821908/2057726)\n\n\n[只讲解了无受限域下曲线的加法](https://www.jianshu.com/p/2e6031ac3d50)\n\n\n[分数求模原理介绍](https://wenku.baidu.com/view/6f2879cca1c7aa00b52acb5f.html)\n\n\n[看雪论坛上的详细介绍，提供了加法运算的验证集](https://www.pediy.com/kssd/pediy06/pediy6014.htm)\n\n[乘法逆元求解的python实现](https://blog.csdn.net/baidu_38271024/article/details/78881031)\n","source":"_drafts/Ecc椭圆曲线基础.md","raw":"title: Ecc椭圆曲线基础\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - ECC\ndate: 2020-05-27 18:16:00\n---\n* 一般，椭圆曲线可以用以下二元三阶方程的形式来表示：\n\n```\ny² = x³ + ax + b，其中a、b为系数。\n```\n\n* 它大概的几何形状如下图：\n\n![](/images/pasted-14.png)\n* 而本文要介绍的加法和乘法，就是基于这样一个奇怪的几何图形来做到的。\n* 椭圆曲线加法（非有限域）：在椭圆曲线上取一点P(Xp,Yp)，再取一点Q(Xq,Yq)，连接P、Q两点作一条直线，这条直线将在椭圆曲线上交于第三点G，过G点作垂直于X轴的直线，将过椭圆曲线另一点R（一般是关于X轴对称的点），R点则被定义为P+Q的结果，既P+Q=R：\n\n![](/images/pasted-15.png)\n\n* 当P=Q的情况下，直线将是椭圆曲线在P（Q）点上的切线，而G点是这条切线和曲线的另一个交点，同样，P+Q=R\n\n![](/images/pasted-16.png)\n\n* 通过上述的图片和文字描述，已经在几何图形上给出了椭圆曲线加法的定义，可是如果要公式化，该如何快速计算呢？\n* 这里只提供快速计算公式，不提供证明，证明可以自己再去解方程组推导一下：\n* 计算P+Q=R\n* 当P！=Q时，两点纵坐标相减的值与横坐标相减的值就是直线的斜率：\n\n```\nλ = (Yq - Yp)/(Xq - Xp)\n\n```\n* 当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除：\n\n```\nλ = (3Xp² + a)/2Yp\n```\n* 斜率计算之后，对点R的坐标进行计算，公式如下：\n\n```\nXr = (λ² - Xp - Xq)\nYr = (λ(Xp - Xr) - Yp)\n```\n* 通过上述公式，可以快速计算椭圆曲线上任意两点的加法和，这里给出加法实现的python代码：\n\n```\nif P == Q:\naaa=(3pow(P[0],2) + a)\nbbb=(2G[1])\nk=(aaa/bbb)\nelse:\naaa=(Q[1]-P[1])\nbbb=(Q[0]-P[0])\nk=(aaa/bbb)\n\nRx=(pow(k,2)-P[0] - Q[0])\nRy=(k*(P[0]-Rx) - P[1])\n椭圆曲线加法（有限域）\n```\n\n* 实数范围上光滑的椭圆曲线在密码学应用上并不合适，需要进行有限域下的离散化操作才能使用。\n\n![](/images/pasted-18.png)\n* 现在将上述的椭圆曲线加法计算公式适当修改，以适应有限域下的计算：\n\n\n```\n当P！=Q时，两点纵坐标相减的值与横坐标相减的值需要与p进行取余操作：\n\tλ = (Yq - Yp)/(Xq - Xp) mod p\n\n当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除，结果也需要与p进行取余操作：\n\n\tλ = (3Xp² + a)/2Yp mod p\n\n斜率计算之后，对点R的坐标进行计算，公式如下：\n\n\tXr = (λ² - Xp - Xq) mod p\n\n\tYr = (λ(Xp - Xr) - Yp) mod p\n\n通过比较，有限域下的计算只是对结果进行了取余操作，上述公式看起来已经解决了有限域下的椭圆曲线加法。\n\n但是如果在编写代码，计算实际的例子时，有很大可能会得到错误的结果，其根源在于\n\n\tλ = (Yq - Yp)/(Xq - Xp) mod p或λ = (3Xp² + a)/2Yp mod p\n    \n在进行取余计算之前，除数和被除数之前可能并不是一个整除的关系。如：1/4 mod 23，如果直接进行处理，将会得到结果0。\n\n但是在分数求模计算中，是如下定义的：\n\n\t计算a/b(mod n)\n\n\ta/b (mod n)=a*b^-1(mod n)\n\n计算1/b mod n=b^(-1) mod n\n就是求y，满足：\n\n\tyb = 1 mod n\n\ty是有限域F(n)上x的乘法逆元素\n\n简单点说，假设需要求上述的1/4 mod 23，可以转化为14（-1次方） mod 23，又可以转化为1(4和23的乘法逆元) mod 23。\n而计算乘法逆元，可以通过拓展欧几里得计算得到，这里对拓展欧几里得不作展开，只提供一个简单算法流程描述：\n\t\tExtendedEuclid(d,f) \n\t1 （X1,X2,X3):=(1,0,f) \n\t2   (Y1,Y2,Y3):=(0,1,d) \n\t3  if (Y3=0) then return  d'=null//无逆元 \n\t4  if (Y3=1) then return  d'=Y2  //Y2为逆元 \n\t5  Q:=X3 div Y3 \n\t6  (T1,T2,T3):=(X1-Q*Y1,X2-Q*Y2,X3-Q*Y3) \n\t7 （X1,X2,X3):=(Y1,Y2,Y3) \n\t8  (Y1,Y2,Y3):=(T1,T2,T3) \n\t9  goto 3\n```\n\n* 得到乘法逆元后，椭圆曲线上的加法运算计算就简单了，实现Python代码如下:\n\n```\n#coding:utf-8\n#欧几里得算法求最大公约数\ndef get_gcd(a, b):\n    k = a // b\n    remainder = a % b\n    while remainder != 0:\n        a = b \n        b = remainder\n        k = a // b\n        remainder = a % b\n    return b\n    \n#改进欧几里得算法求线性方程的x与y\ndef get_(a, b):\n    if b == 0:\n        return 1, 0\n    else:\n        k = a // b\n        remainder = a % b       \n        x1, y1 = get_(b, remainder)\n        x, y = y1, x1 - k * y1          \n    return x, y\n\n#返回乘法逆元\ndef yunsle(a,b):\n    #将初始b的绝对值进行保存\n    if b < 0:\n        m = abs(b)\n    else:\n    m = b\n    flag = get_gcd(a, b)\n\n    #判断最大公约数是否为1，若不是则没有逆元\n    if flag == 1:   \n    x, y = get_(a, b)   \n    x0 = x % m #对于Python '%'就是求模运算，因此不需要'+m'\n    #print(x0) #x0就是所求的逆元\n        return x0\n    else:\n    print(\"Do not have!\")\n\n\nif P == Q:\n        aaa=(3*pow(P[0],2) + a)\n        bbb=(2*P[1])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod \nelse:\n        aaa=(Q[1]-P[1])\n        bbb=(Q[0]-P[0])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod \n\nRx=(pow(k,2)-P[0] - Q[0])  % mod\nRy=(k*(P[0]-Rx) - P[1])  % mod\n```\n\n## 椭圆曲线乘法\n\n* 简单介绍完椭圆曲线上定义的加法运算，椭圆曲线上的乘法运算就比较简单了，因为加法可以退化为加法运算，就像算数上的1*3等价与1+1+1。\n\n* 假设我们需要求2P，则可以化简为P+P=2P\n\n* 同理，当我们需要求3P时，可以化简为P+2P=3P，其中2P=P+P\n\n* 最后，我们可以得到规律，当求nP时（n为任意正整数），P+(n-1)P=nP，其中(n-1)P=P+(n-2)P\n\n* 这样，通过上述介绍的椭圆曲线加法公式，完全可以进行椭圆曲线的乘法计算\n* 以本文开头的题目为例，给出Python代码实现：\n\n```\n#coding:utf-8\n#欧几里得算法求最大公约数\ndef get_gcd(a, b):\n    k = a // b\n    remainder = a % b\n    while remainder != 0:\n        a = b \n        b = remainder\n        k = a // b\n        remainder = a % b\n    return b\n    \n#改进欧几里得算法求线性方程的x与y\ndef get_(a, b):\n    if b == 0:\n        return 1, 0\n    else:\n        k = a // b\n        remainder = a % b       \n        x1, y1 = get_(b, remainder)\n        x, y = y1, x1 - k * y1          \n    return x, y\n\n#返回乘法逆元\ndef yunsle(a,b):\n    #将初始b的绝对值进行保存\n    if b < 0:\n        m = abs(b)\n    else:\n    m = b\n    flag = get_gcd(a, b)\n\n    #判断最大公约数是否为1，若不是则没有逆元\n    if flag == 1:   \n    x, y = get_(a, b)   \n    x0 = x % m #对于Python '%'就是求模运算，因此不需要'+m'\n    #print(x0) #x0就是所求的逆元\n        return x0\n    else:\n    print(\"Do not have!\")\n\n\nmod=15424654874903\n#mod=23\na=16546484\n#a=1\nb=4548674875\n#b=1\nG=[6478678675,5636379357093]\n#G=[3,10]\n#次数\nk=546768\ntemp=[6478678675,5636379357093]\n#temp=[3,10]\nfor i in range(0,k):\n    if i == 0:\n        aaa=(3*pow(G[0],2) + a)\n        bbb=(2*G[1])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod\n    else:\n        aaa=(temp[1]-G[1])\n        bbb=(temp[0]-G[0])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod\n\n    #print y\n    Rx=(pow(y,2)-G[0] - temp[0]) % mod\n    Ry=(y*(G[0]-Rx) - G[1]) % mod\n    temp=[Rx,Ry]\n    #print temp\n\nprint temp\n```\n* 参考文献：\n\n[讲解了受限域的曲线下的加法实现计算](http://blog.51cto.com/11821908/2057726)\n\n\n[只讲解了无受限域下曲线的加法](https://www.jianshu.com/p/2e6031ac3d50)\n\n\n[分数求模原理介绍](https://wenku.baidu.com/view/6f2879cca1c7aa00b52acb5f.html)\n\n\n[看雪论坛上的详细介绍，提供了加法运算的验证集](https://www.pediy.com/kssd/pediy06/pediy6014.htm)\n\n[乘法逆元求解的python实现](https://blog.csdn.net/baidu_38271024/article/details/78881031)\n","slug":"Ecc椭圆曲线基础","published":0,"updated":"2020-05-27T10:26:38.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17b0001vcu9g07q6et6","content":"<ul>\n<li>一般，椭圆曲线可以用以下二元三阶方程的形式来表示：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y² &#x3D; x³ + ax + b，其中a、b为系数。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>它大概的几何形状如下图：</li>\n</ul>\n<p><img src=\"/images/pasted-14.png\" alt=\"\"></p>\n<ul>\n<li>而本文要介绍的加法和乘法，就是基于这样一个奇怪的几何图形来做到的。</li>\n<li>椭圆曲线加法（非有限域）：在椭圆曲线上取一点P(Xp,Yp)，再取一点Q(Xq,Yq)，连接P、Q两点作一条直线，这条直线将在椭圆曲线上交于第三点G，过G点作垂直于X轴的直线，将过椭圆曲线另一点R（一般是关于X轴对称的点），R点则被定义为P+Q的结果，既P+Q=R：</li>\n</ul>\n<p><img src=\"/images/pasted-15.png\" alt=\"\"></p>\n<ul>\n<li>当P=Q的情况下，直线将是椭圆曲线在P（Q）点上的切线，而G点是这条切线和曲线的另一个交点，同样，P+Q=R</li>\n</ul>\n<p><img src=\"/images/pasted-16.png\" alt=\"\"></p>\n<ul>\n<li>通过上述的图片和文字描述，已经在几何图形上给出了椭圆曲线加法的定义，可是如果要公式化，该如何快速计算呢？</li>\n<li>这里只提供快速计算公式，不提供证明，证明可以自己再去解方程组推导一下：</li>\n<li>计算P+Q=R</li>\n<li>当P！=Q时，两点纵坐标相减的值与横坐标相减的值就是直线的斜率：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">λ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">λ &#x3D; (3Xp² + a)&#x2F;2Yp</span><br></pre></td></tr></table></figure>\n<ul>\n<li>斜率计算之后，对点R的坐标进行计算，公式如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Xr &#x3D; (λ² - Xp - Xq)</span><br><span class=\"line\">Yr &#x3D; (λ(Xp - Xr) - Yp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过上述公式，可以快速计算椭圆曲线上任意两点的加法和，这里给出加法实现的python代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if P &#x3D;&#x3D; Q:</span><br><span class=\"line\">aaa&#x3D;(3pow(P[0],2) + a)</span><br><span class=\"line\">bbb&#x3D;(2G[1])</span><br><span class=\"line\">k&#x3D;(aaa&#x2F;bbb)</span><br><span class=\"line\">else:</span><br><span class=\"line\">aaa&#x3D;(Q[1]-P[1])</span><br><span class=\"line\">bbb&#x3D;(Q[0]-P[0])</span><br><span class=\"line\">k&#x3D;(aaa&#x2F;bbb)</span><br><span class=\"line\"></span><br><span class=\"line\">Rx&#x3D;(pow(k,2)-P[0] - Q[0])</span><br><span class=\"line\">Ry&#x3D;(k*(P[0]-Rx) - P[1])</span><br><span class=\"line\">椭圆曲线加法（有限域）</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实数范围上光滑的椭圆曲线在密码学应用上并不合适，需要进行有限域下的离散化操作才能使用。</li>\n</ul>\n<p><img src=\"/images/pasted-18.png\" alt=\"\"></p>\n<ul>\n<li>现在将上述的椭圆曲线加法计算公式适当修改，以适应有限域下的计算：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当P！&#x3D;Q时，两点纵坐标相减的值与横坐标相减的值需要与p进行取余操作：</span><br><span class=\"line\">\tλ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">当P&#x3D;Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除，结果也需要与p进行取余操作：</span><br><span class=\"line\"></span><br><span class=\"line\">\tλ &#x3D; (3Xp² + a)&#x2F;2Yp mod p</span><br><span class=\"line\"></span><br><span class=\"line\">斜率计算之后，对点R的坐标进行计算，公式如下：</span><br><span class=\"line\"></span><br><span class=\"line\">\tXr &#x3D; (λ² - Xp - Xq) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">\tYr &#x3D; (λ(Xp - Xr) - Yp) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">通过比较，有限域下的计算只是对结果进行了取余操作，上述公式看起来已经解决了有限域下的椭圆曲线加法。</span><br><span class=\"line\"></span><br><span class=\"line\">但是如果在编写代码，计算实际的例子时，有很大可能会得到错误的结果，其根源在于</span><br><span class=\"line\"></span><br><span class=\"line\">\tλ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp) mod p或λ &#x3D; (3Xp² + a)&#x2F;2Yp mod p</span><br><span class=\"line\">    </span><br><span class=\"line\">在进行取余计算之前，除数和被除数之前可能并不是一个整除的关系。如：1&#x2F;4 mod 23，如果直接进行处理，将会得到结果0。</span><br><span class=\"line\"></span><br><span class=\"line\">但是在分数求模计算中，是如下定义的：</span><br><span class=\"line\"></span><br><span class=\"line\">\t计算a&#x2F;b(mod n)</span><br><span class=\"line\"></span><br><span class=\"line\">\ta&#x2F;b (mod n)&#x3D;a*b^-1(mod n)</span><br><span class=\"line\"></span><br><span class=\"line\">计算1&#x2F;b mod n&#x3D;b^(-1) mod n</span><br><span class=\"line\">就是求y，满足：</span><br><span class=\"line\"></span><br><span class=\"line\">\tyb &#x3D; 1 mod n</span><br><span class=\"line\">\ty是有限域F(n)上x的乘法逆元素</span><br><span class=\"line\"></span><br><span class=\"line\">简单点说，假设需要求上述的1&#x2F;4 mod 23，可以转化为14（-1次方） mod 23，又可以转化为1(4和23的乘法逆元) mod 23。</span><br><span class=\"line\">而计算乘法逆元，可以通过拓展欧几里得计算得到，这里对拓展欧几里得不作展开，只提供一个简单算法流程描述：</span><br><span class=\"line\">\t\tExtendedEuclid(d,f) </span><br><span class=\"line\">\t1 （X1,X2,X3):&#x3D;(1,0,f) </span><br><span class=\"line\">\t2   (Y1,Y2,Y3):&#x3D;(0,1,d) </span><br><span class=\"line\">\t3  if (Y3&#x3D;0) then return  d&#39;&#x3D;null&#x2F;&#x2F;无逆元 </span><br><span class=\"line\">\t4  if (Y3&#x3D;1) then return  d&#39;&#x3D;Y2  &#x2F;&#x2F;Y2为逆元 </span><br><span class=\"line\">\t5  Q:&#x3D;X3 div Y3 </span><br><span class=\"line\">\t6  (T1,T2,T3):&#x3D;(X1-Q*Y1,X2-Q*Y2,X3-Q*Y3) </span><br><span class=\"line\">\t7 （X1,X2,X3):&#x3D;(Y1,Y2,Y3) </span><br><span class=\"line\">\t8  (Y1,Y2,Y3):&#x3D;(T1,T2,T3) </span><br><span class=\"line\">\t9  goto 3</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>得到乘法逆元后，椭圆曲线上的加法运算计算就简单了，实现Python代码如下:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">#欧几里得算法求最大公约数</span><br><span class=\"line\">def get_gcd(a, b):</span><br><span class=\"line\">    k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">    remainder &#x3D; a % b</span><br><span class=\"line\">    while remainder !&#x3D; 0:</span><br><span class=\"line\">        a &#x3D; b </span><br><span class=\"line\">        b &#x3D; remainder</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b</span><br><span class=\"line\">    return b</span><br><span class=\"line\">    </span><br><span class=\"line\">#改进欧几里得算法求线性方程的x与y</span><br><span class=\"line\">def get_(a, b):</span><br><span class=\"line\">    if b &#x3D;&#x3D; 0:</span><br><span class=\"line\">        return 1, 0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b       </span><br><span class=\"line\">        x1, y1 &#x3D; get_(b, remainder)</span><br><span class=\"line\">        x, y &#x3D; y1, x1 - k * y1          </span><br><span class=\"line\">    return x, y</span><br><span class=\"line\"></span><br><span class=\"line\">#返回乘法逆元</span><br><span class=\"line\">def yunsle(a,b):</span><br><span class=\"line\">    #将初始b的绝对值进行保存</span><br><span class=\"line\">    if b &lt; 0:</span><br><span class=\"line\">        m &#x3D; abs(b)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    m &#x3D; b</span><br><span class=\"line\">    flag &#x3D; get_gcd(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">    #判断最大公约数是否为1，若不是则没有逆元</span><br><span class=\"line\">    if flag &#x3D;&#x3D; 1:   </span><br><span class=\"line\">    x, y &#x3D; get_(a, b)   </span><br><span class=\"line\">    x0 &#x3D; x % m #对于Python &#39;%&#39;就是求模运算，因此不需要&#39;+m&#39;</span><br><span class=\"line\">    #print(x0) #x0就是所求的逆元</span><br><span class=\"line\">        return x0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    print(&quot;Do not have!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if P &#x3D;&#x3D; Q:</span><br><span class=\"line\">        aaa&#x3D;(3*pow(P[0],2) + a)</span><br><span class=\"line\">        bbb&#x3D;(2*P[1])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod </span><br><span class=\"line\">else:</span><br><span class=\"line\">        aaa&#x3D;(Q[1]-P[1])</span><br><span class=\"line\">        bbb&#x3D;(Q[0]-P[0])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod </span><br><span class=\"line\"></span><br><span class=\"line\">Rx&#x3D;(pow(k,2)-P[0] - Q[0])  % mod</span><br><span class=\"line\">Ry&#x3D;(k*(P[0]-Rx) - P[1])  % mod</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"椭圆曲线乘法\"><a href=\"#椭圆曲线乘法\" class=\"headerlink\" title=\"椭圆曲线乘法\"></a>椭圆曲线乘法</h2><ul>\n<li><p>简单介绍完椭圆曲线上定义的加法运算，椭圆曲线上的乘法运算就比较简单了，因为加法可以退化为加法运算，就像算数上的1*3等价与1+1+1。</p>\n</li>\n<li><p>假设我们需要求2P，则可以化简为P+P=2P</p>\n</li>\n<li><p>同理，当我们需要求3P时，可以化简为P+2P=3P，其中2P=P+P</p>\n</li>\n<li><p>最后，我们可以得到规律，当求nP时（n为任意正整数），P+(n-1)P=nP，其中(n-1)P=P+(n-2)P</p>\n</li>\n<li><p>这样，通过上述介绍的椭圆曲线加法公式，完全可以进行椭圆曲线的乘法计算</p>\n</li>\n<li><p>以本文开头的题目为例，给出Python代码实现：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">#欧几里得算法求最大公约数</span><br><span class=\"line\">def get_gcd(a, b):</span><br><span class=\"line\">    k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">    remainder &#x3D; a % b</span><br><span class=\"line\">    while remainder !&#x3D; 0:</span><br><span class=\"line\">        a &#x3D; b </span><br><span class=\"line\">        b &#x3D; remainder</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b</span><br><span class=\"line\">    return b</span><br><span class=\"line\">    </span><br><span class=\"line\">#改进欧几里得算法求线性方程的x与y</span><br><span class=\"line\">def get_(a, b):</span><br><span class=\"line\">    if b &#x3D;&#x3D; 0:</span><br><span class=\"line\">        return 1, 0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b       </span><br><span class=\"line\">        x1, y1 &#x3D; get_(b, remainder)</span><br><span class=\"line\">        x, y &#x3D; y1, x1 - k * y1          </span><br><span class=\"line\">    return x, y</span><br><span class=\"line\"></span><br><span class=\"line\">#返回乘法逆元</span><br><span class=\"line\">def yunsle(a,b):</span><br><span class=\"line\">    #将初始b的绝对值进行保存</span><br><span class=\"line\">    if b &lt; 0:</span><br><span class=\"line\">        m &#x3D; abs(b)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    m &#x3D; b</span><br><span class=\"line\">    flag &#x3D; get_gcd(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">    #判断最大公约数是否为1，若不是则没有逆元</span><br><span class=\"line\">    if flag &#x3D;&#x3D; 1:   </span><br><span class=\"line\">    x, y &#x3D; get_(a, b)   </span><br><span class=\"line\">    x0 &#x3D; x % m #对于Python &#39;%&#39;就是求模运算，因此不需要&#39;+m&#39;</span><br><span class=\"line\">    #print(x0) #x0就是所求的逆元</span><br><span class=\"line\">        return x0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    print(&quot;Do not have!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mod&#x3D;15424654874903</span><br><span class=\"line\">#mod&#x3D;23</span><br><span class=\"line\">a&#x3D;16546484</span><br><span class=\"line\">#a&#x3D;1</span><br><span class=\"line\">b&#x3D;4548674875</span><br><span class=\"line\">#b&#x3D;1</span><br><span class=\"line\">G&#x3D;[6478678675,5636379357093]</span><br><span class=\"line\">#G&#x3D;[3,10]</span><br><span class=\"line\">#次数</span><br><span class=\"line\">k&#x3D;546768</span><br><span class=\"line\">temp&#x3D;[6478678675,5636379357093]</span><br><span class=\"line\">#temp&#x3D;[3,10]</span><br><span class=\"line\">for i in range(0,k):</span><br><span class=\"line\">    if i &#x3D;&#x3D; 0:</span><br><span class=\"line\">        aaa&#x3D;(3*pow(G[0],2) + a)</span><br><span class=\"line\">        bbb&#x3D;(2*G[1])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        aaa&#x3D;(temp[1]-G[1])</span><br><span class=\"line\">        bbb&#x3D;(temp[0]-G[0])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod</span><br><span class=\"line\"></span><br><span class=\"line\">    #print y</span><br><span class=\"line\">    Rx&#x3D;(pow(y,2)-G[0] - temp[0]) % mod</span><br><span class=\"line\">    Ry&#x3D;(y*(G[0]-Rx) - G[1]) % mod</span><br><span class=\"line\">    temp&#x3D;[Rx,Ry]</span><br><span class=\"line\">    #print temp</span><br><span class=\"line\"></span><br><span class=\"line\">print temp</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参考文献：</li>\n</ul>\n<p><a href=\"http://blog.51cto.com/11821908/2057726\" target=\"_blank\" rel=\"noopener\">讲解了受限域的曲线下的加法实现计算</a></p>\n<p><a href=\"https://www.jianshu.com/p/2e6031ac3d50\" target=\"_blank\" rel=\"noopener\">只讲解了无受限域下曲线的加法</a></p>\n<p><a href=\"https://wenku.baidu.com/view/6f2879cca1c7aa00b52acb5f.html\" target=\"_blank\" rel=\"noopener\">分数求模原理介绍</a></p>\n<p><a href=\"https://www.pediy.com/kssd/pediy06/pediy6014.htm\" target=\"_blank\" rel=\"noopener\">看雪论坛上的详细介绍，提供了加法运算的验证集</a></p>\n<p><a href=\"https://blog.csdn.net/baidu_38271024/article/details/78881031\" target=\"_blank\" rel=\"noopener\">乘法逆元求解的python实现</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>一般，椭圆曲线可以用以下二元三阶方程的形式来表示：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y² &#x3D; x³ + ax + b，其中a、b为系数。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>它大概的几何形状如下图：</li>\n</ul>\n<p><img src=\"/images/pasted-14.png\" alt=\"\"></p>\n<ul>\n<li>而本文要介绍的加法和乘法，就是基于这样一个奇怪的几何图形来做到的。</li>\n<li>椭圆曲线加法（非有限域）：在椭圆曲线上取一点P(Xp,Yp)，再取一点Q(Xq,Yq)，连接P、Q两点作一条直线，这条直线将在椭圆曲线上交于第三点G，过G点作垂直于X轴的直线，将过椭圆曲线另一点R（一般是关于X轴对称的点），R点则被定义为P+Q的结果，既P+Q=R：</li>\n</ul>\n<p><img src=\"/images/pasted-15.png\" alt=\"\"></p>\n<ul>\n<li>当P=Q的情况下，直线将是椭圆曲线在P（Q）点上的切线，而G点是这条切线和曲线的另一个交点，同样，P+Q=R</li>\n</ul>\n<p><img src=\"/images/pasted-16.png\" alt=\"\"></p>\n<ul>\n<li>通过上述的图片和文字描述，已经在几何图形上给出了椭圆曲线加法的定义，可是如果要公式化，该如何快速计算呢？</li>\n<li>这里只提供快速计算公式，不提供证明，证明可以自己再去解方程组推导一下：</li>\n<li>计算P+Q=R</li>\n<li>当P！=Q时，两点纵坐标相减的值与横坐标相减的值就是直线的斜率：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">λ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">λ &#x3D; (3Xp² + a)&#x2F;2Yp</span><br></pre></td></tr></table></figure>\n<ul>\n<li>斜率计算之后，对点R的坐标进行计算，公式如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Xr &#x3D; (λ² - Xp - Xq)</span><br><span class=\"line\">Yr &#x3D; (λ(Xp - Xr) - Yp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过上述公式，可以快速计算椭圆曲线上任意两点的加法和，这里给出加法实现的python代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if P &#x3D;&#x3D; Q:</span><br><span class=\"line\">aaa&#x3D;(3pow(P[0],2) + a)</span><br><span class=\"line\">bbb&#x3D;(2G[1])</span><br><span class=\"line\">k&#x3D;(aaa&#x2F;bbb)</span><br><span class=\"line\">else:</span><br><span class=\"line\">aaa&#x3D;(Q[1]-P[1])</span><br><span class=\"line\">bbb&#x3D;(Q[0]-P[0])</span><br><span class=\"line\">k&#x3D;(aaa&#x2F;bbb)</span><br><span class=\"line\"></span><br><span class=\"line\">Rx&#x3D;(pow(k,2)-P[0] - Q[0])</span><br><span class=\"line\">Ry&#x3D;(k*(P[0]-Rx) - P[1])</span><br><span class=\"line\">椭圆曲线加法（有限域）</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实数范围上光滑的椭圆曲线在密码学应用上并不合适，需要进行有限域下的离散化操作才能使用。</li>\n</ul>\n<p><img src=\"/images/pasted-18.png\" alt=\"\"></p>\n<ul>\n<li>现在将上述的椭圆曲线加法计算公式适当修改，以适应有限域下的计算：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当P！&#x3D;Q时，两点纵坐标相减的值与横坐标相减的值需要与p进行取余操作：</span><br><span class=\"line\">\tλ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">当P&#x3D;Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除，结果也需要与p进行取余操作：</span><br><span class=\"line\"></span><br><span class=\"line\">\tλ &#x3D; (3Xp² + a)&#x2F;2Yp mod p</span><br><span class=\"line\"></span><br><span class=\"line\">斜率计算之后，对点R的坐标进行计算，公式如下：</span><br><span class=\"line\"></span><br><span class=\"line\">\tXr &#x3D; (λ² - Xp - Xq) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">\tYr &#x3D; (λ(Xp - Xr) - Yp) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">通过比较，有限域下的计算只是对结果进行了取余操作，上述公式看起来已经解决了有限域下的椭圆曲线加法。</span><br><span class=\"line\"></span><br><span class=\"line\">但是如果在编写代码，计算实际的例子时，有很大可能会得到错误的结果，其根源在于</span><br><span class=\"line\"></span><br><span class=\"line\">\tλ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp) mod p或λ &#x3D; (3Xp² + a)&#x2F;2Yp mod p</span><br><span class=\"line\">    </span><br><span class=\"line\">在进行取余计算之前，除数和被除数之前可能并不是一个整除的关系。如：1&#x2F;4 mod 23，如果直接进行处理，将会得到结果0。</span><br><span class=\"line\"></span><br><span class=\"line\">但是在分数求模计算中，是如下定义的：</span><br><span class=\"line\"></span><br><span class=\"line\">\t计算a&#x2F;b(mod n)</span><br><span class=\"line\"></span><br><span class=\"line\">\ta&#x2F;b (mod n)&#x3D;a*b^-1(mod n)</span><br><span class=\"line\"></span><br><span class=\"line\">计算1&#x2F;b mod n&#x3D;b^(-1) mod n</span><br><span class=\"line\">就是求y，满足：</span><br><span class=\"line\"></span><br><span class=\"line\">\tyb &#x3D; 1 mod n</span><br><span class=\"line\">\ty是有限域F(n)上x的乘法逆元素</span><br><span class=\"line\"></span><br><span class=\"line\">简单点说，假设需要求上述的1&#x2F;4 mod 23，可以转化为14（-1次方） mod 23，又可以转化为1(4和23的乘法逆元) mod 23。</span><br><span class=\"line\">而计算乘法逆元，可以通过拓展欧几里得计算得到，这里对拓展欧几里得不作展开，只提供一个简单算法流程描述：</span><br><span class=\"line\">\t\tExtendedEuclid(d,f) </span><br><span class=\"line\">\t1 （X1,X2,X3):&#x3D;(1,0,f) </span><br><span class=\"line\">\t2   (Y1,Y2,Y3):&#x3D;(0,1,d) </span><br><span class=\"line\">\t3  if (Y3&#x3D;0) then return  d&#39;&#x3D;null&#x2F;&#x2F;无逆元 </span><br><span class=\"line\">\t4  if (Y3&#x3D;1) then return  d&#39;&#x3D;Y2  &#x2F;&#x2F;Y2为逆元 </span><br><span class=\"line\">\t5  Q:&#x3D;X3 div Y3 </span><br><span class=\"line\">\t6  (T1,T2,T3):&#x3D;(X1-Q*Y1,X2-Q*Y2,X3-Q*Y3) </span><br><span class=\"line\">\t7 （X1,X2,X3):&#x3D;(Y1,Y2,Y3) </span><br><span class=\"line\">\t8  (Y1,Y2,Y3):&#x3D;(T1,T2,T3) </span><br><span class=\"line\">\t9  goto 3</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>得到乘法逆元后，椭圆曲线上的加法运算计算就简单了，实现Python代码如下:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">#欧几里得算法求最大公约数</span><br><span class=\"line\">def get_gcd(a, b):</span><br><span class=\"line\">    k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">    remainder &#x3D; a % b</span><br><span class=\"line\">    while remainder !&#x3D; 0:</span><br><span class=\"line\">        a &#x3D; b </span><br><span class=\"line\">        b &#x3D; remainder</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b</span><br><span class=\"line\">    return b</span><br><span class=\"line\">    </span><br><span class=\"line\">#改进欧几里得算法求线性方程的x与y</span><br><span class=\"line\">def get_(a, b):</span><br><span class=\"line\">    if b &#x3D;&#x3D; 0:</span><br><span class=\"line\">        return 1, 0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b       </span><br><span class=\"line\">        x1, y1 &#x3D; get_(b, remainder)</span><br><span class=\"line\">        x, y &#x3D; y1, x1 - k * y1          </span><br><span class=\"line\">    return x, y</span><br><span class=\"line\"></span><br><span class=\"line\">#返回乘法逆元</span><br><span class=\"line\">def yunsle(a,b):</span><br><span class=\"line\">    #将初始b的绝对值进行保存</span><br><span class=\"line\">    if b &lt; 0:</span><br><span class=\"line\">        m &#x3D; abs(b)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    m &#x3D; b</span><br><span class=\"line\">    flag &#x3D; get_gcd(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">    #判断最大公约数是否为1，若不是则没有逆元</span><br><span class=\"line\">    if flag &#x3D;&#x3D; 1:   </span><br><span class=\"line\">    x, y &#x3D; get_(a, b)   </span><br><span class=\"line\">    x0 &#x3D; x % m #对于Python &#39;%&#39;就是求模运算，因此不需要&#39;+m&#39;</span><br><span class=\"line\">    #print(x0) #x0就是所求的逆元</span><br><span class=\"line\">        return x0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    print(&quot;Do not have!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if P &#x3D;&#x3D; Q:</span><br><span class=\"line\">        aaa&#x3D;(3*pow(P[0],2) + a)</span><br><span class=\"line\">        bbb&#x3D;(2*P[1])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod </span><br><span class=\"line\">else:</span><br><span class=\"line\">        aaa&#x3D;(Q[1]-P[1])</span><br><span class=\"line\">        bbb&#x3D;(Q[0]-P[0])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod </span><br><span class=\"line\"></span><br><span class=\"line\">Rx&#x3D;(pow(k,2)-P[0] - Q[0])  % mod</span><br><span class=\"line\">Ry&#x3D;(k*(P[0]-Rx) - P[1])  % mod</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"椭圆曲线乘法\"><a href=\"#椭圆曲线乘法\" class=\"headerlink\" title=\"椭圆曲线乘法\"></a>椭圆曲线乘法</h2><ul>\n<li><p>简单介绍完椭圆曲线上定义的加法运算，椭圆曲线上的乘法运算就比较简单了，因为加法可以退化为加法运算，就像算数上的1*3等价与1+1+1。</p>\n</li>\n<li><p>假设我们需要求2P，则可以化简为P+P=2P</p>\n</li>\n<li><p>同理，当我们需要求3P时，可以化简为P+2P=3P，其中2P=P+P</p>\n</li>\n<li><p>最后，我们可以得到规律，当求nP时（n为任意正整数），P+(n-1)P=nP，其中(n-1)P=P+(n-2)P</p>\n</li>\n<li><p>这样，通过上述介绍的椭圆曲线加法公式，完全可以进行椭圆曲线的乘法计算</p>\n</li>\n<li><p>以本文开头的题目为例，给出Python代码实现：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">#欧几里得算法求最大公约数</span><br><span class=\"line\">def get_gcd(a, b):</span><br><span class=\"line\">    k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">    remainder &#x3D; a % b</span><br><span class=\"line\">    while remainder !&#x3D; 0:</span><br><span class=\"line\">        a &#x3D; b </span><br><span class=\"line\">        b &#x3D; remainder</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b</span><br><span class=\"line\">    return b</span><br><span class=\"line\">    </span><br><span class=\"line\">#改进欧几里得算法求线性方程的x与y</span><br><span class=\"line\">def get_(a, b):</span><br><span class=\"line\">    if b &#x3D;&#x3D; 0:</span><br><span class=\"line\">        return 1, 0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b       </span><br><span class=\"line\">        x1, y1 &#x3D; get_(b, remainder)</span><br><span class=\"line\">        x, y &#x3D; y1, x1 - k * y1          </span><br><span class=\"line\">    return x, y</span><br><span class=\"line\"></span><br><span class=\"line\">#返回乘法逆元</span><br><span class=\"line\">def yunsle(a,b):</span><br><span class=\"line\">    #将初始b的绝对值进行保存</span><br><span class=\"line\">    if b &lt; 0:</span><br><span class=\"line\">        m &#x3D; abs(b)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    m &#x3D; b</span><br><span class=\"line\">    flag &#x3D; get_gcd(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">    #判断最大公约数是否为1，若不是则没有逆元</span><br><span class=\"line\">    if flag &#x3D;&#x3D; 1:   </span><br><span class=\"line\">    x, y &#x3D; get_(a, b)   </span><br><span class=\"line\">    x0 &#x3D; x % m #对于Python &#39;%&#39;就是求模运算，因此不需要&#39;+m&#39;</span><br><span class=\"line\">    #print(x0) #x0就是所求的逆元</span><br><span class=\"line\">        return x0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    print(&quot;Do not have!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mod&#x3D;15424654874903</span><br><span class=\"line\">#mod&#x3D;23</span><br><span class=\"line\">a&#x3D;16546484</span><br><span class=\"line\">#a&#x3D;1</span><br><span class=\"line\">b&#x3D;4548674875</span><br><span class=\"line\">#b&#x3D;1</span><br><span class=\"line\">G&#x3D;[6478678675,5636379357093]</span><br><span class=\"line\">#G&#x3D;[3,10]</span><br><span class=\"line\">#次数</span><br><span class=\"line\">k&#x3D;546768</span><br><span class=\"line\">temp&#x3D;[6478678675,5636379357093]</span><br><span class=\"line\">#temp&#x3D;[3,10]</span><br><span class=\"line\">for i in range(0,k):</span><br><span class=\"line\">    if i &#x3D;&#x3D; 0:</span><br><span class=\"line\">        aaa&#x3D;(3*pow(G[0],2) + a)</span><br><span class=\"line\">        bbb&#x3D;(2*G[1])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        aaa&#x3D;(temp[1]-G[1])</span><br><span class=\"line\">        bbb&#x3D;(temp[0]-G[0])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod</span><br><span class=\"line\"></span><br><span class=\"line\">    #print y</span><br><span class=\"line\">    Rx&#x3D;(pow(y,2)-G[0] - temp[0]) % mod</span><br><span class=\"line\">    Ry&#x3D;(y*(G[0]-Rx) - G[1]) % mod</span><br><span class=\"line\">    temp&#x3D;[Rx,Ry]</span><br><span class=\"line\">    #print temp</span><br><span class=\"line\"></span><br><span class=\"line\">print temp</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参考文献：</li>\n</ul>\n<p><a href=\"http://blog.51cto.com/11821908/2057726\" target=\"_blank\" rel=\"noopener\">讲解了受限域的曲线下的加法实现计算</a></p>\n<p><a href=\"https://www.jianshu.com/p/2e6031ac3d50\" target=\"_blank\" rel=\"noopener\">只讲解了无受限域下曲线的加法</a></p>\n<p><a href=\"https://wenku.baidu.com/view/6f2879cca1c7aa00b52acb5f.html\" target=\"_blank\" rel=\"noopener\">分数求模原理介绍</a></p>\n<p><a href=\"https://www.pediy.com/kssd/pediy06/pediy6014.htm\" target=\"_blank\" rel=\"noopener\">看雪论坛上的详细介绍，提供了加法运算的验证集</a></p>\n<p><a href=\"https://blog.csdn.net/baidu_38271024/article/details/78881031\" target=\"_blank\" rel=\"noopener\">乘法逆元求解的python实现</a></p>\n"},{"title":"RsaLsbOrcalePadding","author":"人生若只如初见","date":"2020-09-06T01:23:00.000Z","_content":"[参考1](https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack)\n[参考2](https://zhuanlan.zhihu.com/p/140726869)\n[参考3](https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/)\n\n## 原理公式\n\n```\n攻击者得到密文C=Pe(mod n) ，将其乘以2e(mod N), 并作为密文发送出去，若返回f(2P)\n如果f(2P) 返回的最后一位是0，那么2P<N，即P<N/2\n如果f(2P) 返回的最后一位是1，那么2P>N，即 P>N/2\n接着我们来看看2P 和 4P\n如果返回的是（偶，偶），那么有 P<N/4\n如果返回的是（偶，奇），那么有N/4<P<N/2\n如果返回的是（偶，奇），那么有N/2<P<3N/4\n如果返回的是（奇，奇），那么有3N/4<P<N\n\n```\n* 数论中有个定理，c = 偶数 a mod 奇数 b，若 c 为奇数，则 a>b，若 c 为偶数，则 a<b\n\n## 推导过程\n\n\n![](/images/pasted-33.png)\n\n\n\n## 脚本：\n\n```\nL = 0\nH = n\nt = pow(2, e, n)\nfor _ in range(n.bit_length()):\n    c = (t * c) % n\n    if oracle(c) == 0:\n        H = (L + H) // 2\n    else:\n        L = (L + H) // 2\nm = L # plain text\n```\n\n\n* 可忽略\n## service.py\n\n```\n#!/usr/bin/python -u\nfrom Crypto.Util.number import *\nfrom Crypto.PublicKey import RSA\nimport random\n#from SECRET import flag\nflag = \"CTF{this_is_my_test_flag}\"\nm = bytes_to_long(flag)\nkey = RSA.generate(1024)\nc = pow(m, key.e, key.n)\nprint(\"Welcome to BACKDOORCTF17\\n\")\nprint(\"PublicKey:\\n\")\nprint(\"N = \" + str(key.n) + \"\\n\")\nprint(\"e = \" + str(key.e) + \"\\n\")\nprint(\"c = \" + str(c) + \"\\n\")\nwhile True:\n    try:\n        temp_c = int(raw_input(\"temp_c = \"))\n        temp_m = pow(temp_c, key.d, key.n)\n    except:\n        break\n    l = str(((temp_m&5) * random.randint(1,10000))%(2*(random.randint(1,10000))))\n    print \"l = \"+l\n```\n\n## solve.py\n\n```\n# -*- coding: utf-8 -*-\n#/usr/bin/env python\nfrom pwn import *\nimport libnum\nimport Crypto\nimport re\nfrom binascii import hexlify,unhexlify\nif len(sys.argv)>1:\n    p=remote(\"127.0.0.1\",2334)\nelse:\n    p=remote('127.0.0.1',2333)\n#context.log_level = 'debug'\ndef oracle(c):\n    l = []\n    for i in range(20):\n        p.sendline(str(c))\n        s = p.recvuntil(\"temp_c\")\n        l.append(int(re.findall(\"l\\s*=\\s*([0-9]*)\",s)[0]))\n    flag0 = 0\n    flag2 = 0\n    for i in range(20):\n        if l[i]%2 != 0:\n            flag0 = 1\n        if l[i] > 10000:\n            flag2 = 1\n    return [flag2,flag0]\ndef main():\n    ss = p.recvuntil(\"temp_c\")\n    N = int(re.findall(\"N\\s*=\\s*(\\d+)\",ss)[0])\n    e = int(re.findall(\"e\\s*=\\s*(\\d+)\",ss)[0])\n    c = int(re.findall(\"c\\s*=\\s*(\\d+)\",ss)[0])\n    size = libnum.len_in_bits(N)\n    print \"N=\",N\n    print \"e=\",e\n    print \"c=\",c\n    c = (pow(2,e,N)*c)%N\n    LB = 0\n    UB = N\n    i = 1\n    while LB!=UB:\n        flag = oracle(c)\n        print i,flag\n        if flag[1]%2==0:\n            UB = (LB+UB)/2\n        else:\n            LB = (LB+UB)/2\n        c = (pow(2,e,N)*c)%N\n        i += 1\n    print LB\n    print UB\n    for i in range(-128,128,0):\n        LB += i\n        if pow(LB,e,N)==C:\n            print unhexlify(hex(LB)[2:-1])\n            exit(0)\nif __name__ == '__main__':\n    main()\n    p.interactive()\n```","source":"_drafts/RsaLsbOrcalePadding.md","raw":"title: RsaLsbOrcalePadding\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-09-06 09:23:00\n---\n[参考1](https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack)\n[参考2](https://zhuanlan.zhihu.com/p/140726869)\n[参考3](https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/)\n\n## 原理公式\n\n```\n攻击者得到密文C=Pe(mod n) ，将其乘以2e(mod N), 并作为密文发送出去，若返回f(2P)\n如果f(2P) 返回的最后一位是0，那么2P<N，即P<N/2\n如果f(2P) 返回的最后一位是1，那么2P>N，即 P>N/2\n接着我们来看看2P 和 4P\n如果返回的是（偶，偶），那么有 P<N/4\n如果返回的是（偶，奇），那么有N/4<P<N/2\n如果返回的是（偶，奇），那么有N/2<P<3N/4\n如果返回的是（奇，奇），那么有3N/4<P<N\n\n```\n* 数论中有个定理，c = 偶数 a mod 奇数 b，若 c 为奇数，则 a>b，若 c 为偶数，则 a<b\n\n## 推导过程\n\n\n![](/images/pasted-33.png)\n\n\n\n## 脚本：\n\n```\nL = 0\nH = n\nt = pow(2, e, n)\nfor _ in range(n.bit_length()):\n    c = (t * c) % n\n    if oracle(c) == 0:\n        H = (L + H) // 2\n    else:\n        L = (L + H) // 2\nm = L # plain text\n```\n\n\n* 可忽略\n## service.py\n\n```\n#!/usr/bin/python -u\nfrom Crypto.Util.number import *\nfrom Crypto.PublicKey import RSA\nimport random\n#from SECRET import flag\nflag = \"CTF{this_is_my_test_flag}\"\nm = bytes_to_long(flag)\nkey = RSA.generate(1024)\nc = pow(m, key.e, key.n)\nprint(\"Welcome to BACKDOORCTF17\\n\")\nprint(\"PublicKey:\\n\")\nprint(\"N = \" + str(key.n) + \"\\n\")\nprint(\"e = \" + str(key.e) + \"\\n\")\nprint(\"c = \" + str(c) + \"\\n\")\nwhile True:\n    try:\n        temp_c = int(raw_input(\"temp_c = \"))\n        temp_m = pow(temp_c, key.d, key.n)\n    except:\n        break\n    l = str(((temp_m&5) * random.randint(1,10000))%(2*(random.randint(1,10000))))\n    print \"l = \"+l\n```\n\n## solve.py\n\n```\n# -*- coding: utf-8 -*-\n#/usr/bin/env python\nfrom pwn import *\nimport libnum\nimport Crypto\nimport re\nfrom binascii import hexlify,unhexlify\nif len(sys.argv)>1:\n    p=remote(\"127.0.0.1\",2334)\nelse:\n    p=remote('127.0.0.1',2333)\n#context.log_level = 'debug'\ndef oracle(c):\n    l = []\n    for i in range(20):\n        p.sendline(str(c))\n        s = p.recvuntil(\"temp_c\")\n        l.append(int(re.findall(\"l\\s*=\\s*([0-9]*)\",s)[0]))\n    flag0 = 0\n    flag2 = 0\n    for i in range(20):\n        if l[i]%2 != 0:\n            flag0 = 1\n        if l[i] > 10000:\n            flag2 = 1\n    return [flag2,flag0]\ndef main():\n    ss = p.recvuntil(\"temp_c\")\n    N = int(re.findall(\"N\\s*=\\s*(\\d+)\",ss)[0])\n    e = int(re.findall(\"e\\s*=\\s*(\\d+)\",ss)[0])\n    c = int(re.findall(\"c\\s*=\\s*(\\d+)\",ss)[0])\n    size = libnum.len_in_bits(N)\n    print \"N=\",N\n    print \"e=\",e\n    print \"c=\",c\n    c = (pow(2,e,N)*c)%N\n    LB = 0\n    UB = N\n    i = 1\n    while LB!=UB:\n        flag = oracle(c)\n        print i,flag\n        if flag[1]%2==0:\n            UB = (LB+UB)/2\n        else:\n            LB = (LB+UB)/2\n        c = (pow(2,e,N)*c)%N\n        i += 1\n    print LB\n    print UB\n    for i in range(-128,128,0):\n        LB += i\n        if pow(LB,e,N)==C:\n            print unhexlify(hex(LB)[2:-1])\n            exit(0)\nif __name__ == '__main__':\n    main()\n    p.interactive()\n```","slug":"RsaLsbOrcalePadding","published":0,"updated":"2020-09-25T11:27:55.508Z","_id":"ckfi5r17d0003vcu992fh02iu","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack\" target=\"_blank\" rel=\"noopener\">参考1</a><br><a href=\"https://zhuanlan.zhihu.com/p/140726869\" target=\"_blank\" rel=\"noopener\">参考2</a><br><a href=\"https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/\" target=\"_blank\" rel=\"noopener\">参考3</a></p>\n<h2 id=\"原理公式\"><a href=\"#原理公式\" class=\"headerlink\" title=\"原理公式\"></a>原理公式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">攻击者得到密文C&#x3D;Pe(mod n) ，将其乘以2e(mod N), 并作为密文发送出去，若返回f(2P)</span><br><span class=\"line\">如果f(2P) 返回的最后一位是0，那么2P&lt;N，即P&lt;N&#x2F;2</span><br><span class=\"line\">如果f(2P) 返回的最后一位是1，那么2P&gt;N，即 P&gt;N&#x2F;2</span><br><span class=\"line\">接着我们来看看2P 和 4P</span><br><span class=\"line\">如果返回的是（偶，偶），那么有 P&lt;N&#x2F;4</span><br><span class=\"line\">如果返回的是（偶，奇），那么有N&#x2F;4&lt;P&lt;N&#x2F;2</span><br><span class=\"line\">如果返回的是（偶，奇），那么有N&#x2F;2&lt;P&lt;3N&#x2F;4</span><br><span class=\"line\">如果返回的是（奇，奇），那么有3N&#x2F;4&lt;P&lt;N</span><br></pre></td></tr></table></figure>\n<ul>\n<li>数论中有个定理，c = 偶数 a mod 奇数 b，若 c 为奇数，则 a&gt;b，若 c 为偶数，则 a&lt;b</li>\n</ul>\n<h2 id=\"推导过程\"><a href=\"#推导过程\" class=\"headerlink\" title=\"推导过程\"></a>推导过程</h2><p><img src=\"/images/pasted-33.png\" alt=\"\"></p>\n<h2 id=\"脚本：\"><a href=\"#脚本：\" class=\"headerlink\" title=\"脚本：\"></a>脚本：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L &#x3D; 0</span><br><span class=\"line\">H &#x3D; n</span><br><span class=\"line\">t &#x3D; pow(2, e, n)</span><br><span class=\"line\">for _ in range(n.bit_length()):</span><br><span class=\"line\">    c &#x3D; (t * c) % n</span><br><span class=\"line\">    if oracle(c) &#x3D;&#x3D; 0:</span><br><span class=\"line\">        H &#x3D; (L + H) &#x2F;&#x2F; 2</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        L &#x3D; (L + H) &#x2F;&#x2F; 2</span><br><span class=\"line\">m &#x3D; L # plain text</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>可忽略<h2 id=\"service-py\"><a href=\"#service-py\" class=\"headerlink\" title=\"service.py\"></a>service.py</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;python -u</span><br><span class=\"line\">from Crypto.Util.number import *</span><br><span class=\"line\">from Crypto.PublicKey import RSA</span><br><span class=\"line\">import random</span><br><span class=\"line\">#from SECRET import flag</span><br><span class=\"line\">flag &#x3D; &quot;CTF&#123;this_is_my_test_flag&#125;&quot;</span><br><span class=\"line\">m &#x3D; bytes_to_long(flag)</span><br><span class=\"line\">key &#x3D; RSA.generate(1024)</span><br><span class=\"line\">c &#x3D; pow(m, key.e, key.n)</span><br><span class=\"line\">print(&quot;Welcome to BACKDOORCTF17\\n&quot;)</span><br><span class=\"line\">print(&quot;PublicKey:\\n&quot;)</span><br><span class=\"line\">print(&quot;N &#x3D; &quot; + str(key.n) + &quot;\\n&quot;)</span><br><span class=\"line\">print(&quot;e &#x3D; &quot; + str(key.e) + &quot;\\n&quot;)</span><br><span class=\"line\">print(&quot;c &#x3D; &quot; + str(c) + &quot;\\n&quot;)</span><br><span class=\"line\">while True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        temp_c &#x3D; int(raw_input(&quot;temp_c &#x3D; &quot;))</span><br><span class=\"line\">        temp_m &#x3D; pow(temp_c, key.d, key.n)</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        break</span><br><span class=\"line\">    l &#x3D; str(((temp_m&amp;5) * random.randint(1,10000))%(2*(random.randint(1,10000))))</span><br><span class=\"line\">    print &quot;l &#x3D; &quot;+l</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"solve-py\"><a href=\"#solve-py\" class=\"headerlink\" title=\"solve.py\"></a>solve.py</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">#&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\">import libnum</span><br><span class=\"line\">import Crypto</span><br><span class=\"line\">import re</span><br><span class=\"line\">from binascii import hexlify,unhexlify</span><br><span class=\"line\">if len(sys.argv)&gt;1:</span><br><span class=\"line\">    p&#x3D;remote(&quot;127.0.0.1&quot;,2334)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    p&#x3D;remote(&#39;127.0.0.1&#39;,2333)</span><br><span class=\"line\">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class=\"line\">def oracle(c):</span><br><span class=\"line\">    l &#x3D; []</span><br><span class=\"line\">    for i in range(20):</span><br><span class=\"line\">        p.sendline(str(c))</span><br><span class=\"line\">        s &#x3D; p.recvuntil(&quot;temp_c&quot;)</span><br><span class=\"line\">        l.append(int(re.findall(&quot;l\\s*&#x3D;\\s*([0-9]*)&quot;,s)[0]))</span><br><span class=\"line\">    flag0 &#x3D; 0</span><br><span class=\"line\">    flag2 &#x3D; 0</span><br><span class=\"line\">    for i in range(20):</span><br><span class=\"line\">        if l[i]%2 !&#x3D; 0:</span><br><span class=\"line\">            flag0 &#x3D; 1</span><br><span class=\"line\">        if l[i] &gt; 10000:</span><br><span class=\"line\">            flag2 &#x3D; 1</span><br><span class=\"line\">    return [flag2,flag0]</span><br><span class=\"line\">def main():</span><br><span class=\"line\">    ss &#x3D; p.recvuntil(&quot;temp_c&quot;)</span><br><span class=\"line\">    N &#x3D; int(re.findall(&quot;N\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    e &#x3D; int(re.findall(&quot;e\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    c &#x3D; int(re.findall(&quot;c\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    size &#x3D; libnum.len_in_bits(N)</span><br><span class=\"line\">    print &quot;N&#x3D;&quot;,N</span><br><span class=\"line\">    print &quot;e&#x3D;&quot;,e</span><br><span class=\"line\">    print &quot;c&#x3D;&quot;,c</span><br><span class=\"line\">    c &#x3D; (pow(2,e,N)*c)%N</span><br><span class=\"line\">    LB &#x3D; 0</span><br><span class=\"line\">    UB &#x3D; N</span><br><span class=\"line\">    i &#x3D; 1</span><br><span class=\"line\">    while LB!&#x3D;UB:</span><br><span class=\"line\">        flag &#x3D; oracle(c)</span><br><span class=\"line\">        print i,flag</span><br><span class=\"line\">        if flag[1]%2&#x3D;&#x3D;0:</span><br><span class=\"line\">            UB &#x3D; (LB+UB)&#x2F;2</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            LB &#x3D; (LB+UB)&#x2F;2</span><br><span class=\"line\">        c &#x3D; (pow(2,e,N)*c)%N</span><br><span class=\"line\">        i +&#x3D; 1</span><br><span class=\"line\">    print LB</span><br><span class=\"line\">    print UB</span><br><span class=\"line\">    for i in range(-128,128,0):</span><br><span class=\"line\">        LB +&#x3D; i</span><br><span class=\"line\">        if pow(LB,e,N)&#x3D;&#x3D;C:</span><br><span class=\"line\">            print unhexlify(hex(LB)[2:-1])</span><br><span class=\"line\">            exit(0)</span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">    main()</span><br><span class=\"line\">    p.interactive()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack\" target=\"_blank\" rel=\"noopener\">参考1</a><br><a href=\"https://zhuanlan.zhihu.com/p/140726869\" target=\"_blank\" rel=\"noopener\">参考2</a><br><a href=\"https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/\" target=\"_blank\" rel=\"noopener\">参考3</a></p>\n<h2 id=\"原理公式\"><a href=\"#原理公式\" class=\"headerlink\" title=\"原理公式\"></a>原理公式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">攻击者得到密文C&#x3D;Pe(mod n) ，将其乘以2e(mod N), 并作为密文发送出去，若返回f(2P)</span><br><span class=\"line\">如果f(2P) 返回的最后一位是0，那么2P&lt;N，即P&lt;N&#x2F;2</span><br><span class=\"line\">如果f(2P) 返回的最后一位是1，那么2P&gt;N，即 P&gt;N&#x2F;2</span><br><span class=\"line\">接着我们来看看2P 和 4P</span><br><span class=\"line\">如果返回的是（偶，偶），那么有 P&lt;N&#x2F;4</span><br><span class=\"line\">如果返回的是（偶，奇），那么有N&#x2F;4&lt;P&lt;N&#x2F;2</span><br><span class=\"line\">如果返回的是（偶，奇），那么有N&#x2F;2&lt;P&lt;3N&#x2F;4</span><br><span class=\"line\">如果返回的是（奇，奇），那么有3N&#x2F;4&lt;P&lt;N</span><br></pre></td></tr></table></figure>\n<ul>\n<li>数论中有个定理，c = 偶数 a mod 奇数 b，若 c 为奇数，则 a&gt;b，若 c 为偶数，则 a&lt;b</li>\n</ul>\n<h2 id=\"推导过程\"><a href=\"#推导过程\" class=\"headerlink\" title=\"推导过程\"></a>推导过程</h2><p><img src=\"/images/pasted-33.png\" alt=\"\"></p>\n<h2 id=\"脚本：\"><a href=\"#脚本：\" class=\"headerlink\" title=\"脚本：\"></a>脚本：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L &#x3D; 0</span><br><span class=\"line\">H &#x3D; n</span><br><span class=\"line\">t &#x3D; pow(2, e, n)</span><br><span class=\"line\">for _ in range(n.bit_length()):</span><br><span class=\"line\">    c &#x3D; (t * c) % n</span><br><span class=\"line\">    if oracle(c) &#x3D;&#x3D; 0:</span><br><span class=\"line\">        H &#x3D; (L + H) &#x2F;&#x2F; 2</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        L &#x3D; (L + H) &#x2F;&#x2F; 2</span><br><span class=\"line\">m &#x3D; L # plain text</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>可忽略<h2 id=\"service-py\"><a href=\"#service-py\" class=\"headerlink\" title=\"service.py\"></a>service.py</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;python -u</span><br><span class=\"line\">from Crypto.Util.number import *</span><br><span class=\"line\">from Crypto.PublicKey import RSA</span><br><span class=\"line\">import random</span><br><span class=\"line\">#from SECRET import flag</span><br><span class=\"line\">flag &#x3D; &quot;CTF&#123;this_is_my_test_flag&#125;&quot;</span><br><span class=\"line\">m &#x3D; bytes_to_long(flag)</span><br><span class=\"line\">key &#x3D; RSA.generate(1024)</span><br><span class=\"line\">c &#x3D; pow(m, key.e, key.n)</span><br><span class=\"line\">print(&quot;Welcome to BACKDOORCTF17\\n&quot;)</span><br><span class=\"line\">print(&quot;PublicKey:\\n&quot;)</span><br><span class=\"line\">print(&quot;N &#x3D; &quot; + str(key.n) + &quot;\\n&quot;)</span><br><span class=\"line\">print(&quot;e &#x3D; &quot; + str(key.e) + &quot;\\n&quot;)</span><br><span class=\"line\">print(&quot;c &#x3D; &quot; + str(c) + &quot;\\n&quot;)</span><br><span class=\"line\">while True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        temp_c &#x3D; int(raw_input(&quot;temp_c &#x3D; &quot;))</span><br><span class=\"line\">        temp_m &#x3D; pow(temp_c, key.d, key.n)</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        break</span><br><span class=\"line\">    l &#x3D; str(((temp_m&amp;5) * random.randint(1,10000))%(2*(random.randint(1,10000))))</span><br><span class=\"line\">    print &quot;l &#x3D; &quot;+l</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"solve-py\"><a href=\"#solve-py\" class=\"headerlink\" title=\"solve.py\"></a>solve.py</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">#&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\">import libnum</span><br><span class=\"line\">import Crypto</span><br><span class=\"line\">import re</span><br><span class=\"line\">from binascii import hexlify,unhexlify</span><br><span class=\"line\">if len(sys.argv)&gt;1:</span><br><span class=\"line\">    p&#x3D;remote(&quot;127.0.0.1&quot;,2334)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    p&#x3D;remote(&#39;127.0.0.1&#39;,2333)</span><br><span class=\"line\">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class=\"line\">def oracle(c):</span><br><span class=\"line\">    l &#x3D; []</span><br><span class=\"line\">    for i in range(20):</span><br><span class=\"line\">        p.sendline(str(c))</span><br><span class=\"line\">        s &#x3D; p.recvuntil(&quot;temp_c&quot;)</span><br><span class=\"line\">        l.append(int(re.findall(&quot;l\\s*&#x3D;\\s*([0-9]*)&quot;,s)[0]))</span><br><span class=\"line\">    flag0 &#x3D; 0</span><br><span class=\"line\">    flag2 &#x3D; 0</span><br><span class=\"line\">    for i in range(20):</span><br><span class=\"line\">        if l[i]%2 !&#x3D; 0:</span><br><span class=\"line\">            flag0 &#x3D; 1</span><br><span class=\"line\">        if l[i] &gt; 10000:</span><br><span class=\"line\">            flag2 &#x3D; 1</span><br><span class=\"line\">    return [flag2,flag0]</span><br><span class=\"line\">def main():</span><br><span class=\"line\">    ss &#x3D; p.recvuntil(&quot;temp_c&quot;)</span><br><span class=\"line\">    N &#x3D; int(re.findall(&quot;N\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    e &#x3D; int(re.findall(&quot;e\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    c &#x3D; int(re.findall(&quot;c\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    size &#x3D; libnum.len_in_bits(N)</span><br><span class=\"line\">    print &quot;N&#x3D;&quot;,N</span><br><span class=\"line\">    print &quot;e&#x3D;&quot;,e</span><br><span class=\"line\">    print &quot;c&#x3D;&quot;,c</span><br><span class=\"line\">    c &#x3D; (pow(2,e,N)*c)%N</span><br><span class=\"line\">    LB &#x3D; 0</span><br><span class=\"line\">    UB &#x3D; N</span><br><span class=\"line\">    i &#x3D; 1</span><br><span class=\"line\">    while LB!&#x3D;UB:</span><br><span class=\"line\">        flag &#x3D; oracle(c)</span><br><span class=\"line\">        print i,flag</span><br><span class=\"line\">        if flag[1]%2&#x3D;&#x3D;0:</span><br><span class=\"line\">            UB &#x3D; (LB+UB)&#x2F;2</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            LB &#x3D; (LB+UB)&#x2F;2</span><br><span class=\"line\">        c &#x3D; (pow(2,e,N)*c)%N</span><br><span class=\"line\">        i +&#x3D; 1</span><br><span class=\"line\">    print LB</span><br><span class=\"line\">    print UB</span><br><span class=\"line\">    for i in range(-128,128,0):</span><br><span class=\"line\">        LB +&#x3D; i</span><br><span class=\"line\">        if pow(LB,e,N)&#x3D;&#x3D;C:</span><br><span class=\"line\">            print unhexlify(hex(LB)[2:-1])</span><br><span class=\"line\">            exit(0)</span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">    main()</span><br><span class=\"line\">    p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"Unicode编码衍生出的编码方案","author":"人生若只如初见","date":"2020-05-27T10:11:00.000Z","_content":"* 字符集和字符编码不是一个概念，字符集定义了文字和二进制的对应关系，为字符分配了唯一的编号，而字符编码规定了如何将文字的编号存储到内存中。有的字符集在制定时就考虑到了编码的问题，是和编码结合在一起的；有的字符集只管制定字符的编号，至于怎么编码，是其他人的事情。\n\n## 方案1：为每个字符分配固定长度的内存\n\n* 一种方案是为每个字符分配固定长度的内存，并且这块内存要足够大，可以容纳下所有的字符编号。这种方案最简单，直接将字符编号放入内存中即可，不需要任何转换，并且以后在字符串中定位字符、修改字符都非常容易。\n\n```\n字符串就是一串连续的字符序列，它们在内存中按次序挨着存放。在C语言中，字符串由双引号\" \"包围起来。\n```\n* 目前的 Unicode 已经收录了上百万的字符，至少需要三个字节才能容纳下所有的字符编号。假设字符串”A3中￥”的 Unicode 编码值（十六进制形式）分别是 2A、31、DA49、BB672C，那么它们在内存中的存储形式为：\n\n![](/images/pasted-13.png)\n* 在几乎所有的字符集中，常用字符的编号往往比较小，罕见字符的编号往往比较大，包括 Unicode 在内。\n* A和3是 ASCII 编码中的字符，Unicode 为了兼容 ASCII，在设计时刻意保留了原来 ASCII 中字符的编号，所以英文字母和阿拉伯数字在 Unicode 中的编号都非常小，用一个字节足以容纳。中是一个汉字，编号比较大，一般要用两个字节才能容纳。￥可以看做是一个极其少见，或者只有极少数地区才会使用到的字符，这样的字符编号往往比较大，有时候需要三个字节才能容纳。\n\n```\n￥是人民币符号，是汉字文化的一部分，它和其它汉字一样，实际上是用两个字节存储的，不过这里我们为了演示，故意犯错地说它需要三个字节。\n```\n* 上图中带灰色背景的字节是没有用到的字节，它们就是被浪费掉的一部分内存空间，这就是用固定长度的内存来存储字符编号的缺点：常用字符的编号都比较小，这种方案会浪费很多内存空间，对于以英文为主的国家，比如美国、加拿大、英国等，内存利用率甚至会低于 50%。\n## 方案2：为每个字符分配尽量少的内存\n\n* 既然上面的方案有缺点，那我们就来改进一下。改进的思路也很明确，就是把空闲的内存压缩掉，为每个字符分配尽量少的字节，例如，A和3分配一个字节足以，中分配两个字节足以，如下图所示：\n\n* 这样虽然没有了空闲字节，不浪费任何内存空间了，但是又出现新的问题了：如果我不告诉你，你怎么知道2A表示一个字符，而不是2A31或者2A31DA才表示一个字符呢？后面的字符也有类似的问题。\n\n* 对于第一种方案，每个字符占用的字节数是固定的，很容易区分各个字符；而这种方案，不同的字符占用的字节数不同，字符之间也没有特殊的标记，计算机是无法定位字符的。\n\n* 这种方案还需要改进，必须让不同的字符编码有不同的特征，并且字符处理程序也需要调整，要根据这些特征去识别不同的字符。\n\n## 要想让不同的字符编码有不同的特征，可以从两个方面下手：\n\n### 1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\n\n* 例如，对于编号较小的、用一个字节足以容纳的字符，我们就可以规定这个字符编号的最高位（Bit）必须是 0；对于编号较大的、要用两个字节存储的字符，我们就可以规定这个字符编号的高字节的最高位必须是 1，低字节的最高位必须是 0；对于编号更大的、需要三个字节存储的字符，我们就可以规定这个字符编号的所有字节的最高位都必须是 1。\n\n* 程序在定位字符时，从前往后依次扫描，如果发现当前字节的最高位是 0，那么就把这一个字节作为一个字符编号。如果发现当前字节的最高位是 1，那么就继续往后扫描，如果后续字节的最高位是 0，那么就把这两个字节作为一个字符编号；如果后续字节的最高位是 1，那么就把挨着的三个字节作为一个字符编号。\n\n* 这种方案的缺点很明显，它会导致字符集不连续，中间留出大量空白区域，这些空白区域不能定义任何字符。\n\n### 2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\n\n* 那么，转换后的编号要具备什么样的特征呢？其实也可以像上面一样，根据字节的最高位是 0 还是 1 来判断字符到底占用了几个字节。\n\n* 相比第一种方案，这种方案有缺点也有优点：\n\n```\n缺点就是多了转换过程，字符在存储和读取时要经过转换，效率低；\n优点就是在制定字符集时不用考虑存储的问题，可以任意排布字符。\n```","source":"_drafts/Unicode编码衍生出的编码方案.md","raw":"title: Unicode编码衍生出的编码方案\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 编码\ndate: 2020-05-27 18:11:00\n---\n* 字符集和字符编码不是一个概念，字符集定义了文字和二进制的对应关系，为字符分配了唯一的编号，而字符编码规定了如何将文字的编号存储到内存中。有的字符集在制定时就考虑到了编码的问题，是和编码结合在一起的；有的字符集只管制定字符的编号，至于怎么编码，是其他人的事情。\n\n## 方案1：为每个字符分配固定长度的内存\n\n* 一种方案是为每个字符分配固定长度的内存，并且这块内存要足够大，可以容纳下所有的字符编号。这种方案最简单，直接将字符编号放入内存中即可，不需要任何转换，并且以后在字符串中定位字符、修改字符都非常容易。\n\n```\n字符串就是一串连续的字符序列，它们在内存中按次序挨着存放。在C语言中，字符串由双引号\" \"包围起来。\n```\n* 目前的 Unicode 已经收录了上百万的字符，至少需要三个字节才能容纳下所有的字符编号。假设字符串”A3中￥”的 Unicode 编码值（十六进制形式）分别是 2A、31、DA49、BB672C，那么它们在内存中的存储形式为：\n\n![](/images/pasted-13.png)\n* 在几乎所有的字符集中，常用字符的编号往往比较小，罕见字符的编号往往比较大，包括 Unicode 在内。\n* A和3是 ASCII 编码中的字符，Unicode 为了兼容 ASCII，在设计时刻意保留了原来 ASCII 中字符的编号，所以英文字母和阿拉伯数字在 Unicode 中的编号都非常小，用一个字节足以容纳。中是一个汉字，编号比较大，一般要用两个字节才能容纳。￥可以看做是一个极其少见，或者只有极少数地区才会使用到的字符，这样的字符编号往往比较大，有时候需要三个字节才能容纳。\n\n```\n￥是人民币符号，是汉字文化的一部分，它和其它汉字一样，实际上是用两个字节存储的，不过这里我们为了演示，故意犯错地说它需要三个字节。\n```\n* 上图中带灰色背景的字节是没有用到的字节，它们就是被浪费掉的一部分内存空间，这就是用固定长度的内存来存储字符编号的缺点：常用字符的编号都比较小，这种方案会浪费很多内存空间，对于以英文为主的国家，比如美国、加拿大、英国等，内存利用率甚至会低于 50%。\n## 方案2：为每个字符分配尽量少的内存\n\n* 既然上面的方案有缺点，那我们就来改进一下。改进的思路也很明确，就是把空闲的内存压缩掉，为每个字符分配尽量少的字节，例如，A和3分配一个字节足以，中分配两个字节足以，如下图所示：\n\n* 这样虽然没有了空闲字节，不浪费任何内存空间了，但是又出现新的问题了：如果我不告诉你，你怎么知道2A表示一个字符，而不是2A31或者2A31DA才表示一个字符呢？后面的字符也有类似的问题。\n\n* 对于第一种方案，每个字符占用的字节数是固定的，很容易区分各个字符；而这种方案，不同的字符占用的字节数不同，字符之间也没有特殊的标记，计算机是无法定位字符的。\n\n* 这种方案还需要改进，必须让不同的字符编码有不同的特征，并且字符处理程序也需要调整，要根据这些特征去识别不同的字符。\n\n## 要想让不同的字符编码有不同的特征，可以从两个方面下手：\n\n### 1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\n\n* 例如，对于编号较小的、用一个字节足以容纳的字符，我们就可以规定这个字符编号的最高位（Bit）必须是 0；对于编号较大的、要用两个字节存储的字符，我们就可以规定这个字符编号的高字节的最高位必须是 1，低字节的最高位必须是 0；对于编号更大的、需要三个字节存储的字符，我们就可以规定这个字符编号的所有字节的最高位都必须是 1。\n\n* 程序在定位字符时，从前往后依次扫描，如果发现当前字节的最高位是 0，那么就把这一个字节作为一个字符编号。如果发现当前字节的最高位是 1，那么就继续往后扫描，如果后续字节的最高位是 0，那么就把这两个字节作为一个字符编号；如果后续字节的最高位是 1，那么就把挨着的三个字节作为一个字符编号。\n\n* 这种方案的缺点很明显，它会导致字符集不连续，中间留出大量空白区域，这些空白区域不能定义任何字符。\n\n### 2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\n\n* 那么，转换后的编号要具备什么样的特征呢？其实也可以像上面一样，根据字节的最高位是 0 还是 1 来判断字符到底占用了几个字节。\n\n* 相比第一种方案，这种方案有缺点也有优点：\n\n```\n缺点就是多了转换过程，字符在存储和读取时要经过转换，效率低；\n优点就是在制定字符集时不用考虑存储的问题，可以任意排布字符。\n```","slug":"Unicode编码衍生出的编码方案","published":0,"updated":"2020-05-27T10:15:18.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17e0004vcu96enl2ss9","content":"<ul>\n<li>字符集和字符编码不是一个概念，字符集定义了文字和二进制的对应关系，为字符分配了唯一的编号，而字符编码规定了如何将文字的编号存储到内存中。有的字符集在制定时就考虑到了编码的问题，是和编码结合在一起的；有的字符集只管制定字符的编号，至于怎么编码，是其他人的事情。</li>\n</ul>\n<h2 id=\"方案1：为每个字符分配固定长度的内存\"><a href=\"#方案1：为每个字符分配固定长度的内存\" class=\"headerlink\" title=\"方案1：为每个字符分配固定长度的内存\"></a>方案1：为每个字符分配固定长度的内存</h2><ul>\n<li>一种方案是为每个字符分配固定长度的内存，并且这块内存要足够大，可以容纳下所有的字符编号。这种方案最简单，直接将字符编号放入内存中即可，不需要任何转换，并且以后在字符串中定位字符、修改字符都非常容易。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符串就是一串连续的字符序列，它们在内存中按次序挨着存放。在C语言中，字符串由双引号&quot; &quot;包围起来。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>目前的 Unicode 已经收录了上百万的字符，至少需要三个字节才能容纳下所有的字符编号。假设字符串”A3中￥”的 Unicode 编码值（十六进制形式）分别是 2A、31、DA49、BB672C，那么它们在内存中的存储形式为：</li>\n</ul>\n<p><img src=\"/images/pasted-13.png\" alt=\"\"></p>\n<ul>\n<li>在几乎所有的字符集中，常用字符的编号往往比较小，罕见字符的编号往往比较大，包括 Unicode 在内。</li>\n<li>A和3是 ASCII 编码中的字符，Unicode 为了兼容 ASCII，在设计时刻意保留了原来 ASCII 中字符的编号，所以英文字母和阿拉伯数字在 Unicode 中的编号都非常小，用一个字节足以容纳。中是一个汉字，编号比较大，一般要用两个字节才能容纳。￥可以看做是一个极其少见，或者只有极少数地区才会使用到的字符，这样的字符编号往往比较大，有时候需要三个字节才能容纳。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">￥是人民币符号，是汉字文化的一部分，它和其它汉字一样，实际上是用两个字节存储的，不过这里我们为了演示，故意犯错地说它需要三个字节。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>上图中带灰色背景的字节是没有用到的字节，它们就是被浪费掉的一部分内存空间，这就是用固定长度的内存来存储字符编号的缺点：常用字符的编号都比较小，这种方案会浪费很多内存空间，对于以英文为主的国家，比如美国、加拿大、英国等，内存利用率甚至会低于 50%。</p>\n<h2 id=\"方案2：为每个字符分配尽量少的内存\"><a href=\"#方案2：为每个字符分配尽量少的内存\" class=\"headerlink\" title=\"方案2：为每个字符分配尽量少的内存\"></a>方案2：为每个字符分配尽量少的内存</h2></li>\n<li><p>既然上面的方案有缺点，那我们就来改进一下。改进的思路也很明确，就是把空闲的内存压缩掉，为每个字符分配尽量少的字节，例如，A和3分配一个字节足以，中分配两个字节足以，如下图所示：</p>\n</li>\n<li><p>这样虽然没有了空闲字节，不浪费任何内存空间了，但是又出现新的问题了：如果我不告诉你，你怎么知道2A表示一个字符，而不是2A31或者2A31DA才表示一个字符呢？后面的字符也有类似的问题。</p>\n</li>\n<li><p>对于第一种方案，每个字符占用的字节数是固定的，很容易区分各个字符；而这种方案，不同的字符占用的字节数不同，字符之间也没有特殊的标记，计算机是无法定位字符的。</p>\n</li>\n<li><p>这种方案还需要改进，必须让不同的字符编码有不同的特征，并且字符处理程序也需要调整，要根据这些特征去识别不同的字符。</p>\n</li>\n</ul>\n<h2 id=\"要想让不同的字符编码有不同的特征，可以从两个方面下手：\"><a href=\"#要想让不同的字符编码有不同的特征，可以从两个方面下手：\" class=\"headerlink\" title=\"要想让不同的字符编码有不同的特征，可以从两个方面下手：\"></a>要想让不同的字符编码有不同的特征，可以从两个方面下手：</h2><h3 id=\"1-一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\"><a href=\"#1-一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\" class=\"headerlink\" title=\"1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\"></a>1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。</h3><ul>\n<li><p>例如，对于编号较小的、用一个字节足以容纳的字符，我们就可以规定这个字符编号的最高位（Bit）必须是 0；对于编号较大的、要用两个字节存储的字符，我们就可以规定这个字符编号的高字节的最高位必须是 1，低字节的最高位必须是 0；对于编号更大的、需要三个字节存储的字符，我们就可以规定这个字符编号的所有字节的最高位都必须是 1。</p>\n</li>\n<li><p>程序在定位字符时，从前往后依次扫描，如果发现当前字节的最高位是 0，那么就把这一个字节作为一个字符编号。如果发现当前字节的最高位是 1，那么就继续往后扫描，如果后续字节的最高位是 0，那么就把这两个字节作为一个字符编号；如果后续字节的最高位是 1，那么就把挨着的三个字节作为一个字符编号。</p>\n</li>\n<li><p>这种方案的缺点很明显，它会导致字符集不连续，中间留出大量空白区域，这些空白区域不能定义任何字符。</p>\n</li>\n</ul>\n<h3 id=\"2-二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\"><a href=\"#2-二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\" class=\"headerlink\" title=\"2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\"></a>2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。</h3><ul>\n<li><p>那么，转换后的编号要具备什么样的特征呢？其实也可以像上面一样，根据字节的最高位是 0 还是 1 来判断字符到底占用了几个字节。</p>\n</li>\n<li><p>相比第一种方案，这种方案有缺点也有优点：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缺点就是多了转换过程，字符在存储和读取时要经过转换，效率低；</span><br><span class=\"line\">优点就是在制定字符集时不用考虑存储的问题，可以任意排布字符。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>字符集和字符编码不是一个概念，字符集定义了文字和二进制的对应关系，为字符分配了唯一的编号，而字符编码规定了如何将文字的编号存储到内存中。有的字符集在制定时就考虑到了编码的问题，是和编码结合在一起的；有的字符集只管制定字符的编号，至于怎么编码，是其他人的事情。</li>\n</ul>\n<h2 id=\"方案1：为每个字符分配固定长度的内存\"><a href=\"#方案1：为每个字符分配固定长度的内存\" class=\"headerlink\" title=\"方案1：为每个字符分配固定长度的内存\"></a>方案1：为每个字符分配固定长度的内存</h2><ul>\n<li>一种方案是为每个字符分配固定长度的内存，并且这块内存要足够大，可以容纳下所有的字符编号。这种方案最简单，直接将字符编号放入内存中即可，不需要任何转换，并且以后在字符串中定位字符、修改字符都非常容易。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符串就是一串连续的字符序列，它们在内存中按次序挨着存放。在C语言中，字符串由双引号&quot; &quot;包围起来。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>目前的 Unicode 已经收录了上百万的字符，至少需要三个字节才能容纳下所有的字符编号。假设字符串”A3中￥”的 Unicode 编码值（十六进制形式）分别是 2A、31、DA49、BB672C，那么它们在内存中的存储形式为：</li>\n</ul>\n<p><img src=\"/images/pasted-13.png\" alt=\"\"></p>\n<ul>\n<li>在几乎所有的字符集中，常用字符的编号往往比较小，罕见字符的编号往往比较大，包括 Unicode 在内。</li>\n<li>A和3是 ASCII 编码中的字符，Unicode 为了兼容 ASCII，在设计时刻意保留了原来 ASCII 中字符的编号，所以英文字母和阿拉伯数字在 Unicode 中的编号都非常小，用一个字节足以容纳。中是一个汉字，编号比较大，一般要用两个字节才能容纳。￥可以看做是一个极其少见，或者只有极少数地区才会使用到的字符，这样的字符编号往往比较大，有时候需要三个字节才能容纳。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">￥是人民币符号，是汉字文化的一部分，它和其它汉字一样，实际上是用两个字节存储的，不过这里我们为了演示，故意犯错地说它需要三个字节。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>上图中带灰色背景的字节是没有用到的字节，它们就是被浪费掉的一部分内存空间，这就是用固定长度的内存来存储字符编号的缺点：常用字符的编号都比较小，这种方案会浪费很多内存空间，对于以英文为主的国家，比如美国、加拿大、英国等，内存利用率甚至会低于 50%。</p>\n<h2 id=\"方案2：为每个字符分配尽量少的内存\"><a href=\"#方案2：为每个字符分配尽量少的内存\" class=\"headerlink\" title=\"方案2：为每个字符分配尽量少的内存\"></a>方案2：为每个字符分配尽量少的内存</h2></li>\n<li><p>既然上面的方案有缺点，那我们就来改进一下。改进的思路也很明确，就是把空闲的内存压缩掉，为每个字符分配尽量少的字节，例如，A和3分配一个字节足以，中分配两个字节足以，如下图所示：</p>\n</li>\n<li><p>这样虽然没有了空闲字节，不浪费任何内存空间了，但是又出现新的问题了：如果我不告诉你，你怎么知道2A表示一个字符，而不是2A31或者2A31DA才表示一个字符呢？后面的字符也有类似的问题。</p>\n</li>\n<li><p>对于第一种方案，每个字符占用的字节数是固定的，很容易区分各个字符；而这种方案，不同的字符占用的字节数不同，字符之间也没有特殊的标记，计算机是无法定位字符的。</p>\n</li>\n<li><p>这种方案还需要改进，必须让不同的字符编码有不同的特征，并且字符处理程序也需要调整，要根据这些特征去识别不同的字符。</p>\n</li>\n</ul>\n<h2 id=\"要想让不同的字符编码有不同的特征，可以从两个方面下手：\"><a href=\"#要想让不同的字符编码有不同的特征，可以从两个方面下手：\" class=\"headerlink\" title=\"要想让不同的字符编码有不同的特征，可以从两个方面下手：\"></a>要想让不同的字符编码有不同的特征，可以从两个方面下手：</h2><h3 id=\"1-一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\"><a href=\"#1-一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\" class=\"headerlink\" title=\"1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\"></a>1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。</h3><ul>\n<li><p>例如，对于编号较小的、用一个字节足以容纳的字符，我们就可以规定这个字符编号的最高位（Bit）必须是 0；对于编号较大的、要用两个字节存储的字符，我们就可以规定这个字符编号的高字节的最高位必须是 1，低字节的最高位必须是 0；对于编号更大的、需要三个字节存储的字符，我们就可以规定这个字符编号的所有字节的最高位都必须是 1。</p>\n</li>\n<li><p>程序在定位字符时，从前往后依次扫描，如果发现当前字节的最高位是 0，那么就把这一个字节作为一个字符编号。如果发现当前字节的最高位是 1，那么就继续往后扫描，如果后续字节的最高位是 0，那么就把这两个字节作为一个字符编号；如果后续字节的最高位是 1，那么就把挨着的三个字节作为一个字符编号。</p>\n</li>\n<li><p>这种方案的缺点很明显，它会导致字符集不连续，中间留出大量空白区域，这些空白区域不能定义任何字符。</p>\n</li>\n</ul>\n<h3 id=\"2-二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\"><a href=\"#2-二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\" class=\"headerlink\" title=\"2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\"></a>2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。</h3><ul>\n<li><p>那么，转换后的编号要具备什么样的特征呢？其实也可以像上面一样，根据字节的最高位是 0 还是 1 来判断字符到底占用了几个字节。</p>\n</li>\n<li><p>相比第一种方案，这种方案有缺点也有优点：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缺点就是多了转换过程，字符在存储和读取时要经过转换，效率低；</span><br><span class=\"line\">优点就是在制定字符集时不用考虑存储的问题，可以任意排布字符。</span><br></pre></td></tr></table></figure>"},{"title":"lcg线性同余随机数生成器","author":"人生若只如初见","date":"2020-05-28T01:49:00.000Z","_content":"# 随机数\n* 计算机产生随机数在概率算法设计中，随机数分为真随机数和伪随机数，计算机只能产生伪随机数。\n* 真随机数：类似放射性元素的衰变等无法控制的且无法复制数据\n* 伪随机数：通过较为容量大的数学公式产生的数字，具有可猜测性。在得到生成器的随机数种子之后，可以通过计算得到伪随机数序列。\n* 通用性伪随机数生成器：s0=seed,s[i+1]=f(s[i])，推广形式：s[i+1]=f(s[i],s[i-1],……,s[i-t])，其中t是固定整数。\n* 满足通用性伪随机数的推广的例子，线性同余生成器：s0=seed,s[i+1]=a*s[i]+b mod m,(i=0,1,2……)\n# 线性同余生成器\n## 线性同余序列的周期\n* 在线性同余序列中存在自封闭特性，具有以下性质\n\n```\n1、存在递推关系：x[i+1]=f(x[i])\n2、其中的任意元素x[i]都在[0,m-1]范围内\n3、f(x)的值也在[0,m-1]范围内\n```\n\n* 性质证明及周期计算\n\n```\n1、假设两个集合s={0,1,2,3,……,m-2,m-1} size(s)=m\n    T={} size(T)=0\n    将产生的伪随机数挪到集合T中\n2、先生成第一个伪随机数x1\n    s={0,1,2,3,……,m-2,m-1} size(s)=m\n    T={x1} size(T)=1\n3、根据第一个伪随机数x1生成第二个伪随机数x2，判断x2的归属，若x2属于集合s则一个周期还未结束，若x2属于集合T此处正好等于x1则一个周期产生，周期p=1\n\n推论到x[i]即生成的每个x都属于s，都转移到T\n此时：s={0,1,2,3,……,m-2,m-1} size(s)=m\n      T={x1,x2,x3,……,x[i-2],x[i-1]} size(T)=i-1\n若x[i]=f(x[i-1])∈s，则未能完成一周期\n若x[i]=f(x[i-1])∈T，则已完成一个周期，周期p≤i-1\n\n周期p也可能等于m，也就是最终s为空集，T中包含0到m-1的所有元素，且f(X[m])=x1\n因此一定存在一个周期p≤m\n推论：\n    1) 当周期p＜m时，选取不同的随机数种子也就是x0(初始值)产生的周期可能会不同。\n    2) 当周期p=m时，序列的周期与初始值x0无关，周期必定为p。\n```\n\n\n## 参数选择\n### m的选择\n* 一般来说，模数应该尽可能大，这样可以产生较长的周期，常见的模数挑选一般为2**w（常用的为2^32或者2^64，产生结果直接截断最右边的32bit或者64bit）\n* 当模数为2**w的时候，最后产生未模之前的数字与最后的结果相比，是该数字的比特位向右边减w位的结果，这种形式在低位上的随机性并不是很好。可以在产生随机数后截取高位比特，将随机性不好的低位比特直接舍弃。\n### a的选择（0≤a<m）\n* a的取值会很大程度上影响整个生成器的安全性，应该使周期尽量长（最长为m），但是周期长的序列随机性比较差。\n* 当a=1时，生成器的公式为s[i+1]=s[i]+b mod m\n* 当a=0时，生成器的公式为s[i+1]=b mod m，安全性为0.\n* 当a取值其他数字时，影响随机数生成器生成数字的周期。\n### 选取参数的总结\n* 模数m尽可能大，一般大于2**30\n* 当m选取为2的幂次方时，应该满足a mod 8=5\n* 当m和a选取都合理时，b需要在与m互质的条件下选取。\n### 最大周期符合的条件：\n* m和b互质\n* m的所有质因子的积能整除a-1\n* 如果m是4的倍数，a-1也是\n* a,b,seed都比m小\n* a,b是正整数\n\n\n# 例题\n\n![](/images/pasted-20.png)\n* 根据线性同余生成器lcg可得：lcg=(a*x+c)%m\n* 根据题目，当输入数字时，可以得到多个连续随机数，根据伪随机数生成的机制，可以了解到，随机数的生成只要知道随机数种子就可以破解\n* 类推到线性同余方程组，也就是说当知道a,c,m时即可知道随机数的整个序列\n* 例如：假设我们知道lcg0,那么lcg1=(a*lcg0+c)%m,同理lcg2=(a*lcg1+c)%m\n* 此时我们随意提交多次，可以从中得到连续的随机数，类比于lcg0,lcg1,lcg2的关系\n* lcg0=32081     lcg1=23815     lcg2=1237   lcg3=2387\n* 爆破模数module，每次moudle值改变时，都进行下面的操作：\n\n```\nlcg1=(a*lcg0+c)%m       lcg2=(a*lcg1+c)%m\n\n两式相减   左边为:lcg2-lcg1   右边为:(a*lcg1+c)-(a*lcg0+c)\n\n化简为: [lcg2-lcg1=a*(lcg1-lcg0) ] %m\n\n根据求余运算规则可知  \n[a=(lcg2-lcg1)*gmpy2.invert(lcg1-lcg0,m)]%m\n\n此时代入lcg0,lcg1,lcg2之后可求得a\n\n代入lcg1=(a*lcg0+c)%m,把c当作未知数放到等式左边后，式子为：\nc=[lcg1*gmpy2.invert(a*lcg0,m)]%m\n\n类推lcg3_guess=(a*lcg2+c)%m\n将求得地lcg3_guess与lcg3比较，如果相等，证明求得的a,c,m为正确值\n否则，m=m+1，继续验证\n\n注意：\n1、这个式子成立条件是两边同时对m求余\n2、gmpy2.invert(x1,x2)是求与x1%x2同余的最小数，二者在求余操作后等价，因为余数相等，该式表示余数，类似7%5=2%5\n```\n\n\n* 求得正确的a,c,m之后，线性同余方程为 lcg[i]=(a*lcg[i-1]+c)%m\n* 多次提交成功之后，获得flag","source":"_drafts/lcg线性同余随机数生成器.md","raw":"title: lcg线性同余随机数生成器\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 随机数\ndate: 2020-05-28 09:49:00\n---\n# 随机数\n* 计算机产生随机数在概率算法设计中，随机数分为真随机数和伪随机数，计算机只能产生伪随机数。\n* 真随机数：类似放射性元素的衰变等无法控制的且无法复制数据\n* 伪随机数：通过较为容量大的数学公式产生的数字，具有可猜测性。在得到生成器的随机数种子之后，可以通过计算得到伪随机数序列。\n* 通用性伪随机数生成器：s0=seed,s[i+1]=f(s[i])，推广形式：s[i+1]=f(s[i],s[i-1],……,s[i-t])，其中t是固定整数。\n* 满足通用性伪随机数的推广的例子，线性同余生成器：s0=seed,s[i+1]=a*s[i]+b mod m,(i=0,1,2……)\n# 线性同余生成器\n## 线性同余序列的周期\n* 在线性同余序列中存在自封闭特性，具有以下性质\n\n```\n1、存在递推关系：x[i+1]=f(x[i])\n2、其中的任意元素x[i]都在[0,m-1]范围内\n3、f(x)的值也在[0,m-1]范围内\n```\n\n* 性质证明及周期计算\n\n```\n1、假设两个集合s={0,1,2,3,……,m-2,m-1} size(s)=m\n    T={} size(T)=0\n    将产生的伪随机数挪到集合T中\n2、先生成第一个伪随机数x1\n    s={0,1,2,3,……,m-2,m-1} size(s)=m\n    T={x1} size(T)=1\n3、根据第一个伪随机数x1生成第二个伪随机数x2，判断x2的归属，若x2属于集合s则一个周期还未结束，若x2属于集合T此处正好等于x1则一个周期产生，周期p=1\n\n推论到x[i]即生成的每个x都属于s，都转移到T\n此时：s={0,1,2,3,……,m-2,m-1} size(s)=m\n      T={x1,x2,x3,……,x[i-2],x[i-1]} size(T)=i-1\n若x[i]=f(x[i-1])∈s，则未能完成一周期\n若x[i]=f(x[i-1])∈T，则已完成一个周期，周期p≤i-1\n\n周期p也可能等于m，也就是最终s为空集，T中包含0到m-1的所有元素，且f(X[m])=x1\n因此一定存在一个周期p≤m\n推论：\n    1) 当周期p＜m时，选取不同的随机数种子也就是x0(初始值)产生的周期可能会不同。\n    2) 当周期p=m时，序列的周期与初始值x0无关，周期必定为p。\n```\n\n\n## 参数选择\n### m的选择\n* 一般来说，模数应该尽可能大，这样可以产生较长的周期，常见的模数挑选一般为2**w（常用的为2^32或者2^64，产生结果直接截断最右边的32bit或者64bit）\n* 当模数为2**w的时候，最后产生未模之前的数字与最后的结果相比，是该数字的比特位向右边减w位的结果，这种形式在低位上的随机性并不是很好。可以在产生随机数后截取高位比特，将随机性不好的低位比特直接舍弃。\n### a的选择（0≤a<m）\n* a的取值会很大程度上影响整个生成器的安全性，应该使周期尽量长（最长为m），但是周期长的序列随机性比较差。\n* 当a=1时，生成器的公式为s[i+1]=s[i]+b mod m\n* 当a=0时，生成器的公式为s[i+1]=b mod m，安全性为0.\n* 当a取值其他数字时，影响随机数生成器生成数字的周期。\n### 选取参数的总结\n* 模数m尽可能大，一般大于2**30\n* 当m选取为2的幂次方时，应该满足a mod 8=5\n* 当m和a选取都合理时，b需要在与m互质的条件下选取。\n### 最大周期符合的条件：\n* m和b互质\n* m的所有质因子的积能整除a-1\n* 如果m是4的倍数，a-1也是\n* a,b,seed都比m小\n* a,b是正整数\n\n\n# 例题\n\n![](/images/pasted-20.png)\n* 根据线性同余生成器lcg可得：lcg=(a*x+c)%m\n* 根据题目，当输入数字时，可以得到多个连续随机数，根据伪随机数生成的机制，可以了解到，随机数的生成只要知道随机数种子就可以破解\n* 类推到线性同余方程组，也就是说当知道a,c,m时即可知道随机数的整个序列\n* 例如：假设我们知道lcg0,那么lcg1=(a*lcg0+c)%m,同理lcg2=(a*lcg1+c)%m\n* 此时我们随意提交多次，可以从中得到连续的随机数，类比于lcg0,lcg1,lcg2的关系\n* lcg0=32081     lcg1=23815     lcg2=1237   lcg3=2387\n* 爆破模数module，每次moudle值改变时，都进行下面的操作：\n\n```\nlcg1=(a*lcg0+c)%m       lcg2=(a*lcg1+c)%m\n\n两式相减   左边为:lcg2-lcg1   右边为:(a*lcg1+c)-(a*lcg0+c)\n\n化简为: [lcg2-lcg1=a*(lcg1-lcg0) ] %m\n\n根据求余运算规则可知  \n[a=(lcg2-lcg1)*gmpy2.invert(lcg1-lcg0,m)]%m\n\n此时代入lcg0,lcg1,lcg2之后可求得a\n\n代入lcg1=(a*lcg0+c)%m,把c当作未知数放到等式左边后，式子为：\nc=[lcg1*gmpy2.invert(a*lcg0,m)]%m\n\n类推lcg3_guess=(a*lcg2+c)%m\n将求得地lcg3_guess与lcg3比较，如果相等，证明求得的a,c,m为正确值\n否则，m=m+1，继续验证\n\n注意：\n1、这个式子成立条件是两边同时对m求余\n2、gmpy2.invert(x1,x2)是求与x1%x2同余的最小数，二者在求余操作后等价，因为余数相等，该式表示余数，类似7%5=2%5\n```\n\n\n* 求得正确的a,c,m之后，线性同余方程为 lcg[i]=(a*lcg[i-1]+c)%m\n* 多次提交成功之后，获得flag","slug":"lcg线性同余随机数生成器","published":0,"updated":"2020-05-28T01:51:13.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17f0005vcu97ywc284t","content":"<h1 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h1><ul>\n<li>计算机产生随机数在概率算法设计中，随机数分为真随机数和伪随机数，计算机只能产生伪随机数。</li>\n<li>真随机数：类似放射性元素的衰变等无法控制的且无法复制数据</li>\n<li>伪随机数：通过较为容量大的数学公式产生的数字，具有可猜测性。在得到生成器的随机数种子之后，可以通过计算得到伪随机数序列。</li>\n<li>通用性伪随机数生成器：s0=seed,s[i+1]=f(s[i])，推广形式：s[i+1]=f(s[i],s[i-1],……,s[i-t])，其中t是固定整数。</li>\n<li>满足通用性伪随机数的推广的例子，线性同余生成器：s0=seed,s[i+1]=a*s[i]+b mod m,(i=0,1,2……)<h1 id=\"线性同余生成器\"><a href=\"#线性同余生成器\" class=\"headerlink\" title=\"线性同余生成器\"></a>线性同余生成器</h1><h2 id=\"线性同余序列的周期\"><a href=\"#线性同余序列的周期\" class=\"headerlink\" title=\"线性同余序列的周期\"></a>线性同余序列的周期</h2></li>\n<li>在线性同余序列中存在自封闭特性，具有以下性质</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、存在递推关系：x[i+1]&#x3D;f(x[i])</span><br><span class=\"line\">2、其中的任意元素x[i]都在[0,m-1]范围内</span><br><span class=\"line\">3、f(x)的值也在[0,m-1]范围内</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>性质证明及周期计算</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、假设两个集合s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">    T&#x3D;&#123;&#125; size(T)&#x3D;0</span><br><span class=\"line\">    将产生的伪随机数挪到集合T中</span><br><span class=\"line\">2、先生成第一个伪随机数x1</span><br><span class=\"line\">    s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">    T&#x3D;&#123;x1&#125; size(T)&#x3D;1</span><br><span class=\"line\">3、根据第一个伪随机数x1生成第二个伪随机数x2，判断x2的归属，若x2属于集合s则一个周期还未结束，若x2属于集合T此处正好等于x1则一个周期产生，周期p&#x3D;1</span><br><span class=\"line\"></span><br><span class=\"line\">推论到x[i]即生成的每个x都属于s，都转移到T</span><br><span class=\"line\">此时：s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">      T&#x3D;&#123;x1,x2,x3,……,x[i-2],x[i-1]&#125; size(T)&#x3D;i-1</span><br><span class=\"line\">若x[i]&#x3D;f(x[i-1])∈s，则未能完成一周期</span><br><span class=\"line\">若x[i]&#x3D;f(x[i-1])∈T，则已完成一个周期，周期p≤i-1</span><br><span class=\"line\"></span><br><span class=\"line\">周期p也可能等于m，也就是最终s为空集，T中包含0到m-1的所有元素，且f(X[m])&#x3D;x1</span><br><span class=\"line\">因此一定存在一个周期p≤m</span><br><span class=\"line\">推论：</span><br><span class=\"line\">    1) 当周期p＜m时，选取不同的随机数种子也就是x0(初始值)产生的周期可能会不同。</span><br><span class=\"line\">    2) 当周期p&#x3D;m时，序列的周期与初始值x0无关，周期必定为p。</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"参数选择\"><a href=\"#参数选择\" class=\"headerlink\" title=\"参数选择\"></a>参数选择</h2><h3 id=\"m的选择\"><a href=\"#m的选择\" class=\"headerlink\" title=\"m的选择\"></a>m的选择</h3><ul>\n<li>一般来说，模数应该尽可能大，这样可以产生较长的周期，常见的模数挑选一般为2**w（常用的为2^32或者2^64，产生结果直接截断最右边的32bit或者64bit）</li>\n<li>当模数为2**w的时候，最后产生未模之前的数字与最后的结果相比，是该数字的比特位向右边减w位的结果，这种形式在低位上的随机性并不是很好。可以在产生随机数后截取高位比特，将随机性不好的低位比特直接舍弃。<h3 id=\"a的选择（0≤a-lt-m）\"><a href=\"#a的选择（0≤a-lt-m）\" class=\"headerlink\" title=\"a的选择（0≤a&lt;m）\"></a>a的选择（0≤a&lt;m）</h3></li>\n<li>a的取值会很大程度上影响整个生成器的安全性，应该使周期尽量长（最长为m），但是周期长的序列随机性比较差。</li>\n<li>当a=1时，生成器的公式为s[i+1]=s[i]+b mod m</li>\n<li>当a=0时，生成器的公式为s[i+1]=b mod m，安全性为0.</li>\n<li>当a取值其他数字时，影响随机数生成器生成数字的周期。<h3 id=\"选取参数的总结\"><a href=\"#选取参数的总结\" class=\"headerlink\" title=\"选取参数的总结\"></a>选取参数的总结</h3></li>\n<li>模数m尽可能大，一般大于2**30</li>\n<li>当m选取为2的幂次方时，应该满足a mod 8=5</li>\n<li>当m和a选取都合理时，b需要在与m互质的条件下选取。<h3 id=\"最大周期符合的条件：\"><a href=\"#最大周期符合的条件：\" class=\"headerlink\" title=\"最大周期符合的条件：\"></a>最大周期符合的条件：</h3></li>\n<li>m和b互质</li>\n<li>m的所有质因子的积能整除a-1</li>\n<li>如果m是4的倍数，a-1也是</li>\n<li>a,b,seed都比m小</li>\n<li>a,b是正整数</li>\n</ul>\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><p><img src=\"/images/pasted-20.png\" alt=\"\"></p>\n<ul>\n<li>根据线性同余生成器lcg可得：lcg=(a*x+c)%m</li>\n<li>根据题目，当输入数字时，可以得到多个连续随机数，根据伪随机数生成的机制，可以了解到，随机数的生成只要知道随机数种子就可以破解</li>\n<li>类推到线性同余方程组，也就是说当知道a,c,m时即可知道随机数的整个序列</li>\n<li>例如：假设我们知道lcg0,那么lcg1=(a<em>lcg0+c)%m,同理lcg2=(a</em>lcg1+c)%m</li>\n<li>此时我们随意提交多次，可以从中得到连续的随机数，类比于lcg0,lcg1,lcg2的关系</li>\n<li>lcg0=32081     lcg1=23815     lcg2=1237   lcg3=2387</li>\n<li>爆破模数module，每次moudle值改变时，都进行下面的操作：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lcg1&#x3D;(a*lcg0+c)%m       lcg2&#x3D;(a*lcg1+c)%m</span><br><span class=\"line\"></span><br><span class=\"line\">两式相减   左边为:lcg2-lcg1   右边为:(a*lcg1+c)-(a*lcg0+c)</span><br><span class=\"line\"></span><br><span class=\"line\">化简为: [lcg2-lcg1&#x3D;a*(lcg1-lcg0) ] %m</span><br><span class=\"line\"></span><br><span class=\"line\">根据求余运算规则可知  </span><br><span class=\"line\">[a&#x3D;(lcg2-lcg1)*gmpy2.invert(lcg1-lcg0,m)]%m</span><br><span class=\"line\"></span><br><span class=\"line\">此时代入lcg0,lcg1,lcg2之后可求得a</span><br><span class=\"line\"></span><br><span class=\"line\">代入lcg1&#x3D;(a*lcg0+c)%m,把c当作未知数放到等式左边后，式子为：</span><br><span class=\"line\">c&#x3D;[lcg1*gmpy2.invert(a*lcg0,m)]%m</span><br><span class=\"line\"></span><br><span class=\"line\">类推lcg3_guess&#x3D;(a*lcg2+c)%m</span><br><span class=\"line\">将求得地lcg3_guess与lcg3比较，如果相等，证明求得的a,c,m为正确值</span><br><span class=\"line\">否则，m&#x3D;m+1，继续验证</span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\">1、这个式子成立条件是两边同时对m求余</span><br><span class=\"line\">2、gmpy2.invert(x1,x2)是求与x1%x2同余的最小数，二者在求余操作后等价，因为余数相等，该式表示余数，类似7%5&#x3D;2%5</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>求得正确的a,c,m之后，线性同余方程为 lcg[i]=(a*lcg[i-1]+c)%m</li>\n<li>多次提交成功之后，获得flag</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h1><ul>\n<li>计算机产生随机数在概率算法设计中，随机数分为真随机数和伪随机数，计算机只能产生伪随机数。</li>\n<li>真随机数：类似放射性元素的衰变等无法控制的且无法复制数据</li>\n<li>伪随机数：通过较为容量大的数学公式产生的数字，具有可猜测性。在得到生成器的随机数种子之后，可以通过计算得到伪随机数序列。</li>\n<li>通用性伪随机数生成器：s0=seed,s[i+1]=f(s[i])，推广形式：s[i+1]=f(s[i],s[i-1],……,s[i-t])，其中t是固定整数。</li>\n<li>满足通用性伪随机数的推广的例子，线性同余生成器：s0=seed,s[i+1]=a*s[i]+b mod m,(i=0,1,2……)<h1 id=\"线性同余生成器\"><a href=\"#线性同余生成器\" class=\"headerlink\" title=\"线性同余生成器\"></a>线性同余生成器</h1><h2 id=\"线性同余序列的周期\"><a href=\"#线性同余序列的周期\" class=\"headerlink\" title=\"线性同余序列的周期\"></a>线性同余序列的周期</h2></li>\n<li>在线性同余序列中存在自封闭特性，具有以下性质</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、存在递推关系：x[i+1]&#x3D;f(x[i])</span><br><span class=\"line\">2、其中的任意元素x[i]都在[0,m-1]范围内</span><br><span class=\"line\">3、f(x)的值也在[0,m-1]范围内</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>性质证明及周期计算</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、假设两个集合s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">    T&#x3D;&#123;&#125; size(T)&#x3D;0</span><br><span class=\"line\">    将产生的伪随机数挪到集合T中</span><br><span class=\"line\">2、先生成第一个伪随机数x1</span><br><span class=\"line\">    s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">    T&#x3D;&#123;x1&#125; size(T)&#x3D;1</span><br><span class=\"line\">3、根据第一个伪随机数x1生成第二个伪随机数x2，判断x2的归属，若x2属于集合s则一个周期还未结束，若x2属于集合T此处正好等于x1则一个周期产生，周期p&#x3D;1</span><br><span class=\"line\"></span><br><span class=\"line\">推论到x[i]即生成的每个x都属于s，都转移到T</span><br><span class=\"line\">此时：s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">      T&#x3D;&#123;x1,x2,x3,……,x[i-2],x[i-1]&#125; size(T)&#x3D;i-1</span><br><span class=\"line\">若x[i]&#x3D;f(x[i-1])∈s，则未能完成一周期</span><br><span class=\"line\">若x[i]&#x3D;f(x[i-1])∈T，则已完成一个周期，周期p≤i-1</span><br><span class=\"line\"></span><br><span class=\"line\">周期p也可能等于m，也就是最终s为空集，T中包含0到m-1的所有元素，且f(X[m])&#x3D;x1</span><br><span class=\"line\">因此一定存在一个周期p≤m</span><br><span class=\"line\">推论：</span><br><span class=\"line\">    1) 当周期p＜m时，选取不同的随机数种子也就是x0(初始值)产生的周期可能会不同。</span><br><span class=\"line\">    2) 当周期p&#x3D;m时，序列的周期与初始值x0无关，周期必定为p。</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"参数选择\"><a href=\"#参数选择\" class=\"headerlink\" title=\"参数选择\"></a>参数选择</h2><h3 id=\"m的选择\"><a href=\"#m的选择\" class=\"headerlink\" title=\"m的选择\"></a>m的选择</h3><ul>\n<li>一般来说，模数应该尽可能大，这样可以产生较长的周期，常见的模数挑选一般为2**w（常用的为2^32或者2^64，产生结果直接截断最右边的32bit或者64bit）</li>\n<li>当模数为2**w的时候，最后产生未模之前的数字与最后的结果相比，是该数字的比特位向右边减w位的结果，这种形式在低位上的随机性并不是很好。可以在产生随机数后截取高位比特，将随机性不好的低位比特直接舍弃。<h3 id=\"a的选择（0≤a-lt-m）\"><a href=\"#a的选择（0≤a-lt-m）\" class=\"headerlink\" title=\"a的选择（0≤a&lt;m）\"></a>a的选择（0≤a&lt;m）</h3></li>\n<li>a的取值会很大程度上影响整个生成器的安全性，应该使周期尽量长（最长为m），但是周期长的序列随机性比较差。</li>\n<li>当a=1时，生成器的公式为s[i+1]=s[i]+b mod m</li>\n<li>当a=0时，生成器的公式为s[i+1]=b mod m，安全性为0.</li>\n<li>当a取值其他数字时，影响随机数生成器生成数字的周期。<h3 id=\"选取参数的总结\"><a href=\"#选取参数的总结\" class=\"headerlink\" title=\"选取参数的总结\"></a>选取参数的总结</h3></li>\n<li>模数m尽可能大，一般大于2**30</li>\n<li>当m选取为2的幂次方时，应该满足a mod 8=5</li>\n<li>当m和a选取都合理时，b需要在与m互质的条件下选取。<h3 id=\"最大周期符合的条件：\"><a href=\"#最大周期符合的条件：\" class=\"headerlink\" title=\"最大周期符合的条件：\"></a>最大周期符合的条件：</h3></li>\n<li>m和b互质</li>\n<li>m的所有质因子的积能整除a-1</li>\n<li>如果m是4的倍数，a-1也是</li>\n<li>a,b,seed都比m小</li>\n<li>a,b是正整数</li>\n</ul>\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><p><img src=\"/images/pasted-20.png\" alt=\"\"></p>\n<ul>\n<li>根据线性同余生成器lcg可得：lcg=(a*x+c)%m</li>\n<li>根据题目，当输入数字时，可以得到多个连续随机数，根据伪随机数生成的机制，可以了解到，随机数的生成只要知道随机数种子就可以破解</li>\n<li>类推到线性同余方程组，也就是说当知道a,c,m时即可知道随机数的整个序列</li>\n<li>例如：假设我们知道lcg0,那么lcg1=(a<em>lcg0+c)%m,同理lcg2=(a</em>lcg1+c)%m</li>\n<li>此时我们随意提交多次，可以从中得到连续的随机数，类比于lcg0,lcg1,lcg2的关系</li>\n<li>lcg0=32081     lcg1=23815     lcg2=1237   lcg3=2387</li>\n<li>爆破模数module，每次moudle值改变时，都进行下面的操作：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lcg1&#x3D;(a*lcg0+c)%m       lcg2&#x3D;(a*lcg1+c)%m</span><br><span class=\"line\"></span><br><span class=\"line\">两式相减   左边为:lcg2-lcg1   右边为:(a*lcg1+c)-(a*lcg0+c)</span><br><span class=\"line\"></span><br><span class=\"line\">化简为: [lcg2-lcg1&#x3D;a*(lcg1-lcg0) ] %m</span><br><span class=\"line\"></span><br><span class=\"line\">根据求余运算规则可知  </span><br><span class=\"line\">[a&#x3D;(lcg2-lcg1)*gmpy2.invert(lcg1-lcg0,m)]%m</span><br><span class=\"line\"></span><br><span class=\"line\">此时代入lcg0,lcg1,lcg2之后可求得a</span><br><span class=\"line\"></span><br><span class=\"line\">代入lcg1&#x3D;(a*lcg0+c)%m,把c当作未知数放到等式左边后，式子为：</span><br><span class=\"line\">c&#x3D;[lcg1*gmpy2.invert(a*lcg0,m)]%m</span><br><span class=\"line\"></span><br><span class=\"line\">类推lcg3_guess&#x3D;(a*lcg2+c)%m</span><br><span class=\"line\">将求得地lcg3_guess与lcg3比较，如果相等，证明求得的a,c,m为正确值</span><br><span class=\"line\">否则，m&#x3D;m+1，继续验证</span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\">1、这个式子成立条件是两边同时对m求余</span><br><span class=\"line\">2、gmpy2.invert(x1,x2)是求与x1%x2同余的最小数，二者在求余操作后等价，因为余数相等，该式表示余数，类似7%5&#x3D;2%5</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>求得正确的a,c,m之后，线性同余方程为 lcg[i]=(a*lcg[i-1]+c)%m</li>\n<li>多次提交成功之后，获得flag</li>\n</ul>\n"},{"title":"分组加密的padding","author":"人生若只如初见","date":"2020-09-24T11:55:00.000Z","_content":"# 基本规则\n* 在分组加密中，明文长度不满足要求时，经常进行padding，即使恰好为块长度的整数倍，依旧需要padding（填充）。\n\n# 各种填充规则\n## pkcs5\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 05 05 05 05 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40\n```\n\n* pkCS5是8字节填充的，即填充一定数量的内容，使得成为8的整数倍，而填充的内容取决于需要填充的数目。例如，串0x56在经过PKCS5填充之后会成为0x56 0x07 0x07 0x07 0x07 0x07 0x07 0x07因为需要填充7字节，因此填充的内容就是7。当然特殊情况下，如果已经满足了8的整倍数，按照PKCS5的规则，仍然需要在尾部填充8个字节，并且内容是0x08,目的是为了加解密时统一处理填充。\n* pkcs5总结来说就是在需要填充的位置，8字节缺少多少就填充多少，例如上面缺少5字节，所以填充0x05。\n\n## pkcs7\n\n\n\n\n## OneAndZeroes Padding\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 80 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40\n```\n\n* 这里其实就是和 md5 和 sha1 的 padding 差不多。\n\n\n## Pad with zeroes except make the last byte equal to the number of padding bytes\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8\n```\n\n* 按照上面的例子，依旧缺失5字节，中间全部填充0x00，在最后一字节填充填充了多少，上面一共需要填充5字节，所以结尾为0x05。\n\n## Pad with zero (null) characters（零填充）\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75\n```\n\n* 在所有需要填充的地方填充0x00，直到满足填充原则。\n\n## Pad with spaces（空格填充）\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 20 20 20 20 20\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25\n```\n\n* 所有需要填充的地方都使用空格填充。\n\n","source":"_drafts/分组加密的padding.md","raw":"title: 分组加密的padding\nauthor: 人生若只如初见\ntags:\n  - ''\ncategories:\n  - 密码学\n  - 填充方式\ndate: 2020-09-24 19:55:00\n---\n# 基本规则\n* 在分组加密中，明文长度不满足要求时，经常进行padding，即使恰好为块长度的整数倍，依旧需要padding（填充）。\n\n# 各种填充规则\n## pkcs5\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 05 05 05 05 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40\n```\n\n* pkCS5是8字节填充的，即填充一定数量的内容，使得成为8的整数倍，而填充的内容取决于需要填充的数目。例如，串0x56在经过PKCS5填充之后会成为0x56 0x07 0x07 0x07 0x07 0x07 0x07 0x07因为需要填充7字节，因此填充的内容就是7。当然特殊情况下，如果已经满足了8的整倍数，按照PKCS5的规则，仍然需要在尾部填充8个字节，并且内容是0x08,目的是为了加解密时统一处理填充。\n* pkcs5总结来说就是在需要填充的位置，8字节缺少多少就填充多少，例如上面缺少5字节，所以填充0x05。\n\n## pkcs7\n\n\n\n\n## OneAndZeroes Padding\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 80 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40\n```\n\n* 这里其实就是和 md5 和 sha1 的 padding 差不多。\n\n\n## Pad with zeroes except make the last byte equal to the number of padding bytes\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8\n```\n\n* 按照上面的例子，依旧缺失5字节，中间全部填充0x00，在最后一字节填充填充了多少，上面一共需要填充5字节，所以结尾为0x05。\n\n## Pad with zero (null) characters（零填充）\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75\n```\n\n* 在所有需要填充的地方填充0x00，直到满足填充原则。\n\n## Pad with spaces（空格填充）\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 20 20 20 20 20\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25\n```\n\n* 所有需要填充的地方都使用空格填充。\n\n","slug":"分组加密的padding","published":0,"updated":"2020-09-25T11:34:45.560Z","_id":"ckfi5r17g0007vcu92ci46d9o","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"基本规则\"><a href=\"#基本规则\" class=\"headerlink\" title=\"基本规则\"></a>基本规则</h1><ul>\n<li>在分组加密中，明文长度不满足要求时，经常进行padding，即使恰好为块长度的整数倍，依旧需要padding（填充）。</li>\n</ul>\n<h1 id=\"各种填充规则\"><a href=\"#各种填充规则\" class=\"headerlink\" title=\"各种填充规则\"></a>各种填充规则</h1><h2 id=\"pkcs5\"><a href=\"#pkcs5\" class=\"headerlink\" title=\"pkcs5\"></a>pkcs5</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6F 72 05 05 05 05 05</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; FD 29 85 C9 E8 DF 41 40</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>pkCS5是8字节填充的，即填充一定数量的内容，使得成为8的整数倍，而填充的内容取决于需要填充的数目。例如，串0x56在经过PKCS5填充之后会成为0x56 0x07 0x07 0x07 0x07 0x07 0x07 0x07因为需要填充7字节，因此填充的内容就是7。当然特殊情况下，如果已经满足了8的整倍数，按照PKCS5的规则，仍然需要在尾部填充8个字节，并且内容是0x08,目的是为了加解密时统一处理填充。</li>\n<li>pkcs5总结来说就是在需要填充的位置，8字节缺少多少就填充多少，例如上面缺少5字节，所以填充0x05。</li>\n</ul>\n<h2 id=\"pkcs7\"><a href=\"#pkcs7\" class=\"headerlink\" title=\"pkcs7\"></a>pkcs7</h2><h2 id=\"OneAndZeroes-Padding\"><a href=\"#OneAndZeroes-Padding\" class=\"headerlink\" title=\"OneAndZeroes Padding\"></a>OneAndZeroes Padding</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6F 72 80 00 00 00 00</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; BE 62 5D 9F F3 C6 C8 40</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这里其实就是和 md5 和 sha1 的 padding 差不多。</li>\n</ul>\n<h2 id=\"Pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes\"><a href=\"#Pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes\" class=\"headerlink\" title=\"Pad with zeroes except make the last byte equal to the number of padding bytes\"></a>Pad with zeroes except make the last byte equal to the number of padding bytes</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 00 00 00 00 05</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; 91 19 2C 64 B5 5C 5D B8</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按照上面的例子，依旧缺失5字节，中间全部填充0x00，在最后一字节填充填充了多少，上面一共需要填充5字节，所以结尾为0x05。</li>\n</ul>\n<h2 id=\"Pad-with-zero-null-characters（零填充）\"><a href=\"#Pad-with-zero-null-characters（零填充）\" class=\"headerlink\" title=\"Pad with zero (null) characters（零填充）\"></a>Pad with zero (null) characters（零填充）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 00 00 00 00 00</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; 9E 14 FB 96 C5 FE EB 75</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在所有需要填充的地方填充0x00，直到满足填充原则。</li>\n</ul>\n<h2 id=\"Pad-with-spaces（空格填充）\"><a href=\"#Pad-with-spaces（空格填充）\" class=\"headerlink\" title=\"Pad with spaces（空格填充）\"></a>Pad with spaces（空格填充）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 20 20 20 20 20</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; E3 FF EC E5 21 1F 35 25</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所有需要填充的地方都使用空格填充。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本规则\"><a href=\"#基本规则\" class=\"headerlink\" title=\"基本规则\"></a>基本规则</h1><ul>\n<li>在分组加密中，明文长度不满足要求时，经常进行padding，即使恰好为块长度的整数倍，依旧需要padding（填充）。</li>\n</ul>\n<h1 id=\"各种填充规则\"><a href=\"#各种填充规则\" class=\"headerlink\" title=\"各种填充规则\"></a>各种填充规则</h1><h2 id=\"pkcs5\"><a href=\"#pkcs5\" class=\"headerlink\" title=\"pkcs5\"></a>pkcs5</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6F 72 05 05 05 05 05</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; FD 29 85 C9 E8 DF 41 40</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>pkCS5是8字节填充的，即填充一定数量的内容，使得成为8的整数倍，而填充的内容取决于需要填充的数目。例如，串0x56在经过PKCS5填充之后会成为0x56 0x07 0x07 0x07 0x07 0x07 0x07 0x07因为需要填充7字节，因此填充的内容就是7。当然特殊情况下，如果已经满足了8的整倍数，按照PKCS5的规则，仍然需要在尾部填充8个字节，并且内容是0x08,目的是为了加解密时统一处理填充。</li>\n<li>pkcs5总结来说就是在需要填充的位置，8字节缺少多少就填充多少，例如上面缺少5字节，所以填充0x05。</li>\n</ul>\n<h2 id=\"pkcs7\"><a href=\"#pkcs7\" class=\"headerlink\" title=\"pkcs7\"></a>pkcs7</h2><h2 id=\"OneAndZeroes-Padding\"><a href=\"#OneAndZeroes-Padding\" class=\"headerlink\" title=\"OneAndZeroes Padding\"></a>OneAndZeroes Padding</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6F 72 80 00 00 00 00</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; BE 62 5D 9F F3 C6 C8 40</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这里其实就是和 md5 和 sha1 的 padding 差不多。</li>\n</ul>\n<h2 id=\"Pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes\"><a href=\"#Pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes\" class=\"headerlink\" title=\"Pad with zeroes except make the last byte equal to the number of padding bytes\"></a>Pad with zeroes except make the last byte equal to the number of padding bytes</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 00 00 00 00 05</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; 91 19 2C 64 B5 5C 5D B8</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按照上面的例子，依旧缺失5字节，中间全部填充0x00，在最后一字节填充填充了多少，上面一共需要填充5字节，所以结尾为0x05。</li>\n</ul>\n<h2 id=\"Pad-with-zero-null-characters（零填充）\"><a href=\"#Pad-with-zero-null-characters（零填充）\" class=\"headerlink\" title=\"Pad with zero (null) characters（零填充）\"></a>Pad with zero (null) characters（零填充）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 00 00 00 00 00</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; 9E 14 FB 96 C5 FE EB 75</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在所有需要填充的地方填充0x00，直到满足填充原则。</li>\n</ul>\n<h2 id=\"Pad-with-spaces（空格填充）\"><a href=\"#Pad-with-spaces（空格填充）\" class=\"headerlink\" title=\"Pad with spaces（空格填充）\"></a>Pad with spaces（空格填充）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 20 20 20 20 20</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; E3 FF EC E5 21 1F 35 25</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所有需要填充的地方都使用空格填充。</li>\n</ul>\n"},{"title":"rsa基础学习","author":"人生若只如初见","date":"2020-05-27T03:46:00.000Z","_content":"# rsa基础\n* 在rsa中常用的参数为：N,E,d,p,q,C,m,dp,dq\n* 各参数所代表的含义：\n```\n<1> 参数N代表模数，在RSA中进行模运算\n<2> 参数E，d分别代表公钥指数和私钥指数\n<3> p,q分别为模数N分解后得到的值\n<4> C，m分别代表密文和明文\n<5> dp≡d mod (p−1)      dq≡d mod (q−1)这两个参数是在d的基础上的延申\n```\n* 各参数之间的关系：\n```\n<1> c≡m^e (mod N)    m≡c^d (mod N)\n<2> phi=(p-1)*(q-1)  e*d≡1 (mod phi)\n这里很重要的一点是e,d的取值范围,1<e<phi,1<d<phi,同时gcd(phi,e)=gcd(phi,d)=1\n```\n* 这也是RSA解密的基础运算，就是拿到公钥指数E和模数N，将模数N分解为两个质因数，求得私钥指数d，从而利用加密过程或解密过程将最终的内容拿到。\n### 这里需要讲一下公钥加密解密体系\n* 以对称加密为例，加密所使用的密钥与解密所使用的密钥是同一个，这样破译的难点集中于加密函数复杂度的设计以及密钥的长度，更多的是一种线性的处理方式；而公钥加密体系将这种问题避开，转而将加密解密的数据进行基于离散数学的运算，这里就提到了我们公私钥指数的关系\n```\ne*d≡1 (mod phi)\n```\n* 在数值小的时候运算是极为简单的，不过当数值增加到指数次方时，求离散数学的逆的难度也会相对应地指数次增长。\n* 但并不是说，公钥破解难度只在这里。好多教材和论文，将rsa这种基于大素数的公钥加密的破解，都解释为只要能够将大素数分解，这个加密体系就不复存在。其实，并没有直接证据能够证明，大素数分解与公钥破解的直接联系。\n* 就比如在RSA的解密过程中，当e=3，此时N为分解难度特别大的2048bit级别时，仍旧可以利用低指数攻击，在不分解N的情况下，将整个密文完整解密出来，所以众多的rsa的攻击方式来源不止是针对N的分解，更多的是从RSA的其他参数下手，使得解密过程更为简单便捷。\n\n* 接下来我们用几道例题来说明\n\n## 例题1\n```\n在RSA中，已知C=34 ，N=123，e=11,那么m为多少？\n```\n* 开始分析，这里知道N，我们使用YAFU分解，可以知道N的两个素因数是3和41\n求得phi=240=80,(11d)%phi=1,所以d=51\nm≡c^d (mod(N))=34^51(mod 123)=19\n\n* 这里用到的YAFU是一个在分解N常用的一个离线工具，它适用于素因数相差特别大或者特别小的情况，能够很快的分解出来，所以一些很小的数可能分解时间比大的数要长，原因在这里。\n\n* 除了这个以外，当面对特别大的素数时，我们可以使用在线网站 http://www.factordb.com/ ,这是一个在线网站，相当于是一个数据库，管理员将以往有分解出来的素数放在网站上，供查询。\n\n* 除此之外，利用算法进行脚本分解，不过成功率很低。\n## 例题2\n```\n题目所给一个加密enc文件和一个public.key文件，打开enc显示乱码\n```\n* public.key文件内容：\n![](https://note.youdao.com/yws/api/personal/file/E96950F29A6D49B883155E66A2FCAA4E?method=download&shareKey=fe3dd78b6638f345e7ba7ffd94c1fbc9)\n* 此时，用到了最常用的密钥工具——openssl，使用opsnssl可以方便的解读出公私钥文件的内容。\n* 使用命令，进行解析\n```\nopenssl rsa -pubin -text -modulus -in warmup -in public.key(这里的public.key可为public.pem,pubkey.pem等)\n```\n* 此命令下，解析内容如图所示\n\n* 之后按照例题1的步骤，进行解密\n* 不过这里的密文利用文件读取的指令，下面附上解题脚本\n![](https://note.youdao.com/yws/api/personal/file/3BB42A51A24E480D982E384770F8A445?method=download&shareKey=43c1fd4976fba9d4b1f14080ea0e32e9)\n* 最终的得到flag:flag{2o!9_CTF_ECUN}","source":"_drafts/rsa基础学习-1.md","raw":"title: rsa基础学习\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-05-27 11:46:00\n---\n# rsa基础\n* 在rsa中常用的参数为：N,E,d,p,q,C,m,dp,dq\n* 各参数所代表的含义：\n```\n<1> 参数N代表模数，在RSA中进行模运算\n<2> 参数E，d分别代表公钥指数和私钥指数\n<3> p,q分别为模数N分解后得到的值\n<4> C，m分别代表密文和明文\n<5> dp≡d mod (p−1)      dq≡d mod (q−1)这两个参数是在d的基础上的延申\n```\n* 各参数之间的关系：\n```\n<1> c≡m^e (mod N)    m≡c^d (mod N)\n<2> phi=(p-1)*(q-1)  e*d≡1 (mod phi)\n这里很重要的一点是e,d的取值范围,1<e<phi,1<d<phi,同时gcd(phi,e)=gcd(phi,d)=1\n```\n* 这也是RSA解密的基础运算，就是拿到公钥指数E和模数N，将模数N分解为两个质因数，求得私钥指数d，从而利用加密过程或解密过程将最终的内容拿到。\n### 这里需要讲一下公钥加密解密体系\n* 以对称加密为例，加密所使用的密钥与解密所使用的密钥是同一个，这样破译的难点集中于加密函数复杂度的设计以及密钥的长度，更多的是一种线性的处理方式；而公钥加密体系将这种问题避开，转而将加密解密的数据进行基于离散数学的运算，这里就提到了我们公私钥指数的关系\n```\ne*d≡1 (mod phi)\n```\n* 在数值小的时候运算是极为简单的，不过当数值增加到指数次方时，求离散数学的逆的难度也会相对应地指数次增长。\n* 但并不是说，公钥破解难度只在这里。好多教材和论文，将rsa这种基于大素数的公钥加密的破解，都解释为只要能够将大素数分解，这个加密体系就不复存在。其实，并没有直接证据能够证明，大素数分解与公钥破解的直接联系。\n* 就比如在RSA的解密过程中，当e=3，此时N为分解难度特别大的2048bit级别时，仍旧可以利用低指数攻击，在不分解N的情况下，将整个密文完整解密出来，所以众多的rsa的攻击方式来源不止是针对N的分解，更多的是从RSA的其他参数下手，使得解密过程更为简单便捷。\n\n* 接下来我们用几道例题来说明\n\n## 例题1\n```\n在RSA中，已知C=34 ，N=123，e=11,那么m为多少？\n```\n* 开始分析，这里知道N，我们使用YAFU分解，可以知道N的两个素因数是3和41\n求得phi=240=80,(11d)%phi=1,所以d=51\nm≡c^d (mod(N))=34^51(mod 123)=19\n\n* 这里用到的YAFU是一个在分解N常用的一个离线工具，它适用于素因数相差特别大或者特别小的情况，能够很快的分解出来，所以一些很小的数可能分解时间比大的数要长，原因在这里。\n\n* 除了这个以外，当面对特别大的素数时，我们可以使用在线网站 http://www.factordb.com/ ,这是一个在线网站，相当于是一个数据库，管理员将以往有分解出来的素数放在网站上，供查询。\n\n* 除此之外，利用算法进行脚本分解，不过成功率很低。\n## 例题2\n```\n题目所给一个加密enc文件和一个public.key文件，打开enc显示乱码\n```\n* public.key文件内容：\n![](https://note.youdao.com/yws/api/personal/file/E96950F29A6D49B883155E66A2FCAA4E?method=download&shareKey=fe3dd78b6638f345e7ba7ffd94c1fbc9)\n* 此时，用到了最常用的密钥工具——openssl，使用opsnssl可以方便的解读出公私钥文件的内容。\n* 使用命令，进行解析\n```\nopenssl rsa -pubin -text -modulus -in warmup -in public.key(这里的public.key可为public.pem,pubkey.pem等)\n```\n* 此命令下，解析内容如图所示\n\n* 之后按照例题1的步骤，进行解密\n* 不过这里的密文利用文件读取的指令，下面附上解题脚本\n![](https://note.youdao.com/yws/api/personal/file/3BB42A51A24E480D982E384770F8A445?method=download&shareKey=43c1fd4976fba9d4b1f14080ea0e32e9)\n* 最终的得到flag:flag{2o!9_CTF_ECUN}","slug":"rsa基础学习-1","published":0,"updated":"2020-05-28T10:47:32.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17h0008vcu93zsa5yvn","content":"<h1 id=\"rsa基础\"><a href=\"#rsa基础\" class=\"headerlink\" title=\"rsa基础\"></a>rsa基础</h1><ul>\n<li><p>在rsa中常用的参数为：N,E,d,p,q,C,m,dp,dq</p>\n</li>\n<li><p>各参数所代表的含义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 参数N代表模数，在RSA中进行模运算</span><br><span class=\"line\">&lt;2&gt; 参数E，d分别代表公钥指数和私钥指数</span><br><span class=\"line\">&lt;3&gt; p,q分别为模数N分解后得到的值</span><br><span class=\"line\">&lt;4&gt; C，m分别代表密文和明文</span><br><span class=\"line\">&lt;5&gt; dp≡d mod (p−1)      dq≡d mod (q−1)这两个参数是在d的基础上的延申</span><br></pre></td></tr></table></figure></li>\n<li><p>各参数之间的关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; c≡m^e (mod N)    m≡c^d (mod N)</span><br><span class=\"line\">&lt;2&gt; phi&#x3D;(p-1)*(q-1)  e*d≡1 (mod phi)</span><br><span class=\"line\">这里很重要的一点是e,d的取值范围,1&lt;e&lt;phi,1&lt;d&lt;phi,同时gcd(phi,e)&#x3D;gcd(phi,d)&#x3D;1</span><br></pre></td></tr></table></figure></li>\n<li><p>这也是RSA解密的基础运算，就是拿到公钥指数E和模数N，将模数N分解为两个质因数，求得私钥指数d，从而利用加密过程或解密过程将最终的内容拿到。</p>\n<h3 id=\"这里需要讲一下公钥加密解密体系\"><a href=\"#这里需要讲一下公钥加密解密体系\" class=\"headerlink\" title=\"这里需要讲一下公钥加密解密体系\"></a>这里需要讲一下公钥加密解密体系</h3></li>\n<li><p>以对称加密为例，加密所使用的密钥与解密所使用的密钥是同一个，这样破译的难点集中于加密函数复杂度的设计以及密钥的长度，更多的是一种线性的处理方式；而公钥加密体系将这种问题避开，转而将加密解密的数据进行基于离散数学的运算，这里就提到了我们公私钥指数的关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e*d≡1 (mod phi)</span><br></pre></td></tr></table></figure></li>\n<li><p>在数值小的时候运算是极为简单的，不过当数值增加到指数次方时，求离散数学的逆的难度也会相对应地指数次增长。</p>\n</li>\n<li><p>但并不是说，公钥破解难度只在这里。好多教材和论文，将rsa这种基于大素数的公钥加密的破解，都解释为只要能够将大素数分解，这个加密体系就不复存在。其实，并没有直接证据能够证明，大素数分解与公钥破解的直接联系。</p>\n</li>\n<li><p>就比如在RSA的解密过程中，当e=3，此时N为分解难度特别大的2048bit级别时，仍旧可以利用低指数攻击，在不分解N的情况下，将整个密文完整解密出来，所以众多的rsa的攻击方式来源不止是针对N的分解，更多的是从RSA的其他参数下手，使得解密过程更为简单便捷。</p>\n</li>\n<li><p>接下来我们用几道例题来说明</p>\n</li>\n</ul>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在RSA中，已知C&#x3D;34 ，N&#x3D;123，e&#x3D;11,那么m为多少？</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>开始分析，这里知道N，我们使用YAFU分解，可以知道N的两个素因数是3和41<br>求得phi=240=80,(11d)%phi=1,所以d=51<br>m≡c^d (mod(N))=34^51(mod 123)=19</p>\n</li>\n<li><p>这里用到的YAFU是一个在分解N常用的一个离线工具，它适用于素因数相差特别大或者特别小的情况，能够很快的分解出来，所以一些很小的数可能分解时间比大的数要长，原因在这里。</p>\n</li>\n<li><p>除了这个以外，当面对特别大的素数时，我们可以使用在线网站 <a href=\"http://www.factordb.com/\" target=\"_blank\" rel=\"noopener\">http://www.factordb.com/</a> ,这是一个在线网站，相当于是一个数据库，管理员将以往有分解出来的素数放在网站上，供查询。</p>\n</li>\n<li><p>除此之外，利用算法进行脚本分解，不过成功率很低。</p>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">题目所给一个加密enc文件和一个public.key文件，打开enc显示乱码</span><br></pre></td></tr></table></figure></li>\n<li><p>public.key文件内容：<br><img src=\"https://note.youdao.com/yws/api/personal/file/E96950F29A6D49B883155E66A2FCAA4E?method=download&shareKey=fe3dd78b6638f345e7ba7ffd94c1fbc9\" alt=\"\"></p>\n</li>\n<li><p>此时，用到了最常用的密钥工具——openssl，使用opsnssl可以方便的解读出公私钥文件的内容。</p>\n</li>\n<li><p>使用命令，进行解析</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -pubin -text -modulus -in warmup -in public.key(这里的public.key可为public.pem,pubkey.pem等)</span><br></pre></td></tr></table></figure></li>\n<li><p>此命令下，解析内容如图所示</p>\n</li>\n<li><p>之后按照例题1的步骤，进行解密</p>\n</li>\n<li><p>不过这里的密文利用文件读取的指令，下面附上解题脚本<br><img src=\"https://note.youdao.com/yws/api/personal/file/3BB42A51A24E480D982E384770F8A445?method=download&shareKey=43c1fd4976fba9d4b1f14080ea0e32e9\" alt=\"\"></p>\n</li>\n<li><p>最终的得到flag:flag{2o!9_CTF_ECUN}</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"rsa基础\"><a href=\"#rsa基础\" class=\"headerlink\" title=\"rsa基础\"></a>rsa基础</h1><ul>\n<li><p>在rsa中常用的参数为：N,E,d,p,q,C,m,dp,dq</p>\n</li>\n<li><p>各参数所代表的含义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 参数N代表模数，在RSA中进行模运算</span><br><span class=\"line\">&lt;2&gt; 参数E，d分别代表公钥指数和私钥指数</span><br><span class=\"line\">&lt;3&gt; p,q分别为模数N分解后得到的值</span><br><span class=\"line\">&lt;4&gt; C，m分别代表密文和明文</span><br><span class=\"line\">&lt;5&gt; dp≡d mod (p−1)      dq≡d mod (q−1)这两个参数是在d的基础上的延申</span><br></pre></td></tr></table></figure></li>\n<li><p>各参数之间的关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; c≡m^e (mod N)    m≡c^d (mod N)</span><br><span class=\"line\">&lt;2&gt; phi&#x3D;(p-1)*(q-1)  e*d≡1 (mod phi)</span><br><span class=\"line\">这里很重要的一点是e,d的取值范围,1&lt;e&lt;phi,1&lt;d&lt;phi,同时gcd(phi,e)&#x3D;gcd(phi,d)&#x3D;1</span><br></pre></td></tr></table></figure></li>\n<li><p>这也是RSA解密的基础运算，就是拿到公钥指数E和模数N，将模数N分解为两个质因数，求得私钥指数d，从而利用加密过程或解密过程将最终的内容拿到。</p>\n<h3 id=\"这里需要讲一下公钥加密解密体系\"><a href=\"#这里需要讲一下公钥加密解密体系\" class=\"headerlink\" title=\"这里需要讲一下公钥加密解密体系\"></a>这里需要讲一下公钥加密解密体系</h3></li>\n<li><p>以对称加密为例，加密所使用的密钥与解密所使用的密钥是同一个，这样破译的难点集中于加密函数复杂度的设计以及密钥的长度，更多的是一种线性的处理方式；而公钥加密体系将这种问题避开，转而将加密解密的数据进行基于离散数学的运算，这里就提到了我们公私钥指数的关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e*d≡1 (mod phi)</span><br></pre></td></tr></table></figure></li>\n<li><p>在数值小的时候运算是极为简单的，不过当数值增加到指数次方时，求离散数学的逆的难度也会相对应地指数次增长。</p>\n</li>\n<li><p>但并不是说，公钥破解难度只在这里。好多教材和论文，将rsa这种基于大素数的公钥加密的破解，都解释为只要能够将大素数分解，这个加密体系就不复存在。其实，并没有直接证据能够证明，大素数分解与公钥破解的直接联系。</p>\n</li>\n<li><p>就比如在RSA的解密过程中，当e=3，此时N为分解难度特别大的2048bit级别时，仍旧可以利用低指数攻击，在不分解N的情况下，将整个密文完整解密出来，所以众多的rsa的攻击方式来源不止是针对N的分解，更多的是从RSA的其他参数下手，使得解密过程更为简单便捷。</p>\n</li>\n<li><p>接下来我们用几道例题来说明</p>\n</li>\n</ul>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在RSA中，已知C&#x3D;34 ，N&#x3D;123，e&#x3D;11,那么m为多少？</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>开始分析，这里知道N，我们使用YAFU分解，可以知道N的两个素因数是3和41<br>求得phi=240=80,(11d)%phi=1,所以d=51<br>m≡c^d (mod(N))=34^51(mod 123)=19</p>\n</li>\n<li><p>这里用到的YAFU是一个在分解N常用的一个离线工具，它适用于素因数相差特别大或者特别小的情况，能够很快的分解出来，所以一些很小的数可能分解时间比大的数要长，原因在这里。</p>\n</li>\n<li><p>除了这个以外，当面对特别大的素数时，我们可以使用在线网站 <a href=\"http://www.factordb.com/\" target=\"_blank\" rel=\"noopener\">http://www.factordb.com/</a> ,这是一个在线网站，相当于是一个数据库，管理员将以往有分解出来的素数放在网站上，供查询。</p>\n</li>\n<li><p>除此之外，利用算法进行脚本分解，不过成功率很低。</p>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">题目所给一个加密enc文件和一个public.key文件，打开enc显示乱码</span><br></pre></td></tr></table></figure></li>\n<li><p>public.key文件内容：<br><img src=\"https://note.youdao.com/yws/api/personal/file/E96950F29A6D49B883155E66A2FCAA4E?method=download&shareKey=fe3dd78b6638f345e7ba7ffd94c1fbc9\" alt=\"\"></p>\n</li>\n<li><p>此时，用到了最常用的密钥工具——openssl，使用opsnssl可以方便的解读出公私钥文件的内容。</p>\n</li>\n<li><p>使用命令，进行解析</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -pubin -text -modulus -in warmup -in public.key(这里的public.key可为public.pem,pubkey.pem等)</span><br></pre></td></tr></table></figure></li>\n<li><p>此命令下，解析内容如图所示</p>\n</li>\n<li><p>之后按照例题1的步骤，进行解密</p>\n</li>\n<li><p>不过这里的密文利用文件读取的指令，下面附上解题脚本<br><img src=\"https://note.youdao.com/yws/api/personal/file/3BB42A51A24E480D982E384770F8A445?method=download&shareKey=43c1fd4976fba9d4b1f14080ea0e32e9\" alt=\"\"></p>\n</li>\n<li><p>最终的得到flag:flag{2o!9_CTF_ECUN}</p>\n</li>\n</ul>\n"},{"title":"RSA  Factor Attack 及常用脚本","author":"人生若只如初见","date":"2020-05-28T14:31:00.000Z","_content":"# 基本解密\n\n* 以下全文中^代表乘方，例如：2^3=2的3次方=8\n* c^d %n  == (m^e)^d %n ==m^ (e*d)%n ==m^(e*d %(φ（n）))%n  ==m^1 %n \n\n* 下面开始正文\n\n# Factor Attack\n\n## 1、当p==q\n\n```\n\tn=p*q=p**2\n\tφ（n）=p**2-p\n```\n\n## 2、孪生质数（twin prime）\n\n* 定义：孪生素数就是指相差2的素数对，例如：3和5，5和7，以36N（N+1）为界，孪生素数以波浪形式渐渐增多\n\n```\n\tn1=p*q,n2=(p+2)*(q+2)\n\tφ（n1）=（p-1）*(q-1)=n1-(p+q)+1\n\tφ（n2）=(p+1)*(q+1)=n1+(p+q)+1\n\tn2=(p+2)*(q+2)=n1+2*(p+q)+4\n\tp+q=(n2-n1-4)/2\n```\n\n## 3、Common Factor Attack(公约数分解)\n\n* p,q  为gcd(ni,nj)=pi=pj，所给N中有最大公因数，即可侧面分解n，也出现在唯密文攻击中，这时一般公约数出现在n与密文c之间\n\n## 4、Pollard Algorithm\n\n* 使用时机：当p-1光滑时\n* 例如：\n\n```\np=9132400715036908229752508016230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\n```\n* a,b,n,k属于N，p是素数，满足gcd(a,p)=1和p|n\n* 根据费马小定理：\n\n```\na^(p-1)≡1 (mod p)⇨a^k(p-1)≡1 (mod p)⇨p|gcd(a^b-1,n)=p^2\n```\n\n* 若p-1|b成立且满足gcd(a^b-1,n)>1,则gcd(a^b-1,n)=p,代入a=2去爆破，但可能会失败。\n\n```\ndef pollard(n):\n\t\ta,b=2,2\n\t\twhile True:\n\t\t\ta=pow(a,b,n)\n\t\t\tp=sympy.gcd(a-1,n)\n\t\t\tif 1<p<n: return p\n\t\t\tb +=1\n```\n\n## 5、Fermat's Factorization method\n* 使用时机：|p-q|很小的时候\n\n```\n让   a=(p+q)/2  b=(p-q)/2\n\t n=(a+b)^a-b)=a^2 -b^2\n```\n* 因为|p-q|很小，所以n会略等于a的平方，把a 用sqrt(n)代入，测试a^2-n是否为平方数，如果a^2-n是平方数，则(p,q)为(a+b,a-b)\n\n```\ndef fermat(n):\n\t\ta=gmpy2.isqrt(n)+1\n\t\tb=a**2-n\n\t\twhile not gmpy2.iroot(b,2)[1]:\n\t\t\ta += 1\n\t\t\tb = a**2 - n\n\t\tb= gmpy2.iroot(b , 2)[0]\n\t\treturn ( a + b , a - b )\n```\n\n# 用到的数学定理\n\n## 1、费马小定理\n* a属于N，p是素数\n\n```\na^(p-1)%p=1\na^(p-1)≡1 （mod p）\n代入φ函数\n推出：a^φ（p）≡1（mod p）\n```\n\n## Hastad's Broadcast Attack(中国剩余定理)\n\n* 对加密的指数做攻击\n* 使用时机：e固定不变，有多个n和对应的c\n\n```\n例子：\n\t\tN=3*5*7\n\tx≡2(mod 3)        N1=5*7=35   n1=3   d1=invert(N1,n1)=2\n\tx≡3(mod 5)        N2=3*7=21   n2=5   d2=invert(N2,n2)=1\n\tx≡2(mod 7)        N3=3*5=15   n3=7   d3=invert(N3,n3)=1\n\tx=(c1*d1*N1+c2*d2*N2+c3*d3*N3)%N\n\t之后对x使用gmpy2.iroot（）,开e次方\n```\n* 特例：2020网鼎杯\n* 使用中国剩余定理求出X后，gmpy2.iroot()开次方数为17，这个需要观察rsa中密文长度、明文长度和模数长度之间的关系考虑。\n\n## Wiener's Attack(维纳攻击)\n\n* 对解密指数做攻击\n* 使用时机：e非常大，d很小的时候\n* 当d<(1/3)(N^(1/4))和|p-q|<max(p,q)条件符合时，可以利用(e,n)来估计(d,φ(n))\n\n```\ne*d≡1(mod φ（n）)\n\t→e*d=k*φ（n）+1                       k属于N\n\t→e/φ（n）=k/d++1/(d*φ（n）)        divide by d*φ（n）\n\t→e/φ（n）≈k/d\n\t→e/n≈k/d\n\t方法：连分数  #如何做连分数\n```\n\n## Common Factor Attack(共模攻击)\n\n* 使用时机：相同明文，不同e，相同的N, 有对应的密文\n\n```\nm**e1%n=c1\nm**e2%n=c2\n若满足gcd(e1,e2)=1，则有线性方程满足s1*e1+s2*e2=1，其中s1=invert(e1,e2)且s2=invert(e2,e1)\nc1**s1 * c2**s2→(m**(e1*s1))*(m**(e2*s2))%n→m**(e1*s1+e2*s2)%n\n注意到(s1,s2)，他们必须是线性方程的一组解，所以分开算invert并不是一组的，所以算出s1后，因为s1*e1+s2*e2=1,所以s2=(1-s1*e1)/e2\n但python的pow报错：\n\t\tValueError:pow()2nd argument cannot be negative when 3rd argument specified\n\t\t若c2**s2≡x**(-s2)  (mod n)\n\t\t  (c2**s2)(x**s2)≡1 (mod n)\n\t\t  (c2*x)**s2≡1 (mod n)\n```\n\n* 脚本\n\n```\nimport sympy\nn=\ne1=\ne2=\nc1=\nc2=\nc2=int(sympy.invert(c2,n))  #作为上面公式中的x\ns1=int(sympy.invert(e1,e2))\ns2=(s1*e1-1)//e2\nm=(pow(c1,s1,n)*pow(c2,s2,n))%n\n```\n\n# 一些自己常用的自定义函数和脚本\n## 1、自定义的invert函数\n\n```\ndef egcd(a,b):\n\tif a==0: return (b,0,1)\n\telse:\n\t\tg,x,y=egcd(b%a,a)\n\t\treturn (g, x - (b // a)*y,y)\n\ndef invert(a,m):\n\tg,x,y=egcd(a,m)\n\tif g !=1: print ('modular inverse does not exist')\n\telse: return x%m\n\ne= \nphi=   #即φ（n）\nd=invert(e,phi)\n```\n\n## 2、维纳攻击脚本\n\n```\nimport sympy\n\ndef fractions(x,y):\n\tans=[y//x]\n\tif y%x==0: return ans\n\telse:\n\t\tans.extend(fractions(y%x,x))\n\t\treturn ans\n\ndef continued_fractions(e,n):\n\tans=[]\n\tx= fractions(e,n)\n\tfor i in range(1,len(x)):\n\t\tk, d= 1, x[i-1]\n\t\tfor j in x[:i-1][::-1]:\n\t\t\tk, d = d, d*j+k\n\t\tans.apped((k, d))\n\treturn ans\n\t\ndef Wiener(e,n):\n\tfor k, d in continued_fractions(e,n):\n\t\tphi=(e*d-1)//k\n\t\t#x**2 -(n-phi+1)x+n=0\n\t\tif d == int(sympy.invert(e,phi)):\n\t\t\treturn d\n\t\t\tbreak\n```\n","source":"_drafts/rsa-Factor-Attack-及常用脚本.md","raw":"title: RSA  Factor Attack 及常用脚本\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-05-28 22:31:00\n---\n# 基本解密\n\n* 以下全文中^代表乘方，例如：2^3=2的3次方=8\n* c^d %n  == (m^e)^d %n ==m^ (e*d)%n ==m^(e*d %(φ（n）))%n  ==m^1 %n \n\n* 下面开始正文\n\n# Factor Attack\n\n## 1、当p==q\n\n```\n\tn=p*q=p**2\n\tφ（n）=p**2-p\n```\n\n## 2、孪生质数（twin prime）\n\n* 定义：孪生素数就是指相差2的素数对，例如：3和5，5和7，以36N（N+1）为界，孪生素数以波浪形式渐渐增多\n\n```\n\tn1=p*q,n2=(p+2)*(q+2)\n\tφ（n1）=（p-1）*(q-1)=n1-(p+q)+1\n\tφ（n2）=(p+1)*(q+1)=n1+(p+q)+1\n\tn2=(p+2)*(q+2)=n1+2*(p+q)+4\n\tp+q=(n2-n1-4)/2\n```\n\n## 3、Common Factor Attack(公约数分解)\n\n* p,q  为gcd(ni,nj)=pi=pj，所给N中有最大公因数，即可侧面分解n，也出现在唯密文攻击中，这时一般公约数出现在n与密文c之间\n\n## 4、Pollard Algorithm\n\n* 使用时机：当p-1光滑时\n* 例如：\n\n```\np=9132400715036908229752508016230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\n```\n* a,b,n,k属于N，p是素数，满足gcd(a,p)=1和p|n\n* 根据费马小定理：\n\n```\na^(p-1)≡1 (mod p)⇨a^k(p-1)≡1 (mod p)⇨p|gcd(a^b-1,n)=p^2\n```\n\n* 若p-1|b成立且满足gcd(a^b-1,n)>1,则gcd(a^b-1,n)=p,代入a=2去爆破，但可能会失败。\n\n```\ndef pollard(n):\n\t\ta,b=2,2\n\t\twhile True:\n\t\t\ta=pow(a,b,n)\n\t\t\tp=sympy.gcd(a-1,n)\n\t\t\tif 1<p<n: return p\n\t\t\tb +=1\n```\n\n## 5、Fermat's Factorization method\n* 使用时机：|p-q|很小的时候\n\n```\n让   a=(p+q)/2  b=(p-q)/2\n\t n=(a+b)^a-b)=a^2 -b^2\n```\n* 因为|p-q|很小，所以n会略等于a的平方，把a 用sqrt(n)代入，测试a^2-n是否为平方数，如果a^2-n是平方数，则(p,q)为(a+b,a-b)\n\n```\ndef fermat(n):\n\t\ta=gmpy2.isqrt(n)+1\n\t\tb=a**2-n\n\t\twhile not gmpy2.iroot(b,2)[1]:\n\t\t\ta += 1\n\t\t\tb = a**2 - n\n\t\tb= gmpy2.iroot(b , 2)[0]\n\t\treturn ( a + b , a - b )\n```\n\n# 用到的数学定理\n\n## 1、费马小定理\n* a属于N，p是素数\n\n```\na^(p-1)%p=1\na^(p-1)≡1 （mod p）\n代入φ函数\n推出：a^φ（p）≡1（mod p）\n```\n\n## Hastad's Broadcast Attack(中国剩余定理)\n\n* 对加密的指数做攻击\n* 使用时机：e固定不变，有多个n和对应的c\n\n```\n例子：\n\t\tN=3*5*7\n\tx≡2(mod 3)        N1=5*7=35   n1=3   d1=invert(N1,n1)=2\n\tx≡3(mod 5)        N2=3*7=21   n2=5   d2=invert(N2,n2)=1\n\tx≡2(mod 7)        N3=3*5=15   n3=7   d3=invert(N3,n3)=1\n\tx=(c1*d1*N1+c2*d2*N2+c3*d3*N3)%N\n\t之后对x使用gmpy2.iroot（）,开e次方\n```\n* 特例：2020网鼎杯\n* 使用中国剩余定理求出X后，gmpy2.iroot()开次方数为17，这个需要观察rsa中密文长度、明文长度和模数长度之间的关系考虑。\n\n## Wiener's Attack(维纳攻击)\n\n* 对解密指数做攻击\n* 使用时机：e非常大，d很小的时候\n* 当d<(1/3)(N^(1/4))和|p-q|<max(p,q)条件符合时，可以利用(e,n)来估计(d,φ(n))\n\n```\ne*d≡1(mod φ（n）)\n\t→e*d=k*φ（n）+1                       k属于N\n\t→e/φ（n）=k/d++1/(d*φ（n）)        divide by d*φ（n）\n\t→e/φ（n）≈k/d\n\t→e/n≈k/d\n\t方法：连分数  #如何做连分数\n```\n\n## Common Factor Attack(共模攻击)\n\n* 使用时机：相同明文，不同e，相同的N, 有对应的密文\n\n```\nm**e1%n=c1\nm**e2%n=c2\n若满足gcd(e1,e2)=1，则有线性方程满足s1*e1+s2*e2=1，其中s1=invert(e1,e2)且s2=invert(e2,e1)\nc1**s1 * c2**s2→(m**(e1*s1))*(m**(e2*s2))%n→m**(e1*s1+e2*s2)%n\n注意到(s1,s2)，他们必须是线性方程的一组解，所以分开算invert并不是一组的，所以算出s1后，因为s1*e1+s2*e2=1,所以s2=(1-s1*e1)/e2\n但python的pow报错：\n\t\tValueError:pow()2nd argument cannot be negative when 3rd argument specified\n\t\t若c2**s2≡x**(-s2)  (mod n)\n\t\t  (c2**s2)(x**s2)≡1 (mod n)\n\t\t  (c2*x)**s2≡1 (mod n)\n```\n\n* 脚本\n\n```\nimport sympy\nn=\ne1=\ne2=\nc1=\nc2=\nc2=int(sympy.invert(c2,n))  #作为上面公式中的x\ns1=int(sympy.invert(e1,e2))\ns2=(s1*e1-1)//e2\nm=(pow(c1,s1,n)*pow(c2,s2,n))%n\n```\n\n# 一些自己常用的自定义函数和脚本\n## 1、自定义的invert函数\n\n```\ndef egcd(a,b):\n\tif a==0: return (b,0,1)\n\telse:\n\t\tg,x,y=egcd(b%a,a)\n\t\treturn (g, x - (b // a)*y,y)\n\ndef invert(a,m):\n\tg,x,y=egcd(a,m)\n\tif g !=1: print ('modular inverse does not exist')\n\telse: return x%m\n\ne= \nphi=   #即φ（n）\nd=invert(e,phi)\n```\n\n## 2、维纳攻击脚本\n\n```\nimport sympy\n\ndef fractions(x,y):\n\tans=[y//x]\n\tif y%x==0: return ans\n\telse:\n\t\tans.extend(fractions(y%x,x))\n\t\treturn ans\n\ndef continued_fractions(e,n):\n\tans=[]\n\tx= fractions(e,n)\n\tfor i in range(1,len(x)):\n\t\tk, d= 1, x[i-1]\n\t\tfor j in x[:i-1][::-1]:\n\t\t\tk, d = d, d*j+k\n\t\tans.apped((k, d))\n\treturn ans\n\t\ndef Wiener(e,n):\n\tfor k, d in continued_fractions(e,n):\n\t\tphi=(e*d-1)//k\n\t\t#x**2 -(n-phi+1)x+n=0\n\t\tif d == int(sympy.invert(e,phi)):\n\t\t\treturn d\n\t\t\tbreak\n```\n","slug":"rsa-Factor-Attack-及常用脚本","published":0,"updated":"2020-05-28T15:07:13.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17l000cvcu93j7928jl","content":"<h1 id=\"基本解密\"><a href=\"#基本解密\" class=\"headerlink\" title=\"基本解密\"></a>基本解密</h1><ul>\n<li><p>以下全文中^代表乘方，例如：2^3=2的3次方=8</p>\n</li>\n<li><p>c^d %n  == (m^e)^d %n ==m^ (e<em>d)%n ==m^(e</em>d %(φ（n）))%n  ==m^1 %n </p>\n</li>\n<li><p>下面开始正文</p>\n</li>\n</ul>\n<h1 id=\"Factor-Attack\"><a href=\"#Factor-Attack\" class=\"headerlink\" title=\"Factor Attack\"></a>Factor Attack</h1><h2 id=\"1、当p-q\"><a href=\"#1、当p-q\" class=\"headerlink\" title=\"1、当p==q\"></a>1、当p==q</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;p*q&#x3D;p**2</span><br><span class=\"line\">φ（n）&#x3D;p**2-p</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、孪生质数（twin-prime）\"><a href=\"#2、孪生质数（twin-prime）\" class=\"headerlink\" title=\"2、孪生质数（twin prime）\"></a>2、孪生质数（twin prime）</h2><ul>\n<li>定义：孪生素数就是指相差2的素数对，例如：3和5，5和7，以36N（N+1）为界，孪生素数以波浪形式渐渐增多</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1&#x3D;p*q,n2&#x3D;(p+2)*(q+2)</span><br><span class=\"line\">φ（n1）&#x3D;（p-1）*(q-1)&#x3D;n1-(p+q)+1</span><br><span class=\"line\">φ（n2）&#x3D;(p+1)*(q+1)&#x3D;n1+(p+q)+1</span><br><span class=\"line\">n2&#x3D;(p+2)*(q+2)&#x3D;n1+2*(p+q)+4</span><br><span class=\"line\">p+q&#x3D;(n2-n1-4)&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、Common-Factor-Attack-公约数分解\"><a href=\"#3、Common-Factor-Attack-公约数分解\" class=\"headerlink\" title=\"3、Common Factor Attack(公约数分解)\"></a>3、Common Factor Attack(公约数分解)</h2><ul>\n<li>p,q  为gcd(ni,nj)=pi=pj，所给N中有最大公因数，即可侧面分解n，也出现在唯密文攻击中，这时一般公约数出现在n与密文c之间</li>\n</ul>\n<h2 id=\"4、Pollard-Algorithm\"><a href=\"#4、Pollard-Algorithm\" class=\"headerlink\" title=\"4、Pollard Algorithm\"></a>4、Pollard Algorithm</h2><ul>\n<li>使用时机：当p-1光滑时</li>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p&#x3D;9132400715036908229752508016230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure>\n<ul>\n<li>a,b,n,k属于N，p是素数，满足gcd(a,p)=1和p|n</li>\n<li>根据费马小定理：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a^(p-1)≡1 (mod p)⇨a^k(p-1)≡1 (mod p)⇨p|gcd(a^b-1,n)&#x3D;p^2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若p-1|b成立且满足gcd(a^b-1,n)&gt;1,则gcd(a^b-1,n)=p,代入a=2去爆破，但可能会失败。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def pollard(n):</span><br><span class=\"line\">\t\ta,b&#x3D;2,2</span><br><span class=\"line\">\t\twhile True:</span><br><span class=\"line\">\t\t\ta&#x3D;pow(a,b,n)</span><br><span class=\"line\">\t\t\tp&#x3D;sympy.gcd(a-1,n)</span><br><span class=\"line\">\t\t\tif 1&lt;p&lt;n: return p</span><br><span class=\"line\">\t\t\tb +&#x3D;1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5、Fermat’s-Factorization-method\"><a href=\"#5、Fermat’s-Factorization-method\" class=\"headerlink\" title=\"5、Fermat’s Factorization method\"></a>5、Fermat’s Factorization method</h2><ul>\n<li>使用时机：|p-q|很小的时候</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">让   a&#x3D;(p+q)&#x2F;2  b&#x3D;(p-q)&#x2F;2</span><br><span class=\"line\">\t n&#x3D;(a+b)^a-b)&#x3D;a^2 -b^2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>因为|p-q|很小，所以n会略等于a的平方，把a 用sqrt(n)代入，测试a^2-n是否为平方数，如果a^2-n是平方数，则(p,q)为(a+b,a-b)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fermat(n):</span><br><span class=\"line\">\t\ta&#x3D;gmpy2.isqrt(n)+1</span><br><span class=\"line\">\t\tb&#x3D;a**2-n</span><br><span class=\"line\">\t\twhile not gmpy2.iroot(b,2)[1]:</span><br><span class=\"line\">\t\t\ta +&#x3D; 1</span><br><span class=\"line\">\t\t\tb &#x3D; a**2 - n</span><br><span class=\"line\">\t\tb&#x3D; gmpy2.iroot(b , 2)[0]</span><br><span class=\"line\">\t\treturn ( a + b , a - b )</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用到的数学定理\"><a href=\"#用到的数学定理\" class=\"headerlink\" title=\"用到的数学定理\"></a>用到的数学定理</h1><h2 id=\"1、费马小定理\"><a href=\"#1、费马小定理\" class=\"headerlink\" title=\"1、费马小定理\"></a>1、费马小定理</h2><ul>\n<li>a属于N，p是素数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a^(p-1)%p&#x3D;1</span><br><span class=\"line\">a^(p-1)≡1 （mod p）</span><br><span class=\"line\">代入φ函数</span><br><span class=\"line\">推出：a^φ（p）≡1（mod p）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hastad’s-Broadcast-Attack-中国剩余定理\"><a href=\"#Hastad’s-Broadcast-Attack-中国剩余定理\" class=\"headerlink\" title=\"Hastad’s Broadcast Attack(中国剩余定理)\"></a>Hastad’s Broadcast Attack(中国剩余定理)</h2><ul>\n<li>对加密的指数做攻击</li>\n<li>使用时机：e固定不变，有多个n和对应的c</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子：</span><br><span class=\"line\">\t\tN&#x3D;3*5*7</span><br><span class=\"line\">\tx≡2(mod 3)        N1&#x3D;5*7&#x3D;35   n1&#x3D;3   d1&#x3D;invert(N1,n1)&#x3D;2</span><br><span class=\"line\">\tx≡3(mod 5)        N2&#x3D;3*7&#x3D;21   n2&#x3D;5   d2&#x3D;invert(N2,n2)&#x3D;1</span><br><span class=\"line\">\tx≡2(mod 7)        N3&#x3D;3*5&#x3D;15   n3&#x3D;7   d3&#x3D;invert(N3,n3)&#x3D;1</span><br><span class=\"line\">\tx&#x3D;(c1*d1*N1+c2*d2*N2+c3*d3*N3)%N</span><br><span class=\"line\">\t之后对x使用gmpy2.iroot（）,开e次方</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特例：2020网鼎杯</li>\n<li>使用中国剩余定理求出X后，gmpy2.iroot()开次方数为17，这个需要观察rsa中密文长度、明文长度和模数长度之间的关系考虑。</li>\n</ul>\n<h2 id=\"Wiener’s-Attack-维纳攻击\"><a href=\"#Wiener’s-Attack-维纳攻击\" class=\"headerlink\" title=\"Wiener’s Attack(维纳攻击)\"></a>Wiener’s Attack(维纳攻击)</h2><ul>\n<li>对解密指数做攻击</li>\n<li>使用时机：e非常大，d很小的时候</li>\n<li>当d&lt;(1/3)(N^(1/4))和|p-q|&lt;max(p,q)条件符合时，可以利用(e,n)来估计(d,φ(n))</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e*d≡1(mod φ（n）)</span><br><span class=\"line\">\t→e*d&#x3D;k*φ（n）+1                       k属于N</span><br><span class=\"line\">\t→e&#x2F;φ（n）&#x3D;k&#x2F;d++1&#x2F;(d*φ（n）)        divide by d*φ（n）</span><br><span class=\"line\">\t→e&#x2F;φ（n）≈k&#x2F;d</span><br><span class=\"line\">\t→e&#x2F;n≈k&#x2F;d</span><br><span class=\"line\">\t方法：连分数  #如何做连分数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Common-Factor-Attack-共模攻击\"><a href=\"#Common-Factor-Attack-共模攻击\" class=\"headerlink\" title=\"Common Factor Attack(共模攻击)\"></a>Common Factor Attack(共模攻击)</h2><ul>\n<li>使用时机：相同明文，不同e，相同的N, 有对应的密文</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m**e1%n&#x3D;c1</span><br><span class=\"line\">m**e2%n&#x3D;c2</span><br><span class=\"line\">若满足gcd(e1,e2)&#x3D;1，则有线性方程满足s1*e1+s2*e2&#x3D;1，其中s1&#x3D;invert(e1,e2)且s2&#x3D;invert(e2,e1)</span><br><span class=\"line\">c1**s1 * c2**s2→(m**(e1*s1))*(m**(e2*s2))%n→m**(e1*s1+e2*s2)%n</span><br><span class=\"line\">注意到(s1,s2)，他们必须是线性方程的一组解，所以分开算invert并不是一组的，所以算出s1后，因为s1*e1+s2*e2&#x3D;1,所以s2&#x3D;(1-s1*e1)&#x2F;e2</span><br><span class=\"line\">但python的pow报错：</span><br><span class=\"line\">\t\tValueError:pow()2nd argument cannot be negative when 3rd argument specified</span><br><span class=\"line\">\t\t若c2**s2≡x**(-s2)  (mod n)</span><br><span class=\"line\">\t\t  (c2**s2)(x**s2)≡1 (mod n)</span><br><span class=\"line\">\t\t  (c2*x)**s2≡1 (mod n)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>脚本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\">n&#x3D;</span><br><span class=\"line\">e1&#x3D;</span><br><span class=\"line\">e2&#x3D;</span><br><span class=\"line\">c1&#x3D;</span><br><span class=\"line\">c2&#x3D;</span><br><span class=\"line\">c2&#x3D;int(sympy.invert(c2,n))  #作为上面公式中的x</span><br><span class=\"line\">s1&#x3D;int(sympy.invert(e1,e2))</span><br><span class=\"line\">s2&#x3D;(s1*e1-1)&#x2F;&#x2F;e2</span><br><span class=\"line\">m&#x3D;(pow(c1,s1,n)*pow(c2,s2,n))%n</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"一些自己常用的自定义函数和脚本\"><a href=\"#一些自己常用的自定义函数和脚本\" class=\"headerlink\" title=\"一些自己常用的自定义函数和脚本\"></a>一些自己常用的自定义函数和脚本</h1><h2 id=\"1、自定义的invert函数\"><a href=\"#1、自定义的invert函数\" class=\"headerlink\" title=\"1、自定义的invert函数\"></a>1、自定义的invert函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def egcd(a,b):</span><br><span class=\"line\">\tif a&#x3D;&#x3D;0: return (b,0,1)</span><br><span class=\"line\">\telse:</span><br><span class=\"line\">\t\tg,x,y&#x3D;egcd(b%a,a)</span><br><span class=\"line\">\t\treturn (g, x - (b &#x2F;&#x2F; a)*y,y)</span><br><span class=\"line\"></span><br><span class=\"line\">def invert(a,m):</span><br><span class=\"line\">\tg,x,y&#x3D;egcd(a,m)</span><br><span class=\"line\">\tif g !&#x3D;1: print (&#39;modular inverse does not exist&#39;)</span><br><span class=\"line\">\telse: return x%m</span><br><span class=\"line\"></span><br><span class=\"line\">e&#x3D; </span><br><span class=\"line\">phi&#x3D;   #即φ（n）</span><br><span class=\"line\">d&#x3D;invert(e,phi)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、维纳攻击脚本\"><a href=\"#2、维纳攻击脚本\" class=\"headerlink\" title=\"2、维纳攻击脚本\"></a>2、维纳攻击脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\"></span><br><span class=\"line\">def fractions(x,y):</span><br><span class=\"line\">\tans&#x3D;[y&#x2F;&#x2F;x]</span><br><span class=\"line\">\tif y%x&#x3D;&#x3D;0: return ans</span><br><span class=\"line\">\telse:</span><br><span class=\"line\">\t\tans.extend(fractions(y%x,x))</span><br><span class=\"line\">\t\treturn ans</span><br><span class=\"line\"></span><br><span class=\"line\">def continued_fractions(e,n):</span><br><span class=\"line\">\tans&#x3D;[]</span><br><span class=\"line\">\tx&#x3D; fractions(e,n)</span><br><span class=\"line\">\tfor i in range(1,len(x)):</span><br><span class=\"line\">\t\tk, d&#x3D; 1, x[i-1]</span><br><span class=\"line\">\t\tfor j in x[:i-1][::-1]:</span><br><span class=\"line\">\t\t\tk, d &#x3D; d, d*j+k</span><br><span class=\"line\">\t\tans.apped((k, d))</span><br><span class=\"line\">\treturn ans</span><br><span class=\"line\">\t</span><br><span class=\"line\">def Wiener(e,n):</span><br><span class=\"line\">\tfor k, d in continued_fractions(e,n):</span><br><span class=\"line\">\t\tphi&#x3D;(e*d-1)&#x2F;&#x2F;k</span><br><span class=\"line\">\t\t#x**2 -(n-phi+1)x+n&#x3D;0</span><br><span class=\"line\">\t\tif d &#x3D;&#x3D; int(sympy.invert(e,phi)):</span><br><span class=\"line\">\t\t\treturn d</span><br><span class=\"line\">\t\t\tbreak</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本解密\"><a href=\"#基本解密\" class=\"headerlink\" title=\"基本解密\"></a>基本解密</h1><ul>\n<li><p>以下全文中^代表乘方，例如：2^3=2的3次方=8</p>\n</li>\n<li><p>c^d %n  == (m^e)^d %n ==m^ (e<em>d)%n ==m^(e</em>d %(φ（n）))%n  ==m^1 %n </p>\n</li>\n<li><p>下面开始正文</p>\n</li>\n</ul>\n<h1 id=\"Factor-Attack\"><a href=\"#Factor-Attack\" class=\"headerlink\" title=\"Factor Attack\"></a>Factor Attack</h1><h2 id=\"1、当p-q\"><a href=\"#1、当p-q\" class=\"headerlink\" title=\"1、当p==q\"></a>1、当p==q</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;p*q&#x3D;p**2</span><br><span class=\"line\">φ（n）&#x3D;p**2-p</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、孪生质数（twin-prime）\"><a href=\"#2、孪生质数（twin-prime）\" class=\"headerlink\" title=\"2、孪生质数（twin prime）\"></a>2、孪生质数（twin prime）</h2><ul>\n<li>定义：孪生素数就是指相差2的素数对，例如：3和5，5和7，以36N（N+1）为界，孪生素数以波浪形式渐渐增多</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1&#x3D;p*q,n2&#x3D;(p+2)*(q+2)</span><br><span class=\"line\">φ（n1）&#x3D;（p-1）*(q-1)&#x3D;n1-(p+q)+1</span><br><span class=\"line\">φ（n2）&#x3D;(p+1)*(q+1)&#x3D;n1+(p+q)+1</span><br><span class=\"line\">n2&#x3D;(p+2)*(q+2)&#x3D;n1+2*(p+q)+4</span><br><span class=\"line\">p+q&#x3D;(n2-n1-4)&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、Common-Factor-Attack-公约数分解\"><a href=\"#3、Common-Factor-Attack-公约数分解\" class=\"headerlink\" title=\"3、Common Factor Attack(公约数分解)\"></a>3、Common Factor Attack(公约数分解)</h2><ul>\n<li>p,q  为gcd(ni,nj)=pi=pj，所给N中有最大公因数，即可侧面分解n，也出现在唯密文攻击中，这时一般公约数出现在n与密文c之间</li>\n</ul>\n<h2 id=\"4、Pollard-Algorithm\"><a href=\"#4、Pollard-Algorithm\" class=\"headerlink\" title=\"4、Pollard Algorithm\"></a>4、Pollard Algorithm</h2><ul>\n<li>使用时机：当p-1光滑时</li>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p&#x3D;9132400715036908229752508016230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure>\n<ul>\n<li>a,b,n,k属于N，p是素数，满足gcd(a,p)=1和p|n</li>\n<li>根据费马小定理：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a^(p-1)≡1 (mod p)⇨a^k(p-1)≡1 (mod p)⇨p|gcd(a^b-1,n)&#x3D;p^2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若p-1|b成立且满足gcd(a^b-1,n)&gt;1,则gcd(a^b-1,n)=p,代入a=2去爆破，但可能会失败。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def pollard(n):</span><br><span class=\"line\">\t\ta,b&#x3D;2,2</span><br><span class=\"line\">\t\twhile True:</span><br><span class=\"line\">\t\t\ta&#x3D;pow(a,b,n)</span><br><span class=\"line\">\t\t\tp&#x3D;sympy.gcd(a-1,n)</span><br><span class=\"line\">\t\t\tif 1&lt;p&lt;n: return p</span><br><span class=\"line\">\t\t\tb +&#x3D;1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5、Fermat’s-Factorization-method\"><a href=\"#5、Fermat’s-Factorization-method\" class=\"headerlink\" title=\"5、Fermat’s Factorization method\"></a>5、Fermat’s Factorization method</h2><ul>\n<li>使用时机：|p-q|很小的时候</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">让   a&#x3D;(p+q)&#x2F;2  b&#x3D;(p-q)&#x2F;2</span><br><span class=\"line\">\t n&#x3D;(a+b)^a-b)&#x3D;a^2 -b^2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>因为|p-q|很小，所以n会略等于a的平方，把a 用sqrt(n)代入，测试a^2-n是否为平方数，如果a^2-n是平方数，则(p,q)为(a+b,a-b)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fermat(n):</span><br><span class=\"line\">\t\ta&#x3D;gmpy2.isqrt(n)+1</span><br><span class=\"line\">\t\tb&#x3D;a**2-n</span><br><span class=\"line\">\t\twhile not gmpy2.iroot(b,2)[1]:</span><br><span class=\"line\">\t\t\ta +&#x3D; 1</span><br><span class=\"line\">\t\t\tb &#x3D; a**2 - n</span><br><span class=\"line\">\t\tb&#x3D; gmpy2.iroot(b , 2)[0]</span><br><span class=\"line\">\t\treturn ( a + b , a - b )</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用到的数学定理\"><a href=\"#用到的数学定理\" class=\"headerlink\" title=\"用到的数学定理\"></a>用到的数学定理</h1><h2 id=\"1、费马小定理\"><a href=\"#1、费马小定理\" class=\"headerlink\" title=\"1、费马小定理\"></a>1、费马小定理</h2><ul>\n<li>a属于N，p是素数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a^(p-1)%p&#x3D;1</span><br><span class=\"line\">a^(p-1)≡1 （mod p）</span><br><span class=\"line\">代入φ函数</span><br><span class=\"line\">推出：a^φ（p）≡1（mod p）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hastad’s-Broadcast-Attack-中国剩余定理\"><a href=\"#Hastad’s-Broadcast-Attack-中国剩余定理\" class=\"headerlink\" title=\"Hastad’s Broadcast Attack(中国剩余定理)\"></a>Hastad’s Broadcast Attack(中国剩余定理)</h2><ul>\n<li>对加密的指数做攻击</li>\n<li>使用时机：e固定不变，有多个n和对应的c</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子：</span><br><span class=\"line\">\t\tN&#x3D;3*5*7</span><br><span class=\"line\">\tx≡2(mod 3)        N1&#x3D;5*7&#x3D;35   n1&#x3D;3   d1&#x3D;invert(N1,n1)&#x3D;2</span><br><span class=\"line\">\tx≡3(mod 5)        N2&#x3D;3*7&#x3D;21   n2&#x3D;5   d2&#x3D;invert(N2,n2)&#x3D;1</span><br><span class=\"line\">\tx≡2(mod 7)        N3&#x3D;3*5&#x3D;15   n3&#x3D;7   d3&#x3D;invert(N3,n3)&#x3D;1</span><br><span class=\"line\">\tx&#x3D;(c1*d1*N1+c2*d2*N2+c3*d3*N3)%N</span><br><span class=\"line\">\t之后对x使用gmpy2.iroot（）,开e次方</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特例：2020网鼎杯</li>\n<li>使用中国剩余定理求出X后，gmpy2.iroot()开次方数为17，这个需要观察rsa中密文长度、明文长度和模数长度之间的关系考虑。</li>\n</ul>\n<h2 id=\"Wiener’s-Attack-维纳攻击\"><a href=\"#Wiener’s-Attack-维纳攻击\" class=\"headerlink\" title=\"Wiener’s Attack(维纳攻击)\"></a>Wiener’s Attack(维纳攻击)</h2><ul>\n<li>对解密指数做攻击</li>\n<li>使用时机：e非常大，d很小的时候</li>\n<li>当d&lt;(1/3)(N^(1/4))和|p-q|&lt;max(p,q)条件符合时，可以利用(e,n)来估计(d,φ(n))</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e*d≡1(mod φ（n）)</span><br><span class=\"line\">\t→e*d&#x3D;k*φ（n）+1                       k属于N</span><br><span class=\"line\">\t→e&#x2F;φ（n）&#x3D;k&#x2F;d++1&#x2F;(d*φ（n）)        divide by d*φ（n）</span><br><span class=\"line\">\t→e&#x2F;φ（n）≈k&#x2F;d</span><br><span class=\"line\">\t→e&#x2F;n≈k&#x2F;d</span><br><span class=\"line\">\t方法：连分数  #如何做连分数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Common-Factor-Attack-共模攻击\"><a href=\"#Common-Factor-Attack-共模攻击\" class=\"headerlink\" title=\"Common Factor Attack(共模攻击)\"></a>Common Factor Attack(共模攻击)</h2><ul>\n<li>使用时机：相同明文，不同e，相同的N, 有对应的密文</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m**e1%n&#x3D;c1</span><br><span class=\"line\">m**e2%n&#x3D;c2</span><br><span class=\"line\">若满足gcd(e1,e2)&#x3D;1，则有线性方程满足s1*e1+s2*e2&#x3D;1，其中s1&#x3D;invert(e1,e2)且s2&#x3D;invert(e2,e1)</span><br><span class=\"line\">c1**s1 * c2**s2→(m**(e1*s1))*(m**(e2*s2))%n→m**(e1*s1+e2*s2)%n</span><br><span class=\"line\">注意到(s1,s2)，他们必须是线性方程的一组解，所以分开算invert并不是一组的，所以算出s1后，因为s1*e1+s2*e2&#x3D;1,所以s2&#x3D;(1-s1*e1)&#x2F;e2</span><br><span class=\"line\">但python的pow报错：</span><br><span class=\"line\">\t\tValueError:pow()2nd argument cannot be negative when 3rd argument specified</span><br><span class=\"line\">\t\t若c2**s2≡x**(-s2)  (mod n)</span><br><span class=\"line\">\t\t  (c2**s2)(x**s2)≡1 (mod n)</span><br><span class=\"line\">\t\t  (c2*x)**s2≡1 (mod n)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>脚本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\">n&#x3D;</span><br><span class=\"line\">e1&#x3D;</span><br><span class=\"line\">e2&#x3D;</span><br><span class=\"line\">c1&#x3D;</span><br><span class=\"line\">c2&#x3D;</span><br><span class=\"line\">c2&#x3D;int(sympy.invert(c2,n))  #作为上面公式中的x</span><br><span class=\"line\">s1&#x3D;int(sympy.invert(e1,e2))</span><br><span class=\"line\">s2&#x3D;(s1*e1-1)&#x2F;&#x2F;e2</span><br><span class=\"line\">m&#x3D;(pow(c1,s1,n)*pow(c2,s2,n))%n</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"一些自己常用的自定义函数和脚本\"><a href=\"#一些自己常用的自定义函数和脚本\" class=\"headerlink\" title=\"一些自己常用的自定义函数和脚本\"></a>一些自己常用的自定义函数和脚本</h1><h2 id=\"1、自定义的invert函数\"><a href=\"#1、自定义的invert函数\" class=\"headerlink\" title=\"1、自定义的invert函数\"></a>1、自定义的invert函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def egcd(a,b):</span><br><span class=\"line\">\tif a&#x3D;&#x3D;0: return (b,0,1)</span><br><span class=\"line\">\telse:</span><br><span class=\"line\">\t\tg,x,y&#x3D;egcd(b%a,a)</span><br><span class=\"line\">\t\treturn (g, x - (b &#x2F;&#x2F; a)*y,y)</span><br><span class=\"line\"></span><br><span class=\"line\">def invert(a,m):</span><br><span class=\"line\">\tg,x,y&#x3D;egcd(a,m)</span><br><span class=\"line\">\tif g !&#x3D;1: print (&#39;modular inverse does not exist&#39;)</span><br><span class=\"line\">\telse: return x%m</span><br><span class=\"line\"></span><br><span class=\"line\">e&#x3D; </span><br><span class=\"line\">phi&#x3D;   #即φ（n）</span><br><span class=\"line\">d&#x3D;invert(e,phi)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、维纳攻击脚本\"><a href=\"#2、维纳攻击脚本\" class=\"headerlink\" title=\"2、维纳攻击脚本\"></a>2、维纳攻击脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\"></span><br><span class=\"line\">def fractions(x,y):</span><br><span class=\"line\">\tans&#x3D;[y&#x2F;&#x2F;x]</span><br><span class=\"line\">\tif y%x&#x3D;&#x3D;0: return ans</span><br><span class=\"line\">\telse:</span><br><span class=\"line\">\t\tans.extend(fractions(y%x,x))</span><br><span class=\"line\">\t\treturn ans</span><br><span class=\"line\"></span><br><span class=\"line\">def continued_fractions(e,n):</span><br><span class=\"line\">\tans&#x3D;[]</span><br><span class=\"line\">\tx&#x3D; fractions(e,n)</span><br><span class=\"line\">\tfor i in range(1,len(x)):</span><br><span class=\"line\">\t\tk, d&#x3D; 1, x[i-1]</span><br><span class=\"line\">\t\tfor j in x[:i-1][::-1]:</span><br><span class=\"line\">\t\t\tk, d &#x3D; d, d*j+k</span><br><span class=\"line\">\t\tans.apped((k, d))</span><br><span class=\"line\">\treturn ans</span><br><span class=\"line\">\t</span><br><span class=\"line\">def Wiener(e,n):</span><br><span class=\"line\">\tfor k, d in continued_fractions(e,n):</span><br><span class=\"line\">\t\tphi&#x3D;(e*d-1)&#x2F;&#x2F;k</span><br><span class=\"line\">\t\t#x**2 -(n-phi+1)x+n&#x3D;0</span><br><span class=\"line\">\t\tif d &#x3D;&#x3D; int(sympy.invert(e,phi)):</span><br><span class=\"line\">\t\t\treturn d</span><br><span class=\"line\">\t\t\tbreak</span><br></pre></td></tr></table></figure>\n"},{"title":"将CRT(中国剩余定理)与RSA结合","author":"人生若只如初见","date":"2020-06-01T01:00:00.000Z","_content":"* 使用中国剩余定理来加快RSA的运算速度，使用Zn中数字的CRT表示法，使用N的素因子预先计算出的三个额外值，来更有效的执行四次幂运算。\n\n# 在RSA中的一些运算\n\n* 正常的RSA解密，使用私钥(n,d)进行密文解密（或生成签名），不过在运算过程中，我们需要先通过公钥指数e求得私钥指数d，并不如e那么方便，所以可以选择一个值尽可能少的“1”位。\n* 对于k位的模数N，私钥质数也有类似的长度，大约一半是“1”。计算指数的时间与k^3成正比,所以需要其他的计算。\n* 基础解密：m=c^d mod n\n\n\n\n* 1、给定p、q并用p>q预计算几个值\n\n```\ndp=(1/e) mod (p-1)\ndq=(1/e) mod (q-1)\nqInv=(1/q) mod p\n```\n\n* 1/e表示e关于phi的逆元，表达式x =（1 / e）mod N也写为x = e -1 mod N，并且x是满足xe≡1（mod N）的任何整数。\n* 使用在Zn中的唯一值x，数字集合{0,1,2,...,n-1}\n* 解密给定的C可以按照下面的步骤\n\n```\nm1 = c^dP mod p\nm2 = c^dQ mod q\nh = qInv.(m1 - m2) mod p\nm = m2 + h.q\n```\n\n* 可以发现，dp,dq,qInv,p,q正好是私钥中的内容。\n\n# 中国剩余定理-特例\n\n```\n定理：令p,q为不同的素数，n=p*q对于任何对(x1,x2)，其中0≤x 1 <p和0≤x 2 <q\n\t存在唯一的数x，其中0≤x <n\n    \t  x 1 = x mod p，\n  \t\t  x 2 = x mod q。\n```\n\n* 任何整数x（0≤x <n）都可以用其CRT表示形式（x 1，x 2）唯一表示。\n\n# 欧拉定理与欧拉公式\n\n```\n如果n是一个正整数，并且a与n互质即gcd(a,n)=1，则a^φ(n) ≡ 1 (mod n)\nφ(n) 是欧拉函数\n欧拉函数是求小于等于n的数中与n互质的数的数目  \n即欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目\n或者说欧拉函数是求 1到n-1 中 与n互质的数 的数目\n \n如果n是质数\n那么1到n-1所有数都是与n互质的，\n所以φ(n) = n-1\n如果n是合数。。。自己算吧\n例如φ(8)=4，因为1,3,5,7均和8互质\n```","source":"_drafts/将CRT-中国剩余定理-与RSA结合.md","raw":"title: 将CRT(中国剩余定理)与RSA结合\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-06-01 09:00:00\n---\n* 使用中国剩余定理来加快RSA的运算速度，使用Zn中数字的CRT表示法，使用N的素因子预先计算出的三个额外值，来更有效的执行四次幂运算。\n\n# 在RSA中的一些运算\n\n* 正常的RSA解密，使用私钥(n,d)进行密文解密（或生成签名），不过在运算过程中，我们需要先通过公钥指数e求得私钥指数d，并不如e那么方便，所以可以选择一个值尽可能少的“1”位。\n* 对于k位的模数N，私钥质数也有类似的长度，大约一半是“1”。计算指数的时间与k^3成正比,所以需要其他的计算。\n* 基础解密：m=c^d mod n\n\n\n\n* 1、给定p、q并用p>q预计算几个值\n\n```\ndp=(1/e) mod (p-1)\ndq=(1/e) mod (q-1)\nqInv=(1/q) mod p\n```\n\n* 1/e表示e关于phi的逆元，表达式x =（1 / e）mod N也写为x = e -1 mod N，并且x是满足xe≡1（mod N）的任何整数。\n* 使用在Zn中的唯一值x，数字集合{0,1,2,...,n-1}\n* 解密给定的C可以按照下面的步骤\n\n```\nm1 = c^dP mod p\nm2 = c^dQ mod q\nh = qInv.(m1 - m2) mod p\nm = m2 + h.q\n```\n\n* 可以发现，dp,dq,qInv,p,q正好是私钥中的内容。\n\n# 中国剩余定理-特例\n\n```\n定理：令p,q为不同的素数，n=p*q对于任何对(x1,x2)，其中0≤x 1 <p和0≤x 2 <q\n\t存在唯一的数x，其中0≤x <n\n    \t  x 1 = x mod p，\n  \t\t  x 2 = x mod q。\n```\n\n* 任何整数x（0≤x <n）都可以用其CRT表示形式（x 1，x 2）唯一表示。\n\n# 欧拉定理与欧拉公式\n\n```\n如果n是一个正整数，并且a与n互质即gcd(a,n)=1，则a^φ(n) ≡ 1 (mod n)\nφ(n) 是欧拉函数\n欧拉函数是求小于等于n的数中与n互质的数的数目  \n即欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目\n或者说欧拉函数是求 1到n-1 中 与n互质的数 的数目\n \n如果n是质数\n那么1到n-1所有数都是与n互质的，\n所以φ(n) = n-1\n如果n是合数。。。自己算吧\n例如φ(8)=4，因为1,3,5,7均和8互质\n```","slug":"将CRT-中国剩余定理-与RSA结合","published":0,"updated":"2020-09-25T09:11:11.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17m000dvcu9622l57s0","content":"<ul>\n<li>使用中国剩余定理来加快RSA的运算速度，使用Zn中数字的CRT表示法，使用N的素因子预先计算出的三个额外值，来更有效的执行四次幂运算。</li>\n</ul>\n<h1 id=\"在RSA中的一些运算\"><a href=\"#在RSA中的一些运算\" class=\"headerlink\" title=\"在RSA中的一些运算\"></a>在RSA中的一些运算</h1><ul>\n<li>正常的RSA解密，使用私钥(n,d)进行密文解密（或生成签名），不过在运算过程中，我们需要先通过公钥指数e求得私钥指数d，并不如e那么方便，所以可以选择一个值尽可能少的“1”位。</li>\n<li>对于k位的模数N，私钥质数也有类似的长度，大约一半是“1”。计算指数的时间与k^3成正比,所以需要其他的计算。</li>\n<li>基础解密：m=c^d mod n</li>\n</ul>\n<ul>\n<li>1、给定p、q并用p&gt;q预计算几个值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp&#x3D;(1&#x2F;e) mod (p-1)</span><br><span class=\"line\">dq&#x3D;(1&#x2F;e) mod (q-1)</span><br><span class=\"line\">qInv&#x3D;(1&#x2F;q) mod p</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1/e表示e关于phi的逆元，表达式x =（1 / e）mod N也写为x = e -1 mod N，并且x是满足xe≡1（mod N）的任何整数。</li>\n<li>使用在Zn中的唯一值x，数字集合{0,1,2,…,n-1}</li>\n<li>解密给定的C可以按照下面的步骤</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m1 &#x3D; c^dP mod p</span><br><span class=\"line\">m2 &#x3D; c^dQ mod q</span><br><span class=\"line\">h &#x3D; qInv.(m1 - m2) mod p</span><br><span class=\"line\">m &#x3D; m2 + h.q</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以发现，dp,dq,qInv,p,q正好是私钥中的内容。</li>\n</ul>\n<h1 id=\"中国剩余定理-特例\"><a href=\"#中国剩余定理-特例\" class=\"headerlink\" title=\"中国剩余定理-特例\"></a>中国剩余定理-特例</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定理：令p,q为不同的素数，n&#x3D;p*q对于任何对(x1,x2)，其中0≤x 1 &lt;p和0≤x 2 &lt;q</span><br><span class=\"line\">\t存在唯一的数x，其中0≤x &lt;n</span><br><span class=\"line\">    \t  x 1 &#x3D; x mod p，</span><br><span class=\"line\">  \t\t  x 2 &#x3D; x mod q。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任何整数x（0≤x &lt;n）都可以用其CRT表示形式（x 1，x 2）唯一表示。</li>\n</ul>\n<h1 id=\"欧拉定理与欧拉公式\"><a href=\"#欧拉定理与欧拉公式\" class=\"headerlink\" title=\"欧拉定理与欧拉公式\"></a>欧拉定理与欧拉公式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果n是一个正整数，并且a与n互质即gcd(a,n)&#x3D;1，则a^φ(n) ≡ 1 (mod n)</span><br><span class=\"line\">φ(n) 是欧拉函数</span><br><span class=\"line\">欧拉函数是求小于等于n的数中与n互质的数的数目  </span><br><span class=\"line\">即欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目</span><br><span class=\"line\">或者说欧拉函数是求 1到n-1 中 与n互质的数 的数目</span><br><span class=\"line\"> </span><br><span class=\"line\">如果n是质数</span><br><span class=\"line\">那么1到n-1所有数都是与n互质的，</span><br><span class=\"line\">所以φ(n) &#x3D; n-1</span><br><span class=\"line\">如果n是合数。。。自己算吧</span><br><span class=\"line\">例如φ(8)&#x3D;4，因为1,3,5,7均和8互质</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>使用中国剩余定理来加快RSA的运算速度，使用Zn中数字的CRT表示法，使用N的素因子预先计算出的三个额外值，来更有效的执行四次幂运算。</li>\n</ul>\n<h1 id=\"在RSA中的一些运算\"><a href=\"#在RSA中的一些运算\" class=\"headerlink\" title=\"在RSA中的一些运算\"></a>在RSA中的一些运算</h1><ul>\n<li>正常的RSA解密，使用私钥(n,d)进行密文解密（或生成签名），不过在运算过程中，我们需要先通过公钥指数e求得私钥指数d，并不如e那么方便，所以可以选择一个值尽可能少的“1”位。</li>\n<li>对于k位的模数N，私钥质数也有类似的长度，大约一半是“1”。计算指数的时间与k^3成正比,所以需要其他的计算。</li>\n<li>基础解密：m=c^d mod n</li>\n</ul>\n<ul>\n<li>1、给定p、q并用p&gt;q预计算几个值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp&#x3D;(1&#x2F;e) mod (p-1)</span><br><span class=\"line\">dq&#x3D;(1&#x2F;e) mod (q-1)</span><br><span class=\"line\">qInv&#x3D;(1&#x2F;q) mod p</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1/e表示e关于phi的逆元，表达式x =（1 / e）mod N也写为x = e -1 mod N，并且x是满足xe≡1（mod N）的任何整数。</li>\n<li>使用在Zn中的唯一值x，数字集合{0,1,2,…,n-1}</li>\n<li>解密给定的C可以按照下面的步骤</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m1 &#x3D; c^dP mod p</span><br><span class=\"line\">m2 &#x3D; c^dQ mod q</span><br><span class=\"line\">h &#x3D; qInv.(m1 - m2) mod p</span><br><span class=\"line\">m &#x3D; m2 + h.q</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以发现，dp,dq,qInv,p,q正好是私钥中的内容。</li>\n</ul>\n<h1 id=\"中国剩余定理-特例\"><a href=\"#中国剩余定理-特例\" class=\"headerlink\" title=\"中国剩余定理-特例\"></a>中国剩余定理-特例</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定理：令p,q为不同的素数，n&#x3D;p*q对于任何对(x1,x2)，其中0≤x 1 &lt;p和0≤x 2 &lt;q</span><br><span class=\"line\">\t存在唯一的数x，其中0≤x &lt;n</span><br><span class=\"line\">    \t  x 1 &#x3D; x mod p，</span><br><span class=\"line\">  \t\t  x 2 &#x3D; x mod q。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任何整数x（0≤x &lt;n）都可以用其CRT表示形式（x 1，x 2）唯一表示。</li>\n</ul>\n<h1 id=\"欧拉定理与欧拉公式\"><a href=\"#欧拉定理与欧拉公式\" class=\"headerlink\" title=\"欧拉定理与欧拉公式\"></a>欧拉定理与欧拉公式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果n是一个正整数，并且a与n互质即gcd(a,n)&#x3D;1，则a^φ(n) ≡ 1 (mod n)</span><br><span class=\"line\">φ(n) 是欧拉函数</span><br><span class=\"line\">欧拉函数是求小于等于n的数中与n互质的数的数目  </span><br><span class=\"line\">即欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目</span><br><span class=\"line\">或者说欧拉函数是求 1到n-1 中 与n互质的数 的数目</span><br><span class=\"line\"> </span><br><span class=\"line\">如果n是质数</span><br><span class=\"line\">那么1到n-1所有数都是与n互质的，</span><br><span class=\"line\">所以φ(n) &#x3D; n-1</span><br><span class=\"line\">如果n是合数。。。自己算吧</span><br><span class=\"line\">例如φ(8)&#x3D;4，因为1,3,5,7均和8互质</span><br></pre></td></tr></table></figure>"},{"title":"rsa已知e*d分解N","author":"人生若只如初见","date":"2020-05-28T10:30:00.000Z","_content":"# 基本特征\n\n* 前面说过RSA的基本参数，我们知道e*d≡1 mod (p-1)*(q-1).\n* 这个题型是说，当我们从题目中得到e*d和N的值时，如何通过分解N来解密ｒｓａ\n# 简述\n\n* 输入e,d\n\n* e,d都是奇数，因为它们相对于(p-1)*(q-1)都是素数\n\n* 通过建立e*d=1 mod Φ(N)\n\n* 让e*d-1=2^k * r(r 是奇数)\n\n* 让(1<b<N)，从中随机挑选b\n\n* 如果gcd(b,N)>1,我们就停止\n\n* 否则 b∈ZN*, 那么b^(e*d-1)=1 mod N\n\n* 让e*d-1=2^k  *r  当r是奇数，b^(e*d-1)=1 mod N ,求mod N\\\n\n* a0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.\n\n```\n1.我们知道ak=1  让j是aj =1mod  N 的最小指数\n2. 如果0<j并且a(j-1) 不等于N-1那么a(j-1)是关于1mod  N 的一个非平凡根\n```\n\n## 定理\n\n```\n至少有一半的b，1<b<N，满足是1 mod N 的一个非平凡根\n\n\n证明过程：\n如果x^2=1 mod N 并且 x不等于1，N-1 那么gcd(x+1,N)>0\n\n证明过程：x^2 -1 =(x+1)*(x-1) .      N除以乘积，但是x不等于N-1,1.\n\t    因此N不能除以(x-1)或者(x+1)\n\t    所以p必须除以其中一个,q除以另外一个\n```\n\n## 范围\n\n```\n输入d,e,N,随机选择b\n让e*d-1=2^k *r (r是奇数)，b^(e*d-1)=1 mod N\n求mod N\na0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.\n由定理可知，对于概率大于 0.5，aj中的一个是1模N的非平凡平方根，这样的根产生N的因式分解\n\n\n所有的操作都是在log N内\n```\n\n# 例题\n\n```\nN=2773   e=17   d=157\n\n计算过程:\ne*d-1=2668=2^2  *667\n随机挑选b，进行mod 2773的操作\nb=7   7^667=1 mod N        不好\n b=8   8^667=471 mod N, 并且 471^2=1 mod N,所以471是1 mod 2773的非平凡平方根\n\nGcd(472,N)=59          gcd(470,N)=47\n2773//59=47\n```\n\n# 总结：\n\n```\n1、设定k=e*d-1\n2、从2到N-1的范围内随机选择一个数字g\n3、将k写成2^t  *r 的形式\n4、如果t能被2整除，那么t=t/2,并且x=g^t mod N ,直到x>1\n5、在满足x>1的情况下，如果y=gcd(x-1,N)>1,那么其中一个因数p=y， 另一个因数为N/y,如果不满足条件，返回步骤2，重新选择数字g\n```","source":"_drafts/rsa已知e-d分解N.md","raw":"title: rsa已知e*d分解N\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-05-28 18:30:00\n---\n# 基本特征\n\n* 前面说过RSA的基本参数，我们知道e*d≡1 mod (p-1)*(q-1).\n* 这个题型是说，当我们从题目中得到e*d和N的值时，如何通过分解N来解密ｒｓａ\n# 简述\n\n* 输入e,d\n\n* e,d都是奇数，因为它们相对于(p-1)*(q-1)都是素数\n\n* 通过建立e*d=1 mod Φ(N)\n\n* 让e*d-1=2^k * r(r 是奇数)\n\n* 让(1<b<N)，从中随机挑选b\n\n* 如果gcd(b,N)>1,我们就停止\n\n* 否则 b∈ZN*, 那么b^(e*d-1)=1 mod N\n\n* 让e*d-1=2^k  *r  当r是奇数，b^(e*d-1)=1 mod N ,求mod N\\\n\n* a0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.\n\n```\n1.我们知道ak=1  让j是aj =1mod  N 的最小指数\n2. 如果0<j并且a(j-1) 不等于N-1那么a(j-1)是关于1mod  N 的一个非平凡根\n```\n\n## 定理\n\n```\n至少有一半的b，1<b<N，满足是1 mod N 的一个非平凡根\n\n\n证明过程：\n如果x^2=1 mod N 并且 x不等于1，N-1 那么gcd(x+1,N)>0\n\n证明过程：x^2 -1 =(x+1)*(x-1) .      N除以乘积，但是x不等于N-1,1.\n\t    因此N不能除以(x-1)或者(x+1)\n\t    所以p必须除以其中一个,q除以另外一个\n```\n\n## 范围\n\n```\n输入d,e,N,随机选择b\n让e*d-1=2^k *r (r是奇数)，b^(e*d-1)=1 mod N\n求mod N\na0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.\n由定理可知，对于概率大于 0.5，aj中的一个是1模N的非平凡平方根，这样的根产生N的因式分解\n\n\n所有的操作都是在log N内\n```\n\n# 例题\n\n```\nN=2773   e=17   d=157\n\n计算过程:\ne*d-1=2668=2^2  *667\n随机挑选b，进行mod 2773的操作\nb=7   7^667=1 mod N        不好\n b=8   8^667=471 mod N, 并且 471^2=1 mod N,所以471是1 mod 2773的非平凡平方根\n\nGcd(472,N)=59          gcd(470,N)=47\n2773//59=47\n```\n\n# 总结：\n\n```\n1、设定k=e*d-1\n2、从2到N-1的范围内随机选择一个数字g\n3、将k写成2^t  *r 的形式\n4、如果t能被2整除，那么t=t/2,并且x=g^t mod N ,直到x>1\n5、在满足x>1的情况下，如果y=gcd(x-1,N)>1,那么其中一个因数p=y， 另一个因数为N/y,如果不满足条件，返回步骤2，重新选择数字g\n```","slug":"rsa已知e-d分解N","published":0,"updated":"2020-05-28T10:44:58.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17o000fvcu969d226ta","content":"<h1 id=\"基本特征\"><a href=\"#基本特征\" class=\"headerlink\" title=\"基本特征\"></a>基本特征</h1><ul>\n<li><p>前面说过RSA的基本参数，我们知道e<em>d≡1 mod (p-1)</em>(q-1).</p>\n</li>\n<li><p>这个题型是说，当我们从题目中得到e*d和N的值时，如何通过分解N来解密ｒｓａ</p>\n<h1 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h1></li>\n<li><p>输入e,d</p>\n</li>\n<li><p>e,d都是奇数，因为它们相对于(p-1)*(q-1)都是素数</p>\n</li>\n<li><p>通过建立e*d=1 mod Φ(N)</p>\n</li>\n<li><p>让e*d-1=2^k * r(r 是奇数)</p>\n</li>\n<li><p>让(1&lt;b&lt;N)，从中随机挑选b</p>\n</li>\n<li><p>如果gcd(b,N)&gt;1,我们就停止</p>\n</li>\n<li><p>否则 b∈ZN<em>, 那么b^(e</em>d-1)=1 mod N</p>\n</li>\n<li><p>让e<em>d-1=2^k  *r  当r是奇数，b^(e</em>d-1)=1 mod N ,求mod N\\</p>\n</li>\n<li><p>a0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.我们知道ak&#x3D;1  让j是aj &#x3D;1mod  N 的最小指数</span><br><span class=\"line\">2. 如果0&lt;j并且a(j-1) 不等于N-1那么a(j-1)是关于1mod  N 的一个非平凡根</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定理\"><a href=\"#定理\" class=\"headerlink\" title=\"定理\"></a>定理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">至少有一半的b，1&lt;b&lt;N，满足是1 mod N 的一个非平凡根</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">证明过程：</span><br><span class=\"line\">如果x^2&#x3D;1 mod N 并且 x不等于1，N-1 那么gcd(x+1,N)&gt;0</span><br><span class=\"line\"></span><br><span class=\"line\">证明过程：x^2 -1 &#x3D;(x+1)*(x-1) .      N除以乘积，但是x不等于N-1,1.</span><br><span class=\"line\">\t    因此N不能除以(x-1)或者(x+1)</span><br><span class=\"line\">\t    所以p必须除以其中一个,q除以另外一个</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a>范围</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入d,e,N,随机选择b</span><br><span class=\"line\">让e*d-1&#x3D;2^k *r (r是奇数)，b^(e*d-1)&#x3D;1 mod N</span><br><span class=\"line\">求mod N</span><br><span class=\"line\">a0 &#x3D; b^r, a1 &#x3D; (a0)^2, a2 &#x3D; (a1)^2,…, ak &#x3D; (ak-1)^2.</span><br><span class=\"line\">由定理可知，对于概率大于 0.5，aj中的一个是1模N的非平凡平方根，这样的根产生N的因式分解</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">所有的操作都是在log N内</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">N&#x3D;2773   e&#x3D;17   d&#x3D;157</span><br><span class=\"line\"></span><br><span class=\"line\">计算过程:</span><br><span class=\"line\">e*d-1&#x3D;2668&#x3D;2^2  *667</span><br><span class=\"line\">随机挑选b，进行mod 2773的操作</span><br><span class=\"line\">b&#x3D;7   7^667&#x3D;1 mod N        不好</span><br><span class=\"line\"> b&#x3D;8   8^667&#x3D;471 mod N, 并且 471^2&#x3D;1 mod N,所以471是1 mod 2773的非平凡平方根</span><br><span class=\"line\"></span><br><span class=\"line\">Gcd(472,N)&#x3D;59          gcd(470,N)&#x3D;47</span><br><span class=\"line\">2773&#x2F;&#x2F;59&#x3D;47</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、设定k&#x3D;e*d-1</span><br><span class=\"line\">2、从2到N-1的范围内随机选择一个数字g</span><br><span class=\"line\">3、将k写成2^t  *r 的形式</span><br><span class=\"line\">4、如果t能被2整除，那么t&#x3D;t&#x2F;2,并且x&#x3D;g^t mod N ,直到x&gt;1</span><br><span class=\"line\">5、在满足x&gt;1的情况下，如果y&#x3D;gcd(x-1,N)&gt;1,那么其中一个因数p&#x3D;y， 另一个因数为N&#x2F;y,如果不满足条件，返回步骤2，重新选择数字g</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本特征\"><a href=\"#基本特征\" class=\"headerlink\" title=\"基本特征\"></a>基本特征</h1><ul>\n<li><p>前面说过RSA的基本参数，我们知道e<em>d≡1 mod (p-1)</em>(q-1).</p>\n</li>\n<li><p>这个题型是说，当我们从题目中得到e*d和N的值时，如何通过分解N来解密ｒｓａ</p>\n<h1 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h1></li>\n<li><p>输入e,d</p>\n</li>\n<li><p>e,d都是奇数，因为它们相对于(p-1)*(q-1)都是素数</p>\n</li>\n<li><p>通过建立e*d=1 mod Φ(N)</p>\n</li>\n<li><p>让e*d-1=2^k * r(r 是奇数)</p>\n</li>\n<li><p>让(1&lt;b&lt;N)，从中随机挑选b</p>\n</li>\n<li><p>如果gcd(b,N)&gt;1,我们就停止</p>\n</li>\n<li><p>否则 b∈ZN<em>, 那么b^(e</em>d-1)=1 mod N</p>\n</li>\n<li><p>让e<em>d-1=2^k  *r  当r是奇数，b^(e</em>d-1)=1 mod N ,求mod N\\</p>\n</li>\n<li><p>a0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.我们知道ak&#x3D;1  让j是aj &#x3D;1mod  N 的最小指数</span><br><span class=\"line\">2. 如果0&lt;j并且a(j-1) 不等于N-1那么a(j-1)是关于1mod  N 的一个非平凡根</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定理\"><a href=\"#定理\" class=\"headerlink\" title=\"定理\"></a>定理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">至少有一半的b，1&lt;b&lt;N，满足是1 mod N 的一个非平凡根</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">证明过程：</span><br><span class=\"line\">如果x^2&#x3D;1 mod N 并且 x不等于1，N-1 那么gcd(x+1,N)&gt;0</span><br><span class=\"line\"></span><br><span class=\"line\">证明过程：x^2 -1 &#x3D;(x+1)*(x-1) .      N除以乘积，但是x不等于N-1,1.</span><br><span class=\"line\">\t    因此N不能除以(x-1)或者(x+1)</span><br><span class=\"line\">\t    所以p必须除以其中一个,q除以另外一个</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a>范围</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入d,e,N,随机选择b</span><br><span class=\"line\">让e*d-1&#x3D;2^k *r (r是奇数)，b^(e*d-1)&#x3D;1 mod N</span><br><span class=\"line\">求mod N</span><br><span class=\"line\">a0 &#x3D; b^r, a1 &#x3D; (a0)^2, a2 &#x3D; (a1)^2,…, ak &#x3D; (ak-1)^2.</span><br><span class=\"line\">由定理可知，对于概率大于 0.5，aj中的一个是1模N的非平凡平方根，这样的根产生N的因式分解</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">所有的操作都是在log N内</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">N&#x3D;2773   e&#x3D;17   d&#x3D;157</span><br><span class=\"line\"></span><br><span class=\"line\">计算过程:</span><br><span class=\"line\">e*d-1&#x3D;2668&#x3D;2^2  *667</span><br><span class=\"line\">随机挑选b，进行mod 2773的操作</span><br><span class=\"line\">b&#x3D;7   7^667&#x3D;1 mod N        不好</span><br><span class=\"line\"> b&#x3D;8   8^667&#x3D;471 mod N, 并且 471^2&#x3D;1 mod N,所以471是1 mod 2773的非平凡平方根</span><br><span class=\"line\"></span><br><span class=\"line\">Gcd(472,N)&#x3D;59          gcd(470,N)&#x3D;47</span><br><span class=\"line\">2773&#x2F;&#x2F;59&#x3D;47</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、设定k&#x3D;e*d-1</span><br><span class=\"line\">2、从2到N-1的范围内随机选择一个数字g</span><br><span class=\"line\">3、将k写成2^t  *r 的形式</span><br><span class=\"line\">4、如果t能被2整除，那么t&#x3D;t&#x2F;2,并且x&#x3D;g^t mod N ,直到x&gt;1</span><br><span class=\"line\">5、在满足x&gt;1的情况下，如果y&#x3D;gcd(x-1,N)&gt;1,那么其中一个因数p&#x3D;y， 另一个因数为N&#x2F;y,如果不满足条件，返回步骤2，重新选择数字g</span><br></pre></td></tr></table></figure>"},{"title":"rsa当e=2且不互素时处理方式","author":"人生若只如初见","date":"2020-06-23T10:10:00.000Z","_content":"# 整个过程简化为6步\n* 1、运用广义Euclid除法，求出整数s和t使得sp+tq=1\n* 2、计算u≡c**((p+1)/4) (mod p)\n* 3、计算v≡c**((q+1)/4) (mod q)\n* 4、计算x≡(tqu+spv)  (mod n)\n* 5、计算y≡(tqu-spv)  (mod n)\n* 6、同余式x**2≡c (mod n) 的四个根是x,-x(mod n),y,-y(mod n)\n\n\n\n*  其中一个根即为密文\n\n```\n# -*-coding: utf-8 -*-  \nimport gmpy  \n\ndef n2s(num):  \n    t = hex(num)[2:]  \n    if len(t) % 2 == 1:  \n        return ('0'+t).decode('hex')  \n    return t.decode('hex')  \n\nc = int(open('flag.enc','rb').read().encode('hex'),16)  # 密文 c  \np = 275127860351348928173285174381581152299             # 分解后的素数 p  \nq = 319576316814478949870590164193048041239             # 分解后的素数 q  \nn = p*q                                                 # 公钥 N  \n\n# 根据中国剩余定理求解相应明文  \nr = pow(c,(p+1)/4,p)  \ns = pow(c,(q+1)/4,q)  \na = gmpy.invert(p,q)  \nb = gmpy.invert(q,p)  \nx =(a*p*s+b*q*r)%n  \ny =(a*p*s-b*q*r)%n  \n\n# 打印明文  \nprint n2s(x%n)  \nprint n2s((-x)%n)  \nprint n2s(y%n)  \nprint n2s((-y)%n)\n```","source":"_drafts/rsa当e-2且不互素时处理方式.md","raw":"title: rsa当e=2且不互素时处理方式\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-06-23 18:10:00\n---\n# 整个过程简化为6步\n* 1、运用广义Euclid除法，求出整数s和t使得sp+tq=1\n* 2、计算u≡c**((p+1)/4) (mod p)\n* 3、计算v≡c**((q+1)/4) (mod q)\n* 4、计算x≡(tqu+spv)  (mod n)\n* 5、计算y≡(tqu-spv)  (mod n)\n* 6、同余式x**2≡c (mod n) 的四个根是x,-x(mod n),y,-y(mod n)\n\n\n\n*  其中一个根即为密文\n\n```\n# -*-coding: utf-8 -*-  \nimport gmpy  \n\ndef n2s(num):  \n    t = hex(num)[2:]  \n    if len(t) % 2 == 1:  \n        return ('0'+t).decode('hex')  \n    return t.decode('hex')  \n\nc = int(open('flag.enc','rb').read().encode('hex'),16)  # 密文 c  \np = 275127860351348928173285174381581152299             # 分解后的素数 p  \nq = 319576316814478949870590164193048041239             # 分解后的素数 q  \nn = p*q                                                 # 公钥 N  \n\n# 根据中国剩余定理求解相应明文  \nr = pow(c,(p+1)/4,p)  \ns = pow(c,(q+1)/4,q)  \na = gmpy.invert(p,q)  \nb = gmpy.invert(q,p)  \nx =(a*p*s+b*q*r)%n  \ny =(a*p*s-b*q*r)%n  \n\n# 打印明文  \nprint n2s(x%n)  \nprint n2s((-x)%n)  \nprint n2s(y%n)  \nprint n2s((-y)%n)\n```","slug":"rsa当e-2且不互素时处理方式","published":0,"updated":"2020-06-23T10:35:18.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17p000hvcu91ocwcrha","content":"<h1 id=\"整个过程简化为6步\"><a href=\"#整个过程简化为6步\" class=\"headerlink\" title=\"整个过程简化为6步\"></a>整个过程简化为6步</h1><ul>\n<li>1、运用广义Euclid除法，求出整数s和t使得sp+tq=1</li>\n<li>2、计算u≡c**((p+1)/4) (mod p)</li>\n<li>3、计算v≡c**((q+1)/4) (mod q)</li>\n<li>4、计算x≡(tqu+spv)  (mod n)</li>\n<li>5、计算y≡(tqu-spv)  (mod n)</li>\n<li>6、同余式x**2≡c (mod n) 的四个根是x,-x(mod n),y,-y(mod n)</li>\n</ul>\n<ul>\n<li>其中一个根即为密文</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -*-coding: utf-8 -*-  </span><br><span class=\"line\">import gmpy  </span><br><span class=\"line\"></span><br><span class=\"line\">def n2s(num):  </span><br><span class=\"line\">    t &#x3D; hex(num)[2:]  </span><br><span class=\"line\">    if len(t) % 2 &#x3D;&#x3D; 1:  </span><br><span class=\"line\">        return (&#39;0&#39;+t).decode(&#39;hex&#39;)  </span><br><span class=\"line\">    return t.decode(&#39;hex&#39;)  </span><br><span class=\"line\"></span><br><span class=\"line\">c &#x3D; int(open(&#39;flag.enc&#39;,&#39;rb&#39;).read().encode(&#39;hex&#39;),16)  # 密文 c  </span><br><span class=\"line\">p &#x3D; 275127860351348928173285174381581152299             # 分解后的素数 p  </span><br><span class=\"line\">q &#x3D; 319576316814478949870590164193048041239             # 分解后的素数 q  </span><br><span class=\"line\">n &#x3D; p*q                                                 # 公钥 N  </span><br><span class=\"line\"></span><br><span class=\"line\"># 根据中国剩余定理求解相应明文  </span><br><span class=\"line\">r &#x3D; pow(c,(p+1)&#x2F;4,p)  </span><br><span class=\"line\">s &#x3D; pow(c,(q+1)&#x2F;4,q)  </span><br><span class=\"line\">a &#x3D; gmpy.invert(p,q)  </span><br><span class=\"line\">b &#x3D; gmpy.invert(q,p)  </span><br><span class=\"line\">x &#x3D;(a*p*s+b*q*r)%n  </span><br><span class=\"line\">y &#x3D;(a*p*s-b*q*r)%n  </span><br><span class=\"line\"></span><br><span class=\"line\"># 打印明文  </span><br><span class=\"line\">print n2s(x%n)  </span><br><span class=\"line\">print n2s((-x)%n)  </span><br><span class=\"line\">print n2s(y%n)  </span><br><span class=\"line\">print n2s((-y)%n)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"整个过程简化为6步\"><a href=\"#整个过程简化为6步\" class=\"headerlink\" title=\"整个过程简化为6步\"></a>整个过程简化为6步</h1><ul>\n<li>1、运用广义Euclid除法，求出整数s和t使得sp+tq=1</li>\n<li>2、计算u≡c**((p+1)/4) (mod p)</li>\n<li>3、计算v≡c**((q+1)/4) (mod q)</li>\n<li>4、计算x≡(tqu+spv)  (mod n)</li>\n<li>5、计算y≡(tqu-spv)  (mod n)</li>\n<li>6、同余式x**2≡c (mod n) 的四个根是x,-x(mod n),y,-y(mod n)</li>\n</ul>\n<ul>\n<li>其中一个根即为密文</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -*-coding: utf-8 -*-  </span><br><span class=\"line\">import gmpy  </span><br><span class=\"line\"></span><br><span class=\"line\">def n2s(num):  </span><br><span class=\"line\">    t &#x3D; hex(num)[2:]  </span><br><span class=\"line\">    if len(t) % 2 &#x3D;&#x3D; 1:  </span><br><span class=\"line\">        return (&#39;0&#39;+t).decode(&#39;hex&#39;)  </span><br><span class=\"line\">    return t.decode(&#39;hex&#39;)  </span><br><span class=\"line\"></span><br><span class=\"line\">c &#x3D; int(open(&#39;flag.enc&#39;,&#39;rb&#39;).read().encode(&#39;hex&#39;),16)  # 密文 c  </span><br><span class=\"line\">p &#x3D; 275127860351348928173285174381581152299             # 分解后的素数 p  </span><br><span class=\"line\">q &#x3D; 319576316814478949870590164193048041239             # 分解后的素数 q  </span><br><span class=\"line\">n &#x3D; p*q                                                 # 公钥 N  </span><br><span class=\"line\"></span><br><span class=\"line\"># 根据中国剩余定理求解相应明文  </span><br><span class=\"line\">r &#x3D; pow(c,(p+1)&#x2F;4,p)  </span><br><span class=\"line\">s &#x3D; pow(c,(q+1)&#x2F;4,q)  </span><br><span class=\"line\">a &#x3D; gmpy.invert(p,q)  </span><br><span class=\"line\">b &#x3D; gmpy.invert(q,p)  </span><br><span class=\"line\">x &#x3D;(a*p*s+b*q*r)%n  </span><br><span class=\"line\">y &#x3D;(a*p*s-b*q*r)%n  </span><br><span class=\"line\"></span><br><span class=\"line\"># 打印明文  </span><br><span class=\"line\">print n2s(x%n)  </span><br><span class=\"line\">print n2s((-x)%n)  </span><br><span class=\"line\">print n2s(y%n)  </span><br><span class=\"line\">print n2s((-y)%n)</span><br></pre></td></tr></table></figure>"},{"title":"密码学编码(一)ASCII编码","author":"人生若只如初见","date":"2020-05-27T09:56:00.000Z","_content":"* 我的密码学入门是从编码开始，逐步认识到各种密码类型，我会逐步总结。\n* 今天先介绍ASCII，base系列等编码\n\n# ASCII\n\n* 计算机的最早发明者是美国人，所以他们首要面临的问题就是如何让机器能够将他们的文字，也就是拉丁字母与二进制相对应，然而在计算机出现早期，各个公司都创建了属于自己的一套编码规则，这给不同计算机之间的数据交换带来了极大困难。\n* ASCII的标准版本第一次发布于1967年，迄今为止共收录了128个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是1234567890）、标点符号（,.!等）、特殊符号（@#$%^&等）以及一些具有控制功能的字符（往往不会显示出来）。\n* 在ASCII编码中，大写字母、小写字母和阿拉伯数字都是连续分布的。\n\n* 连续分布的ASCII编码为程序员带来了极大方便，例如：当寻找某个字母的位置时，只需要记住A的ASCII编码，然后加上两者之间的间隔。\n\n![](/images/pasted-7.png)\n* 扩展ASCII打印字符\n* 扩展的ASCII字符满足了对更多字符的需求.增加了128个字符.\n* 即使有了这些更多的字符,许多语言还是包含无法压缩到256个字符中的符号.因此,出现了一些ASCII的变体来囊括地区性字符和符号.\n\n![](/images/pasted-8.png)\n* 在平时遇到大批量的ASCII编码需要转换时，可进入下列在线网站 ：[ASCII编码](https://www.qqxiuzi.cn/bianma/ascii.htm)\n\n* 除此以外，还可以将二进制，十六进制直接转换为ASCII编码（本质上是将其他进制转换为十进制，再将十进制与ASCII编码一一对应）\n\n* 下面附上python3脚本（将十六进制转换为ASCII）\n\n```\nfrom binascii import a2b_hex\n\nh =input()\np1 = bytes(h,'utf-8')\np2 = a2b_hex(p1)\nprint(p2.decode())\n```\n* 下一节我们讲解base系列编码\n","source":"_drafts/密码学编码-一-ASCII编码.md","raw":"title: 密码学编码(一)ASCII编码\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 编码\ndate: 2020-05-27 17:56:00\n---\n* 我的密码学入门是从编码开始，逐步认识到各种密码类型，我会逐步总结。\n* 今天先介绍ASCII，base系列等编码\n\n# ASCII\n\n* 计算机的最早发明者是美国人，所以他们首要面临的问题就是如何让机器能够将他们的文字，也就是拉丁字母与二进制相对应，然而在计算机出现早期，各个公司都创建了属于自己的一套编码规则，这给不同计算机之间的数据交换带来了极大困难。\n* ASCII的标准版本第一次发布于1967年，迄今为止共收录了128个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是1234567890）、标点符号（,.!等）、特殊符号（@#$%^&等）以及一些具有控制功能的字符（往往不会显示出来）。\n* 在ASCII编码中，大写字母、小写字母和阿拉伯数字都是连续分布的。\n\n* 连续分布的ASCII编码为程序员带来了极大方便，例如：当寻找某个字母的位置时，只需要记住A的ASCII编码，然后加上两者之间的间隔。\n\n![](/images/pasted-7.png)\n* 扩展ASCII打印字符\n* 扩展的ASCII字符满足了对更多字符的需求.增加了128个字符.\n* 即使有了这些更多的字符,许多语言还是包含无法压缩到256个字符中的符号.因此,出现了一些ASCII的变体来囊括地区性字符和符号.\n\n![](/images/pasted-8.png)\n* 在平时遇到大批量的ASCII编码需要转换时，可进入下列在线网站 ：[ASCII编码](https://www.qqxiuzi.cn/bianma/ascii.htm)\n\n* 除此以外，还可以将二进制，十六进制直接转换为ASCII编码（本质上是将其他进制转换为十进制，再将十进制与ASCII编码一一对应）\n\n* 下面附上python3脚本（将十六进制转换为ASCII）\n\n```\nfrom binascii import a2b_hex\n\nh =input()\np1 = bytes(h,'utf-8')\np2 = a2b_hex(p1)\nprint(p2.decode())\n```\n* 下一节我们讲解base系列编码\n","slug":"密码学编码-一-ASCII编码","published":0,"updated":"2020-05-27T09:59:26.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17q000jvcu9hpav4r76","content":"<ul>\n<li>我的密码学入门是从编码开始，逐步认识到各种密码类型，我会逐步总结。</li>\n<li>今天先介绍ASCII，base系列等编码</li>\n</ul>\n<h1 id=\"ASCII\"><a href=\"#ASCII\" class=\"headerlink\" title=\"ASCII\"></a>ASCII</h1><ul>\n<li><p>计算机的最早发明者是美国人，所以他们首要面临的问题就是如何让机器能够将他们的文字，也就是拉丁字母与二进制相对应，然而在计算机出现早期，各个公司都创建了属于自己的一套编码规则，这给不同计算机之间的数据交换带来了极大困难。</p>\n</li>\n<li><p>ASCII的标准版本第一次发布于1967年，迄今为止共收录了128个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是1234567890）、标点符号（,.!等）、特殊符号（@#$%^&amp;等）以及一些具有控制功能的字符（往往不会显示出来）。</p>\n</li>\n<li><p>在ASCII编码中，大写字母、小写字母和阿拉伯数字都是连续分布的。</p>\n</li>\n<li><p>连续分布的ASCII编码为程序员带来了极大方便，例如：当寻找某个字母的位置时，只需要记住A的ASCII编码，然后加上两者之间的间隔。</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-7.png\" alt=\"\"></p>\n<ul>\n<li>扩展ASCII打印字符</li>\n<li>扩展的ASCII字符满足了对更多字符的需求.增加了128个字符.</li>\n<li>即使有了这些更多的字符,许多语言还是包含无法压缩到256个字符中的符号.因此,出现了一些ASCII的变体来囊括地区性字符和符号.</li>\n</ul>\n<p><img src=\"/images/pasted-8.png\" alt=\"\"></p>\n<ul>\n<li><p>在平时遇到大批量的ASCII编码需要转换时，可进入下列在线网站 ：<a href=\"https://www.qqxiuzi.cn/bianma/ascii.htm\" target=\"_blank\" rel=\"noopener\">ASCII编码</a></p>\n</li>\n<li><p>除此以外，还可以将二进制，十六进制直接转换为ASCII编码（本质上是将其他进制转换为十进制，再将十进制与ASCII编码一一对应）</p>\n</li>\n<li><p>下面附上python3脚本（将十六进制转换为ASCII）</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from binascii import a2b_hex</span><br><span class=\"line\"></span><br><span class=\"line\">h &#x3D;input()</span><br><span class=\"line\">p1 &#x3D; bytes(h,&#39;utf-8&#39;)</span><br><span class=\"line\">p2 &#x3D; a2b_hex(p1)</span><br><span class=\"line\">print(p2.decode())</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下一节我们讲解base系列编码</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>我的密码学入门是从编码开始，逐步认识到各种密码类型，我会逐步总结。</li>\n<li>今天先介绍ASCII，base系列等编码</li>\n</ul>\n<h1 id=\"ASCII\"><a href=\"#ASCII\" class=\"headerlink\" title=\"ASCII\"></a>ASCII</h1><ul>\n<li><p>计算机的最早发明者是美国人，所以他们首要面临的问题就是如何让机器能够将他们的文字，也就是拉丁字母与二进制相对应，然而在计算机出现早期，各个公司都创建了属于自己的一套编码规则，这给不同计算机之间的数据交换带来了极大困难。</p>\n</li>\n<li><p>ASCII的标准版本第一次发布于1967年，迄今为止共收录了128个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是1234567890）、标点符号（,.!等）、特殊符号（@#$%^&amp;等）以及一些具有控制功能的字符（往往不会显示出来）。</p>\n</li>\n<li><p>在ASCII编码中，大写字母、小写字母和阿拉伯数字都是连续分布的。</p>\n</li>\n<li><p>连续分布的ASCII编码为程序员带来了极大方便，例如：当寻找某个字母的位置时，只需要记住A的ASCII编码，然后加上两者之间的间隔。</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-7.png\" alt=\"\"></p>\n<ul>\n<li>扩展ASCII打印字符</li>\n<li>扩展的ASCII字符满足了对更多字符的需求.增加了128个字符.</li>\n<li>即使有了这些更多的字符,许多语言还是包含无法压缩到256个字符中的符号.因此,出现了一些ASCII的变体来囊括地区性字符和符号.</li>\n</ul>\n<p><img src=\"/images/pasted-8.png\" alt=\"\"></p>\n<ul>\n<li><p>在平时遇到大批量的ASCII编码需要转换时，可进入下列在线网站 ：<a href=\"https://www.qqxiuzi.cn/bianma/ascii.htm\" target=\"_blank\" rel=\"noopener\">ASCII编码</a></p>\n</li>\n<li><p>除此以外，还可以将二进制，十六进制直接转换为ASCII编码（本质上是将其他进制转换为十进制，再将十进制与ASCII编码一一对应）</p>\n</li>\n<li><p>下面附上python3脚本（将十六进制转换为ASCII）</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from binascii import a2b_hex</span><br><span class=\"line\"></span><br><span class=\"line\">h &#x3D;input()</span><br><span class=\"line\">p1 &#x3D; bytes(h,&#39;utf-8&#39;)</span><br><span class=\"line\">p2 &#x3D; a2b_hex(p1)</span><br><span class=\"line\">print(p2.decode())</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下一节我们讲解base系列编码</li>\n</ul>\n"},{"title":"密码学编码(三)Unicode编码","author":"人生若只如初见","date":"2020-05-27T10:01:00.000Z","_content":"* 计算机发展早期，编码只有ASCII编码，但ASCII编码只能够用来表示拉丁字母、数字以及一些特殊符号，而语言不止英语一种，例如中文一个字节是不够表示的，最少需要两个字节，并且需要兼容ASCII编码，不能与之发生冲突。为了解决传统字符编码方案的局限性，所以Unicode编码应运而生。\n\n* Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。\n\n* 在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。\n* 几乎所有电脑系统都支持基本拉丁字母，并各自支持不同的其他编码方式。Unicode为了和它们相互兼容，其首256字符保留给ISO 8859-1所定义的字符，使既有的西欧语系文字的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。举例来说，全角格式区段包含了主要的拉丁字母的全角格式，在中文、日文、以及韩文字形当中，这些字符以全角的方式来呈现，而不以常见的半角形式显示，这对竖排文字和等宽排列文字有重要作用。\n\n* Unicode为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF(十六进制)，有110多万，每个字符都有一个唯一的Unicode编号，这个编号一般写成16进制，在前面加上U+。例如：“马”的Unicode是U+9A6C。\n* Unicode就相当于一张表，建立了字符与编号之间的联系,它是一种规定，Unicode本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。\n* 除了直接转换为二进制的策略，Unicode 可以使用的编码有三种，分别是：\n\n```\nUFT-8：一种变长的编码方案，使用 1~6 个字节来存储；\nUFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；\nUTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。\n```\n\n* ①Unicode其实应该是一个码值表。（百度百科：Unicode的功用是为每一个字符提供一个唯一的代码（即一组数字））。\n* ②UTF-8/UTF-16/UTF-32是通过对Unicode码值进行对应规则转换后，编码保持到内存/文件中。UTF-8/UTF-16/UTF-32都是可变长度的编码方式。（后面将进行Unicode码值转换为UTF-8的说明）。\n* ③我们平常说的 “Unicode编码是2个字节” 这句话，其实是因为windows默认的Unicode编码就是UTF-16，在常用基本字符上2个字节的编码方式已经够用导致的误解，其实是可变长度的。在没有特殊说明的情况下，常说的Unicode编码可以理解为UTF-16编码。\n* ④UTF-32是因为UTF-16编码方式不能表示全部的字符而扩充的编码方式。\n* ps：显示的字符是表现形式，具体内存中的编码方式和字符显示之间通过中间层进行转换。（根据编码规则，1个字符可能对应内存中1个到几个字节。）\n\n* 这里转换为二进制后计算机的储存问题：计算机在存储器中排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34\n* UTF-8编码不存在字节序大小端问题！（因为字节序只影响同时处理多于两个字节的编码方式，比如UTF-16/UTF-32，而UTF-8是按照单字节进行处理的）\n* UTF-8的解码都必须先读取首字节获取字节数，所以必须找到首字节的第一位要么是0，要么是110/1110/11110/111110/1111110，所以上面的“中”字，无论是保存为11100100 10111000 10101101还是10101101 10111000 11100100，都必须要先找到11100100这个字节，所以UTF-8从机制上就能避免字节序的问题。\n* UTF-16/UTF-32存在字节序问题（UTF-16常用情况下一次处理2个字节/UTF-32一次处理4个字节）！一个“奎”的Unicode码值是0x594E，“乙”的Unicode码值是0x4E59。如果我们的UTF-16字节数据是0x594E，那么这是“奎”还是“乙”？如果大端序，0x594E是“奎”，如果是小端序，0x4E59，是“乙”。\n\n![](/images/pasted-9.png)\n## UTF-8\n* UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：\n\n```\n对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。\n\n对于需要使用 N 个字节来表示的字符（N > 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。\n```\n\n* 编码规则：\n![](/images/pasted-10.png)\n\n![](/images/pasted-11.png)\n\n![](/images/pasted-12.png)\n* 对于具体的Unicode编号，进行UTF-8编码的方法：\n* 首先找到该Unicode编号所在的编号范围，进而找到对应的二进制格式，然后将该Unicode编号转换为二进制数有（去掉高位的0）最后将该二进制数一次填充入二进制格式的X中，未填充的X变为0.\n* 例：马的Unicode编号是：0x9A6C，整数编号是39532，其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532对应的二进制为1001 1010 0110 1100，填入为：11101001 10101001 10101100\n\n## UTF-16\n* 为了弄清楚UTF-16文件的大小尾序，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文字档案是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。\n* 使用2字节或者4字节进行编码\n* 字符按照UTF-16进行编码的规则是： - 字符的值小于0x10000的用等于该值的16位整数来表示。 - 字符的值介于0x10000和0x10FFFF之间的，用一个值介于0xD800和0xDBFF(在所谓的高8位区)的16位整数和值介于0xDC00和0xDFFF(在所谓的低8位区)的16位整数来表示。 - 字符的值大于0x10FFFF不能按照UTF-16进行编码。注意：在0xD800和0xDFFF间的值是特别为UTF-16预留，所以不应该将任何字符的值指定为这个区间内的数值。\n\n```\nD800－DB7F High Surrogates 高位替代 895\nDB80－DBFF High Private Use Surrogates 高位专用替代 127\nDC00－DFFF Low Surrogates 低位替代 1023\n```\n\n* 高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。\n* 如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：\n\n```\n1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111\n```\n\n* 按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到\n\n```\n1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111\n```\n* 即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代。\n## UTF-32\n* UTF-32 是固定长度的编码，始终占用 4 个字节，足以容纳所有的 Unicode 字符，所以直接存储 Unicode 编号即可，不需要任何编码转换。浪费了空间，赢得了效率。\n* BOM（Byte Order Mark）\n\n```\n①为了保证编码和解码字节顺序问题（因为只有保证编码和解码的规则一致才能保证是同一个字符），所以Unicode规范中推荐的标记字节顺序的方法是BOM（Byte Order Mark）。\n②UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。根据BOM的规则，在一段字节流开始时，如果接收到以下字节，则分别表明了该文本文件的编码。\n\tUTF-8: EF BB BF\n\tUTF-16 : FF FE\n\tUTF-16 big-endian: FE FF\n\tUTF-32 little-endian: FF FE 00 00\n\tUTF-32 big-endian: 00 00 FE FF\n而如果不是以这个开头，那程序则会以ANSI，也就是系统默认编码读取。\n如同样是字符“A”﹐在以下几种格式中的存储形式分别是﹕\n\tUTF-16 big-endian : 00 41\n\tUTF-16 little-endian : 41 00\n\tUTF-32 big-endian : 00 00 00 41\n\tUTF-32 little-endian : 41 00 00 00\n```","source":"_drafts/密码学编码-三-Unicode编码.md","raw":"title: 密码学编码(三)Unicode编码\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 编码\ndate: 2020-05-27 18:01:00\n---\n* 计算机发展早期，编码只有ASCII编码，但ASCII编码只能够用来表示拉丁字母、数字以及一些特殊符号，而语言不止英语一种，例如中文一个字节是不够表示的，最少需要两个字节，并且需要兼容ASCII编码，不能与之发生冲突。为了解决传统字符编码方案的局限性，所以Unicode编码应运而生。\n\n* Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。\n\n* 在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。\n* 几乎所有电脑系统都支持基本拉丁字母，并各自支持不同的其他编码方式。Unicode为了和它们相互兼容，其首256字符保留给ISO 8859-1所定义的字符，使既有的西欧语系文字的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。举例来说，全角格式区段包含了主要的拉丁字母的全角格式，在中文、日文、以及韩文字形当中，这些字符以全角的方式来呈现，而不以常见的半角形式显示，这对竖排文字和等宽排列文字有重要作用。\n\n* Unicode为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF(十六进制)，有110多万，每个字符都有一个唯一的Unicode编号，这个编号一般写成16进制，在前面加上U+。例如：“马”的Unicode是U+9A6C。\n* Unicode就相当于一张表，建立了字符与编号之间的联系,它是一种规定，Unicode本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。\n* 除了直接转换为二进制的策略，Unicode 可以使用的编码有三种，分别是：\n\n```\nUFT-8：一种变长的编码方案，使用 1~6 个字节来存储；\nUFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；\nUTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。\n```\n\n* ①Unicode其实应该是一个码值表。（百度百科：Unicode的功用是为每一个字符提供一个唯一的代码（即一组数字））。\n* ②UTF-8/UTF-16/UTF-32是通过对Unicode码值进行对应规则转换后，编码保持到内存/文件中。UTF-8/UTF-16/UTF-32都是可变长度的编码方式。（后面将进行Unicode码值转换为UTF-8的说明）。\n* ③我们平常说的 “Unicode编码是2个字节” 这句话，其实是因为windows默认的Unicode编码就是UTF-16，在常用基本字符上2个字节的编码方式已经够用导致的误解，其实是可变长度的。在没有特殊说明的情况下，常说的Unicode编码可以理解为UTF-16编码。\n* ④UTF-32是因为UTF-16编码方式不能表示全部的字符而扩充的编码方式。\n* ps：显示的字符是表现形式，具体内存中的编码方式和字符显示之间通过中间层进行转换。（根据编码规则，1个字符可能对应内存中1个到几个字节。）\n\n* 这里转换为二进制后计算机的储存问题：计算机在存储器中排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34\n* UTF-8编码不存在字节序大小端问题！（因为字节序只影响同时处理多于两个字节的编码方式，比如UTF-16/UTF-32，而UTF-8是按照单字节进行处理的）\n* UTF-8的解码都必须先读取首字节获取字节数，所以必须找到首字节的第一位要么是0，要么是110/1110/11110/111110/1111110，所以上面的“中”字，无论是保存为11100100 10111000 10101101还是10101101 10111000 11100100，都必须要先找到11100100这个字节，所以UTF-8从机制上就能避免字节序的问题。\n* UTF-16/UTF-32存在字节序问题（UTF-16常用情况下一次处理2个字节/UTF-32一次处理4个字节）！一个“奎”的Unicode码值是0x594E，“乙”的Unicode码值是0x4E59。如果我们的UTF-16字节数据是0x594E，那么这是“奎”还是“乙”？如果大端序，0x594E是“奎”，如果是小端序，0x4E59，是“乙”。\n\n![](/images/pasted-9.png)\n## UTF-8\n* UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：\n\n```\n对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。\n\n对于需要使用 N 个字节来表示的字符（N > 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。\n```\n\n* 编码规则：\n![](/images/pasted-10.png)\n\n![](/images/pasted-11.png)\n\n![](/images/pasted-12.png)\n* 对于具体的Unicode编号，进行UTF-8编码的方法：\n* 首先找到该Unicode编号所在的编号范围，进而找到对应的二进制格式，然后将该Unicode编号转换为二进制数有（去掉高位的0）最后将该二进制数一次填充入二进制格式的X中，未填充的X变为0.\n* 例：马的Unicode编号是：0x9A6C，整数编号是39532，其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532对应的二进制为1001 1010 0110 1100，填入为：11101001 10101001 10101100\n\n## UTF-16\n* 为了弄清楚UTF-16文件的大小尾序，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文字档案是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。\n* 使用2字节或者4字节进行编码\n* 字符按照UTF-16进行编码的规则是： - 字符的值小于0x10000的用等于该值的16位整数来表示。 - 字符的值介于0x10000和0x10FFFF之间的，用一个值介于0xD800和0xDBFF(在所谓的高8位区)的16位整数和值介于0xDC00和0xDFFF(在所谓的低8位区)的16位整数来表示。 - 字符的值大于0x10FFFF不能按照UTF-16进行编码。注意：在0xD800和0xDFFF间的值是特别为UTF-16预留，所以不应该将任何字符的值指定为这个区间内的数值。\n\n```\nD800－DB7F High Surrogates 高位替代 895\nDB80－DBFF High Private Use Surrogates 高位专用替代 127\nDC00－DFFF Low Surrogates 低位替代 1023\n```\n\n* 高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。\n* 如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：\n\n```\n1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111\n```\n\n* 按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到\n\n```\n1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111\n```\n* 即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代。\n## UTF-32\n* UTF-32 是固定长度的编码，始终占用 4 个字节，足以容纳所有的 Unicode 字符，所以直接存储 Unicode 编号即可，不需要任何编码转换。浪费了空间，赢得了效率。\n* BOM（Byte Order Mark）\n\n```\n①为了保证编码和解码字节顺序问题（因为只有保证编码和解码的规则一致才能保证是同一个字符），所以Unicode规范中推荐的标记字节顺序的方法是BOM（Byte Order Mark）。\n②UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。根据BOM的规则，在一段字节流开始时，如果接收到以下字节，则分别表明了该文本文件的编码。\n\tUTF-8: EF BB BF\n\tUTF-16 : FF FE\n\tUTF-16 big-endian: FE FF\n\tUTF-32 little-endian: FF FE 00 00\n\tUTF-32 big-endian: 00 00 FE FF\n而如果不是以这个开头，那程序则会以ANSI，也就是系统默认编码读取。\n如同样是字符“A”﹐在以下几种格式中的存储形式分别是﹕\n\tUTF-16 big-endian : 00 41\n\tUTF-16 little-endian : 41 00\n\tUTF-32 big-endian : 00 00 00 41\n\tUTF-32 little-endian : 41 00 00 00\n```","slug":"密码学编码-三-Unicode编码","published":0,"updated":"2020-05-27T10:08:57.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17r000kvcu9284ydgz3","content":"<ul>\n<li><p>计算机发展早期，编码只有ASCII编码，但ASCII编码只能够用来表示拉丁字母、数字以及一些特殊符号，而语言不止英语一种，例如中文一个字节是不够表示的，最少需要两个字节，并且需要兼容ASCII编码，不能与之发生冲突。为了解决传统字符编码方案的局限性，所以Unicode编码应运而生。</p>\n</li>\n<li><p>Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p>\n</li>\n<li><p>在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。</p>\n</li>\n<li><p>几乎所有电脑系统都支持基本拉丁字母，并各自支持不同的其他编码方式。Unicode为了和它们相互兼容，其首256字符保留给ISO 8859-1所定义的字符，使既有的西欧语系文字的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。举例来说，全角格式区段包含了主要的拉丁字母的全角格式，在中文、日文、以及韩文字形当中，这些字符以全角的方式来呈现，而不以常见的半角形式显示，这对竖排文字和等宽排列文字有重要作用。</p>\n</li>\n<li><p>Unicode为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF(十六进制)，有110多万，每个字符都有一个唯一的Unicode编号，这个编号一般写成16进制，在前面加上U+。例如：“马”的Unicode是U+9A6C。</p>\n</li>\n<li><p>Unicode就相当于一张表，建立了字符与编号之间的联系,它是一种规定，Unicode本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。</p>\n</li>\n<li><p>除了直接转换为二进制的策略，Unicode 可以使用的编码有三种，分别是：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UFT-8：一种变长的编码方案，使用 1~6 个字节来存储；</span><br><span class=\"line\">UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；</span><br><span class=\"line\">UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>①Unicode其实应该是一个码值表。（百度百科：Unicode的功用是为每一个字符提供一个唯一的代码（即一组数字））。</p>\n</li>\n<li><p>②UTF-8/UTF-16/UTF-32是通过对Unicode码值进行对应规则转换后，编码保持到内存/文件中。UTF-8/UTF-16/UTF-32都是可变长度的编码方式。（后面将进行Unicode码值转换为UTF-8的说明）。</p>\n</li>\n<li><p>③我们平常说的 “Unicode编码是2个字节” 这句话，其实是因为windows默认的Unicode编码就是UTF-16，在常用基本字符上2个字节的编码方式已经够用导致的误解，其实是可变长度的。在没有特殊说明的情况下，常说的Unicode编码可以理解为UTF-16编码。</p>\n</li>\n<li><p>④UTF-32是因为UTF-16编码方式不能表示全部的字符而扩充的编码方式。</p>\n</li>\n<li><p>ps：显示的字符是表现形式，具体内存中的编码方式和字符显示之间通过中间层进行转换。（根据编码规则，1个字符可能对应内存中1个到几个字节。）</p>\n</li>\n<li><p>这里转换为二进制后计算机的储存问题：计算机在存储器中排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34</p>\n</li>\n<li><p>UTF-8编码不存在字节序大小端问题！（因为字节序只影响同时处理多于两个字节的编码方式，比如UTF-16/UTF-32，而UTF-8是按照单字节进行处理的）</p>\n</li>\n<li><p>UTF-8的解码都必须先读取首字节获取字节数，所以必须找到首字节的第一位要么是0，要么是110/1110/11110/111110/1111110，所以上面的“中”字，无论是保存为11100100 10111000 10101101还是10101101 10111000 11100100，都必须要先找到11100100这个字节，所以UTF-8从机制上就能避免字节序的问题。</p>\n</li>\n<li><p>UTF-16/UTF-32存在字节序问题（UTF-16常用情况下一次处理2个字节/UTF-32一次处理4个字节）！一个“奎”的Unicode码值是0x594E，“乙”的Unicode码值是0x4E59。如果我们的UTF-16字节数据是0x594E，那么这是“奎”还是“乙”？如果大端序，0x594E是“奎”，如果是小端序，0x4E59，是“乙”。</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-9.png\" alt=\"\"></p>\n<h2 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h2><ul>\n<li>UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。</span><br><span class=\"line\"></span><br><span class=\"line\">对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编码规则：<br><img src=\"/images/pasted-10.png\" alt=\"\"></li>\n</ul>\n<p><img src=\"/images/pasted-11.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-12.png\" alt=\"\"></p>\n<ul>\n<li>对于具体的Unicode编号，进行UTF-8编码的方法：</li>\n<li>首先找到该Unicode编号所在的编号范围，进而找到对应的二进制格式，然后将该Unicode编号转换为二进制数有（去掉高位的0）最后将该二进制数一次填充入二进制格式的X中，未填充的X变为0.</li>\n<li>例：马的Unicode编号是：0x9A6C，整数编号是39532，其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532对应的二进制为1001 1010 0110 1100，填入为：11101001 10101001 10101100</li>\n</ul>\n<h2 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h2><ul>\n<li>为了弄清楚UTF-16文件的大小尾序，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文字档案是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。</li>\n<li>使用2字节或者4字节进行编码</li>\n<li>字符按照UTF-16进行编码的规则是： - 字符的值小于0x10000的用等于该值的16位整数来表示。 - 字符的值介于0x10000和0x10FFFF之间的，用一个值介于0xD800和0xDBFF(在所谓的高8位区)的16位整数和值介于0xDC00和0xDFFF(在所谓的低8位区)的16位整数来表示。 - 字符的值大于0x10FFFF不能按照UTF-16进行编码。注意：在0xD800和0xDFFF间的值是特别为UTF-16预留，所以不应该将任何字符的值指定为这个区间内的数值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D800－DB7F High Surrogates 高位替代 895</span><br><span class=\"line\">DB80－DBFF High Private Use Surrogates 高位专用替代 127</span><br><span class=\"line\">DC00－DFFF Low Surrogates 低位替代 1023</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。</li>\n<li>如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>\n<ul>\n<li>即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代。<h2 id=\"UTF-32\"><a href=\"#UTF-32\" class=\"headerlink\" title=\"UTF-32\"></a>UTF-32</h2></li>\n<li>UTF-32 是固定长度的编码，始终占用 4 个字节，足以容纳所有的 Unicode 字符，所以直接存储 Unicode 编号即可，不需要任何编码转换。浪费了空间，赢得了效率。</li>\n<li>BOM（Byte Order Mark）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">①为了保证编码和解码字节顺序问题（因为只有保证编码和解码的规则一致才能保证是同一个字符），所以Unicode规范中推荐的标记字节顺序的方法是BOM（Byte Order Mark）。</span><br><span class=\"line\">②UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。根据BOM的规则，在一段字节流开始时，如果接收到以下字节，则分别表明了该文本文件的编码。</span><br><span class=\"line\">\tUTF-8: EF BB BF</span><br><span class=\"line\">\tUTF-16 : FF FE</span><br><span class=\"line\">\tUTF-16 big-endian: FE FF</span><br><span class=\"line\">\tUTF-32 little-endian: FF FE 00 00</span><br><span class=\"line\">\tUTF-32 big-endian: 00 00 FE FF</span><br><span class=\"line\">而如果不是以这个开头，那程序则会以ANSI，也就是系统默认编码读取。</span><br><span class=\"line\">如同样是字符“A”﹐在以下几种格式中的存储形式分别是﹕</span><br><span class=\"line\">\tUTF-16 big-endian : 00 41</span><br><span class=\"line\">\tUTF-16 little-endian : 41 00</span><br><span class=\"line\">\tUTF-32 big-endian : 00 00 00 41</span><br><span class=\"line\">\tUTF-32 little-endian : 41 00 00 00</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>计算机发展早期，编码只有ASCII编码，但ASCII编码只能够用来表示拉丁字母、数字以及一些特殊符号，而语言不止英语一种，例如中文一个字节是不够表示的，最少需要两个字节，并且需要兼容ASCII编码，不能与之发生冲突。为了解决传统字符编码方案的局限性，所以Unicode编码应运而生。</p>\n</li>\n<li><p>Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p>\n</li>\n<li><p>在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。</p>\n</li>\n<li><p>几乎所有电脑系统都支持基本拉丁字母，并各自支持不同的其他编码方式。Unicode为了和它们相互兼容，其首256字符保留给ISO 8859-1所定义的字符，使既有的西欧语系文字的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。举例来说，全角格式区段包含了主要的拉丁字母的全角格式，在中文、日文、以及韩文字形当中，这些字符以全角的方式来呈现，而不以常见的半角形式显示，这对竖排文字和等宽排列文字有重要作用。</p>\n</li>\n<li><p>Unicode为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF(十六进制)，有110多万，每个字符都有一个唯一的Unicode编号，这个编号一般写成16进制，在前面加上U+。例如：“马”的Unicode是U+9A6C。</p>\n</li>\n<li><p>Unicode就相当于一张表，建立了字符与编号之间的联系,它是一种规定，Unicode本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。</p>\n</li>\n<li><p>除了直接转换为二进制的策略，Unicode 可以使用的编码有三种，分别是：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UFT-8：一种变长的编码方案，使用 1~6 个字节来存储；</span><br><span class=\"line\">UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；</span><br><span class=\"line\">UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>①Unicode其实应该是一个码值表。（百度百科：Unicode的功用是为每一个字符提供一个唯一的代码（即一组数字））。</p>\n</li>\n<li><p>②UTF-8/UTF-16/UTF-32是通过对Unicode码值进行对应规则转换后，编码保持到内存/文件中。UTF-8/UTF-16/UTF-32都是可变长度的编码方式。（后面将进行Unicode码值转换为UTF-8的说明）。</p>\n</li>\n<li><p>③我们平常说的 “Unicode编码是2个字节” 这句话，其实是因为windows默认的Unicode编码就是UTF-16，在常用基本字符上2个字节的编码方式已经够用导致的误解，其实是可变长度的。在没有特殊说明的情况下，常说的Unicode编码可以理解为UTF-16编码。</p>\n</li>\n<li><p>④UTF-32是因为UTF-16编码方式不能表示全部的字符而扩充的编码方式。</p>\n</li>\n<li><p>ps：显示的字符是表现形式，具体内存中的编码方式和字符显示之间通过中间层进行转换。（根据编码规则，1个字符可能对应内存中1个到几个字节。）</p>\n</li>\n<li><p>这里转换为二进制后计算机的储存问题：计算机在存储器中排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34</p>\n</li>\n<li><p>UTF-8编码不存在字节序大小端问题！（因为字节序只影响同时处理多于两个字节的编码方式，比如UTF-16/UTF-32，而UTF-8是按照单字节进行处理的）</p>\n</li>\n<li><p>UTF-8的解码都必须先读取首字节获取字节数，所以必须找到首字节的第一位要么是0，要么是110/1110/11110/111110/1111110，所以上面的“中”字，无论是保存为11100100 10111000 10101101还是10101101 10111000 11100100，都必须要先找到11100100这个字节，所以UTF-8从机制上就能避免字节序的问题。</p>\n</li>\n<li><p>UTF-16/UTF-32存在字节序问题（UTF-16常用情况下一次处理2个字节/UTF-32一次处理4个字节）！一个“奎”的Unicode码值是0x594E，“乙”的Unicode码值是0x4E59。如果我们的UTF-16字节数据是0x594E，那么这是“奎”还是“乙”？如果大端序，0x594E是“奎”，如果是小端序，0x4E59，是“乙”。</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-9.png\" alt=\"\"></p>\n<h2 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h2><ul>\n<li>UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。</span><br><span class=\"line\"></span><br><span class=\"line\">对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编码规则：<br><img src=\"/images/pasted-10.png\" alt=\"\"></li>\n</ul>\n<p><img src=\"/images/pasted-11.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-12.png\" alt=\"\"></p>\n<ul>\n<li>对于具体的Unicode编号，进行UTF-8编码的方法：</li>\n<li>首先找到该Unicode编号所在的编号范围，进而找到对应的二进制格式，然后将该Unicode编号转换为二进制数有（去掉高位的0）最后将该二进制数一次填充入二进制格式的X中，未填充的X变为0.</li>\n<li>例：马的Unicode编号是：0x9A6C，整数编号是39532，其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532对应的二进制为1001 1010 0110 1100，填入为：11101001 10101001 10101100</li>\n</ul>\n<h2 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h2><ul>\n<li>为了弄清楚UTF-16文件的大小尾序，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文字档案是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。</li>\n<li>使用2字节或者4字节进行编码</li>\n<li>字符按照UTF-16进行编码的规则是： - 字符的值小于0x10000的用等于该值的16位整数来表示。 - 字符的值介于0x10000和0x10FFFF之间的，用一个值介于0xD800和0xDBFF(在所谓的高8位区)的16位整数和值介于0xDC00和0xDFFF(在所谓的低8位区)的16位整数来表示。 - 字符的值大于0x10FFFF不能按照UTF-16进行编码。注意：在0xD800和0xDFFF间的值是特别为UTF-16预留，所以不应该将任何字符的值指定为这个区间内的数值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D800－DB7F High Surrogates 高位替代 895</span><br><span class=\"line\">DB80－DBFF High Private Use Surrogates 高位专用替代 127</span><br><span class=\"line\">DC00－DFFF Low Surrogates 低位替代 1023</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。</li>\n<li>如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>\n<ul>\n<li>即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代。<h2 id=\"UTF-32\"><a href=\"#UTF-32\" class=\"headerlink\" title=\"UTF-32\"></a>UTF-32</h2></li>\n<li>UTF-32 是固定长度的编码，始终占用 4 个字节，足以容纳所有的 Unicode 字符，所以直接存储 Unicode 编号即可，不需要任何编码转换。浪费了空间，赢得了效率。</li>\n<li>BOM（Byte Order Mark）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">①为了保证编码和解码字节顺序问题（因为只有保证编码和解码的规则一致才能保证是同一个字符），所以Unicode规范中推荐的标记字节顺序的方法是BOM（Byte Order Mark）。</span><br><span class=\"line\">②UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。根据BOM的规则，在一段字节流开始时，如果接收到以下字节，则分别表明了该文本文件的编码。</span><br><span class=\"line\">\tUTF-8: EF BB BF</span><br><span class=\"line\">\tUTF-16 : FF FE</span><br><span class=\"line\">\tUTF-16 big-endian: FE FF</span><br><span class=\"line\">\tUTF-32 little-endian: FF FE 00 00</span><br><span class=\"line\">\tUTF-32 big-endian: 00 00 FE FF</span><br><span class=\"line\">而如果不是以这个开头，那程序则会以ANSI，也就是系统默认编码读取。</span><br><span class=\"line\">如同样是字符“A”﹐在以下几种格式中的存储形式分别是﹕</span><br><span class=\"line\">\tUTF-16 big-endian : 00 41</span><br><span class=\"line\">\tUTF-16 little-endian : 41 00</span><br><span class=\"line\">\tUTF-32 big-endian : 00 00 00 41</span><br><span class=\"line\">\tUTF-32 little-endian : 41 00 00 00</span><br></pre></td></tr></table></figure>"},{"title":"rsa已知高位攻击","author":"人生若只如初见","date":"2020-05-27T03:54:00.000Z","_content":"# 已知高位攻击利用\n* 基础讲解：\n# 1. 格的基础\n* 格的基础概念：设v1,v2,….,vm线性无关，m维格L（v1,v2,….,vm）是指由向量v1,v2,….,vm生成的一个向量集，它的形式为——L（v1,v2,….,vm）=Σ ai * vi, (i=1,2,….,m ai∈Z)\n称{v1,v2,….,vm}为格L的一组基，且记Dim(L)=m; m、n分别为格L的维数和秩，当m=n时，称格L是满维的。\n# 2. 格基规约\n* 同一个格可以使用不同的基来表示，解决格上的问题时，即使使用同一种算法，如果选用不同的基，最后的运行时间和运行结果差别也是十分明显的。选择最优的一组基的过程就是格基规约，并称这样的一组基为格的一组规约基。常见的两种规约方法是Gauss规约和LLL规约。\n![](https://note.youdao.com/yws/api/personal/file/3E79235F98824E54871C18C516CCC71D?method=download&shareKey=719882fdcdade620567084447f055b72)\n* 其实综上所述，已知高位攻击就是将问题转换到格的数学问题中，转向求格的最短非零向量\n\n* 格基规约算法应用于密码分析的另一个重要方面就是线性同余结尾序列的重构。\n\n# 重点（伪随机序列的还原重构）\n## LLL-算法在密码分析中的应用(攻克线性同余结尾序列)\n* 众所周知, 线性同余是产生伪随机序列的一个极其简便流行的手段.但是, 若将原序列原样输出,而不做\n* 处理的话 ,即使是在不知道模数与乘子的情况下, 序列也能被轻易地重构(即还原出模数与乘子).于是, 为了增强抗攻击力,Knuth 提出了截尾序列生成器\n* 该生成器模型如下 :\n```\n输入初值 x 0 ,递归生成序列{x i }:x i+1 =ax i +b mod m , a , b , m ∈ Z ,输出序列{y i }:y i =[ x i /2 βv ] \n```\n* 其中v 为m 的比特数 , β =1 -α而α为输出y i 的比特数占原x i 的比特数之比例.\n* 由于对{x i }做了截尾处理, 使重构困难了.早期的计算机上曾广泛使用了类似的方法产生伪随机整数序列 .其方法是将 n 比特数平方后, 丢弃头尾各n/2 比特\n\n# J.S算法\n* 功能 　设得到 n +t 长的序列 ,记为 y 1 , y 2 , …, y t , y t+1 , …, y t+n ,其中 n ≈(2 αt log m)1/2,且原序列{xi}中(x 1 -x 0 , m)=1.J.S.算法能求出模数 m 和乘子a , 从而重构了原模型\n\n* 描述：\n```\n<1> 做Vi=[y(i+1) - yi ,  y(i+2)-y(i+1)....,y(i+t)-y(i+t)-1],  i=1,2,...,n.\n<2> 适当选取 k , 考虑 kV 1 , kV 2 , …, kV n 作输入 , 执行 KILL- 算法 , 得到 λ=(λ 1 , λ 2 , …, λ n ), 且∑λ i V i =0   (i=1，2,...,n), λ 较小.\n<3> 做多项式 P(x)=Σλi * X^i  (i=1,2,...,n)\n<4> 重复(1)～ (3)多次 ,得到多项式序列 p 1 , p 2 , …, p r .将p i 自然映射到Z^(n+1) 上.应用LLL-算法于p 1 , p 2 ,…, p r 上, 得到生成的格 L 的一组 LLL-约基 ,计算 d(L),令m =d(L),输出 m \n<5> 将 L 的基中次数 ≥2的向量乘以大整数 K (K ≥m 2^(n/2) ),再构成子格 L′, 执行 LLL-算法 ,找到 L′的一组 LLL-约基 .运用线性代数的知识,利用 LLL-约基, 找到首一多项式 A(x).令a =A(0), 输出 a .算法结束 .\n```\n* 注意：在（4）中多项式个数r≤（6α-1）㏒ m ㏒ ㏒ m,就可以满足要求了，算法中执行的LLL-算法其实是LLL-算法在输入任意r个向量(有可能线性相关)情况时的改进算法\n\n# coppersmith的一些定理:\n```\n<1>定理3.3 对任意的a > 0 ， 给定N = PQR及PQ的高位(1/5)(logN,2)比特，我们可以在多项式时间logN内得到N的分解式。这是三个因式的分解。也就是说我们现在是由理论依据的，已知高位是可以在一定时间内分解N。\n<2>已知p高位u多少位菜可以进行攻击呢？定理是在《Mathematics_of_Public_Key_Cryptography》这本数里面提到的，我们将我们上面得到的N的值带入上图的式子中。计算(1/根号2)*N\n```\n* 由上式得出：\n\n```\nif p.bit_length == 1024 ,p的高位需已知约576位\n\nif p.bit_length == 1024 ,p的高位需已知约288位\n```\n* 1.sage里面的small_roots能实现上述的给出已知的p高位进行分解N的函数方法，利用了LLL算法求解非线性低维度多项式方程小根的方法。\n\n* 2.Coppersmith证明了在已知p和q部分比特的情况下，若q和p的未知部分的上界X和Y满足XY <= N ^ (0.5)则Ｎ的多项式可以被分解。\n这里的0.5可以替换成其他的数，具体原因不详。\n\n* 链接：\n  [sage里small_roots的具体用法](https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots)\n\n# 已知高位攻击分为三种情况\n```\n<1>已知P的高位\n<2>已知d的高位\n<3>已知m的高位\n```\n## 已知P的高位\n\n* 知道p的高位为p的位数的约1/2时即可\n\n* 已知e,n爆破 1024的P，至少需要知道前576位二进制，即前144位16进制(特殊情况下，可能所得到的已知位数稍小于144位，需要爆破两三位，然后使用sage脚本)\n* 正好已知144位16进制的情况\n```\nn=\np4=            #已知P的高位\ne=\npbits=          #P原本的位数\n\nkbits=pbits - p4.nbits()\nprint p4.nbits()\np4 = p4 << kbits\nPR.<x> = PolynomialRing(Zmod(n))\nf = x + p4\nroots = f.small_roots(X=2^kbits,beta=0.4)\n# 经过以上一些函数处理后，n和p已经被转化为10进制\nif roots:\n    p= p4 + int(roots([0]))\n    print \"n\",n\n    print \"p\",p\n    print \"q\",n/p\n```\n* 已知142位16进制的情况\n```\nn=\np4=            #已知P的高位,最后面8位二进制，也就是两位十六进制要参与爆破，所以要用00补充\ne=\npbits=          #P原本的位数\n\n\nfor i in range(0,256):        # 要爆破的8位二进制数，为2**8==256，表示0~255\n    p4 =\n    p4 = p4 + int(hex(i),16)\n#print hex(p4)\n\n\nkbits=pbits - p4.nbits()\nprint p4.nbits()\np4 = p4 << kbits\nPR.<x> = PolynomialRing(Zmod(n))\nf = x + p4\nroots = f.small_roots(X=2^kbits,beta=0.4)\n# 经过以上一些函数处理后，n和p已经被转化为10进制\nif roots:\n    p= p4 + int(roots([0]))\n    print \"n\",n\n    print \"p\",p\n    print \"q\",n/p\n```\n## 已知d的高位\n\n* 如果知道d的低位，低位约为n的位数的1/4就可以恢复d。已知私钥的512位的低位 Partial Key Exposure Attack(部分私钥暴露攻击)\n```\ndef partial_p(p0, kbits, n):\n \n    PR.<x> = PolynomialRing(Zmod(n))\n \n    nbits = n.nbits()\n \n \n \n    f = 2^kbits*x + p0\n \n    f = f.monic()\n \n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root < 2^(nbits//2-kbits) with factor >= n^0.3\n \n    if roots:\n \n        x0 = roots[0]\n \n        p = gcd(2^kbits*x0 + p0, n)\n \n        return ZZ(p)\n \n \n \ndef find_p(d0, kbits, e, n):\n \n    X = var('X')\n \n \n \n    for k in xrange(1, e+1):\n \n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n \n        for x in results:\n \n            p0 = ZZ(x[0])\n \n            p = partial_p(p0, kbits, n)\n \n            if p:\n \n                return p\n \n \n \n \n \nif __name__ == '__main__':\n \n    n = 0xd463feb999c9292e25acd7f98d49a13413df2c4e74820136e739281bb394a73f2d1e6b53066932f50a73310360e5a5c622507d8662dadaef860b3266222129fd645eb74a0207af9bd79a9794f4bd21f32841ce9e1700b0b049cfadb760993fcfc7c65eca63904aa197df306cad8720b1b228484629cf967d808c13f6caef94a9\n \n    e = 3\n \n    d = 0x603d033f2ef6c759aec839f132a45215fc8a635b757f3951a731fe60bc6729b3bcf819b57abfcaba3a93e9edef766c0d499cad3f7adb306bcf1645cfb63400e3\n \n \n \n    beta = 0.5\n \n    epsilon = beta^2/7\n \n \n \n    nbits = n.nbits()\n \n    print \"nbits:%d:\"%(nbits)\n \n    #kbits = floor(nbits*(beta^2+epsilon))\n \n    kbits = nbits - d.nbits()-1\n \n    print \"kbits:%d\"%(kbits)\n \n    d0 = d & (2^kbits-1)\n \n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n \n \n \n    p = find_p(d0, kbits, e, n)\n \n    print \"found p: %d\" % p\n \n    q = n//p\n \n    print d\n \nprint inverse_mod(e, (p-1)*(q-1))\n```\n## 已知明文m的高位\n\n* 已知明文的高位，是Stereotyped messages攻击 或 Lattice based attacks \n```\nn = 0x2519834a6cc3bf25d078caefc5358e41c726a7a56270e425e21515d1b195b248b82f4189a0b621694586bb254e27010ee4376a849bb373e5e3f2eb622e3e7804d18ddb897463f3516b431e7fc65ec41c42edf736d5940c3139d1e374aed1fc3b70737125e1f540b541a9c671f4bf0ded798d727211116eb8b86cdd6a29aefcc7\n\ne = 3\nm = randrange(n)\nc = pow(m, e, n)\n\nbeta = 1\n \nepsilon = beta^2/7\n \nnbits = n.nbits()\n \nkbits = floor(nbits*(beta^2/e-epsilon))\n \n#mbar = m & (2^nbits-2^kbits)\n \nmbar = 0xb11ffc4ce423c77035280f1c575696327901daac8a83c057c453973ee5f4e508455648886441c0f3393fe4c922ef1c3a6249c12d21a000000000000000000\n \nc = 0x1f6f6a8e61f7b5ad8bef738f4376a96724192d8da1e3689dec7ce5d1df615e0910803317f9bafb6671ffe722e0292ce76cca399f2af1952dd31a61b37019da9cf27f82c3ecd4befc03c557efe1a5a29f9bb73c0239f62ed951955718ac0eaa3f60a4c415ef064ea33bbd61abe127c6fc808c0edb034c52c45bd20a219317fb75\n \nprint \"upper %d bits (of %d bits) is given\" % (nbits-kbits, nbits)\n \nPR.<x> = PolynomialRing(Zmod(n))\n \nf = (mbar + x)^e - c\n\nprint m\nx0 = f.small_roots(X=2^kbits, beta=1)[0]  # find root < 2^kbits with factor = n1\nprint mbar + x0\n```","source":"_drafts/rsa已知高位攻击1.md","raw":"title: rsa已知高位攻击\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-05-27 11:54:00\n---\n# 已知高位攻击利用\n* 基础讲解：\n# 1. 格的基础\n* 格的基础概念：设v1,v2,….,vm线性无关，m维格L（v1,v2,….,vm）是指由向量v1,v2,….,vm生成的一个向量集，它的形式为——L（v1,v2,….,vm）=Σ ai * vi, (i=1,2,….,m ai∈Z)\n称{v1,v2,….,vm}为格L的一组基，且记Dim(L)=m; m、n分别为格L的维数和秩，当m=n时，称格L是满维的。\n# 2. 格基规约\n* 同一个格可以使用不同的基来表示，解决格上的问题时，即使使用同一种算法，如果选用不同的基，最后的运行时间和运行结果差别也是十分明显的。选择最优的一组基的过程就是格基规约，并称这样的一组基为格的一组规约基。常见的两种规约方法是Gauss规约和LLL规约。\n![](https://note.youdao.com/yws/api/personal/file/3E79235F98824E54871C18C516CCC71D?method=download&shareKey=719882fdcdade620567084447f055b72)\n* 其实综上所述，已知高位攻击就是将问题转换到格的数学问题中，转向求格的最短非零向量\n\n* 格基规约算法应用于密码分析的另一个重要方面就是线性同余结尾序列的重构。\n\n# 重点（伪随机序列的还原重构）\n## LLL-算法在密码分析中的应用(攻克线性同余结尾序列)\n* 众所周知, 线性同余是产生伪随机序列的一个极其简便流行的手段.但是, 若将原序列原样输出,而不做\n* 处理的话 ,即使是在不知道模数与乘子的情况下, 序列也能被轻易地重构(即还原出模数与乘子).于是, 为了增强抗攻击力,Knuth 提出了截尾序列生成器\n* 该生成器模型如下 :\n```\n输入初值 x 0 ,递归生成序列{x i }:x i+1 =ax i +b mod m , a , b , m ∈ Z ,输出序列{y i }:y i =[ x i /2 βv ] \n```\n* 其中v 为m 的比特数 , β =1 -α而α为输出y i 的比特数占原x i 的比特数之比例.\n* 由于对{x i }做了截尾处理, 使重构困难了.早期的计算机上曾广泛使用了类似的方法产生伪随机整数序列 .其方法是将 n 比特数平方后, 丢弃头尾各n/2 比特\n\n# J.S算法\n* 功能 　设得到 n +t 长的序列 ,记为 y 1 , y 2 , …, y t , y t+1 , …, y t+n ,其中 n ≈(2 αt log m)1/2,且原序列{xi}中(x 1 -x 0 , m)=1.J.S.算法能求出模数 m 和乘子a , 从而重构了原模型\n\n* 描述：\n```\n<1> 做Vi=[y(i+1) - yi ,  y(i+2)-y(i+1)....,y(i+t)-y(i+t)-1],  i=1,2,...,n.\n<2> 适当选取 k , 考虑 kV 1 , kV 2 , …, kV n 作输入 , 执行 KILL- 算法 , 得到 λ=(λ 1 , λ 2 , …, λ n ), 且∑λ i V i =0   (i=1，2,...,n), λ 较小.\n<3> 做多项式 P(x)=Σλi * X^i  (i=1,2,...,n)\n<4> 重复(1)～ (3)多次 ,得到多项式序列 p 1 , p 2 , …, p r .将p i 自然映射到Z^(n+1) 上.应用LLL-算法于p 1 , p 2 ,…, p r 上, 得到生成的格 L 的一组 LLL-约基 ,计算 d(L),令m =d(L),输出 m \n<5> 将 L 的基中次数 ≥2的向量乘以大整数 K (K ≥m 2^(n/2) ),再构成子格 L′, 执行 LLL-算法 ,找到 L′的一组 LLL-约基 .运用线性代数的知识,利用 LLL-约基, 找到首一多项式 A(x).令a =A(0), 输出 a .算法结束 .\n```\n* 注意：在（4）中多项式个数r≤（6α-1）㏒ m ㏒ ㏒ m,就可以满足要求了，算法中执行的LLL-算法其实是LLL-算法在输入任意r个向量(有可能线性相关)情况时的改进算法\n\n# coppersmith的一些定理:\n```\n<1>定理3.3 对任意的a > 0 ， 给定N = PQR及PQ的高位(1/5)(logN,2)比特，我们可以在多项式时间logN内得到N的分解式。这是三个因式的分解。也就是说我们现在是由理论依据的，已知高位是可以在一定时间内分解N。\n<2>已知p高位u多少位菜可以进行攻击呢？定理是在《Mathematics_of_Public_Key_Cryptography》这本数里面提到的，我们将我们上面得到的N的值带入上图的式子中。计算(1/根号2)*N\n```\n* 由上式得出：\n\n```\nif p.bit_length == 1024 ,p的高位需已知约576位\n\nif p.bit_length == 1024 ,p的高位需已知约288位\n```\n* 1.sage里面的small_roots能实现上述的给出已知的p高位进行分解N的函数方法，利用了LLL算法求解非线性低维度多项式方程小根的方法。\n\n* 2.Coppersmith证明了在已知p和q部分比特的情况下，若q和p的未知部分的上界X和Y满足XY <= N ^ (0.5)则Ｎ的多项式可以被分解。\n这里的0.5可以替换成其他的数，具体原因不详。\n\n* 链接：\n  [sage里small_roots的具体用法](https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots)\n\n# 已知高位攻击分为三种情况\n```\n<1>已知P的高位\n<2>已知d的高位\n<3>已知m的高位\n```\n## 已知P的高位\n\n* 知道p的高位为p的位数的约1/2时即可\n\n* 已知e,n爆破 1024的P，至少需要知道前576位二进制，即前144位16进制(特殊情况下，可能所得到的已知位数稍小于144位，需要爆破两三位，然后使用sage脚本)\n* 正好已知144位16进制的情况\n```\nn=\np4=            #已知P的高位\ne=\npbits=          #P原本的位数\n\nkbits=pbits - p4.nbits()\nprint p4.nbits()\np4 = p4 << kbits\nPR.<x> = PolynomialRing(Zmod(n))\nf = x + p4\nroots = f.small_roots(X=2^kbits,beta=0.4)\n# 经过以上一些函数处理后，n和p已经被转化为10进制\nif roots:\n    p= p4 + int(roots([0]))\n    print \"n\",n\n    print \"p\",p\n    print \"q\",n/p\n```\n* 已知142位16进制的情况\n```\nn=\np4=            #已知P的高位,最后面8位二进制，也就是两位十六进制要参与爆破，所以要用00补充\ne=\npbits=          #P原本的位数\n\n\nfor i in range(0,256):        # 要爆破的8位二进制数，为2**8==256，表示0~255\n    p4 =\n    p4 = p4 + int(hex(i),16)\n#print hex(p4)\n\n\nkbits=pbits - p4.nbits()\nprint p4.nbits()\np4 = p4 << kbits\nPR.<x> = PolynomialRing(Zmod(n))\nf = x + p4\nroots = f.small_roots(X=2^kbits,beta=0.4)\n# 经过以上一些函数处理后，n和p已经被转化为10进制\nif roots:\n    p= p4 + int(roots([0]))\n    print \"n\",n\n    print \"p\",p\n    print \"q\",n/p\n```\n## 已知d的高位\n\n* 如果知道d的低位，低位约为n的位数的1/4就可以恢复d。已知私钥的512位的低位 Partial Key Exposure Attack(部分私钥暴露攻击)\n```\ndef partial_p(p0, kbits, n):\n \n    PR.<x> = PolynomialRing(Zmod(n))\n \n    nbits = n.nbits()\n \n \n \n    f = 2^kbits*x + p0\n \n    f = f.monic()\n \n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root < 2^(nbits//2-kbits) with factor >= n^0.3\n \n    if roots:\n \n        x0 = roots[0]\n \n        p = gcd(2^kbits*x0 + p0, n)\n \n        return ZZ(p)\n \n \n \ndef find_p(d0, kbits, e, n):\n \n    X = var('X')\n \n \n \n    for k in xrange(1, e+1):\n \n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n \n        for x in results:\n \n            p0 = ZZ(x[0])\n \n            p = partial_p(p0, kbits, n)\n \n            if p:\n \n                return p\n \n \n \n \n \nif __name__ == '__main__':\n \n    n = 0xd463feb999c9292e25acd7f98d49a13413df2c4e74820136e739281bb394a73f2d1e6b53066932f50a73310360e5a5c622507d8662dadaef860b3266222129fd645eb74a0207af9bd79a9794f4bd21f32841ce9e1700b0b049cfadb760993fcfc7c65eca63904aa197df306cad8720b1b228484629cf967d808c13f6caef94a9\n \n    e = 3\n \n    d = 0x603d033f2ef6c759aec839f132a45215fc8a635b757f3951a731fe60bc6729b3bcf819b57abfcaba3a93e9edef766c0d499cad3f7adb306bcf1645cfb63400e3\n \n \n \n    beta = 0.5\n \n    epsilon = beta^2/7\n \n \n \n    nbits = n.nbits()\n \n    print \"nbits:%d:\"%(nbits)\n \n    #kbits = floor(nbits*(beta^2+epsilon))\n \n    kbits = nbits - d.nbits()-1\n \n    print \"kbits:%d\"%(kbits)\n \n    d0 = d & (2^kbits-1)\n \n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n \n \n \n    p = find_p(d0, kbits, e, n)\n \n    print \"found p: %d\" % p\n \n    q = n//p\n \n    print d\n \nprint inverse_mod(e, (p-1)*(q-1))\n```\n## 已知明文m的高位\n\n* 已知明文的高位，是Stereotyped messages攻击 或 Lattice based attacks \n```\nn = 0x2519834a6cc3bf25d078caefc5358e41c726a7a56270e425e21515d1b195b248b82f4189a0b621694586bb254e27010ee4376a849bb373e5e3f2eb622e3e7804d18ddb897463f3516b431e7fc65ec41c42edf736d5940c3139d1e374aed1fc3b70737125e1f540b541a9c671f4bf0ded798d727211116eb8b86cdd6a29aefcc7\n\ne = 3\nm = randrange(n)\nc = pow(m, e, n)\n\nbeta = 1\n \nepsilon = beta^2/7\n \nnbits = n.nbits()\n \nkbits = floor(nbits*(beta^2/e-epsilon))\n \n#mbar = m & (2^nbits-2^kbits)\n \nmbar = 0xb11ffc4ce423c77035280f1c575696327901daac8a83c057c453973ee5f4e508455648886441c0f3393fe4c922ef1c3a6249c12d21a000000000000000000\n \nc = 0x1f6f6a8e61f7b5ad8bef738f4376a96724192d8da1e3689dec7ce5d1df615e0910803317f9bafb6671ffe722e0292ce76cca399f2af1952dd31a61b37019da9cf27f82c3ecd4befc03c557efe1a5a29f9bb73c0239f62ed951955718ac0eaa3f60a4c415ef064ea33bbd61abe127c6fc808c0edb034c52c45bd20a219317fb75\n \nprint \"upper %d bits (of %d bits) is given\" % (nbits-kbits, nbits)\n \nPR.<x> = PolynomialRing(Zmod(n))\n \nf = (mbar + x)^e - c\n\nprint m\nx0 = f.small_roots(X=2^kbits, beta=1)[0]  # find root < 2^kbits with factor = n1\nprint mbar + x0\n```","slug":"rsa已知高位攻击1","published":0,"updated":"2020-05-27T06:38:58.062Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17s000nvcu9b0f534v6","content":"<h1 id=\"已知高位攻击利用\"><a href=\"#已知高位攻击利用\" class=\"headerlink\" title=\"已知高位攻击利用\"></a>已知高位攻击利用</h1><ul>\n<li><p>基础讲解：</p>\n<h1 id=\"1-格的基础\"><a href=\"#1-格的基础\" class=\"headerlink\" title=\"1. 格的基础\"></a>1. 格的基础</h1></li>\n<li><p>格的基础概念：设v1,v2,….,vm线性无关，m维格L（v1,v2,….,vm）是指由向量v1,v2,….,vm生成的一个向量集，它的形式为——L（v1,v2,….,vm）=Σ ai * vi, (i=1,2,….,m ai∈Z)<br>称{v1,v2,….,vm}为格L的一组基，且记Dim(L)=m; m、n分别为格L的维数和秩，当m=n时，称格L是满维的。</p>\n<h1 id=\"2-格基规约\"><a href=\"#2-格基规约\" class=\"headerlink\" title=\"2. 格基规约\"></a>2. 格基规约</h1></li>\n<li><p>同一个格可以使用不同的基来表示，解决格上的问题时，即使使用同一种算法，如果选用不同的基，最后的运行时间和运行结果差别也是十分明显的。选择最优的一组基的过程就是格基规约，并称这样的一组基为格的一组规约基。常见的两种规约方法是Gauss规约和LLL规约。<br><img src=\"https://note.youdao.com/yws/api/personal/file/3E79235F98824E54871C18C516CCC71D?method=download&shareKey=719882fdcdade620567084447f055b72\" alt=\"\"></p>\n</li>\n<li><p>其实综上所述，已知高位攻击就是将问题转换到格的数学问题中，转向求格的最短非零向量</p>\n</li>\n<li><p>格基规约算法应用于密码分析的另一个重要方面就是线性同余结尾序列的重构。</p>\n</li>\n</ul>\n<h1 id=\"重点（伪随机序列的还原重构）\"><a href=\"#重点（伪随机序列的还原重构）\" class=\"headerlink\" title=\"重点（伪随机序列的还原重构）\"></a>重点（伪随机序列的还原重构）</h1><h2 id=\"LLL-算法在密码分析中的应用-攻克线性同余结尾序列\"><a href=\"#LLL-算法在密码分析中的应用-攻克线性同余结尾序列\" class=\"headerlink\" title=\"LLL-算法在密码分析中的应用(攻克线性同余结尾序列)\"></a>LLL-算法在密码分析中的应用(攻克线性同余结尾序列)</h2><ul>\n<li>众所周知, 线性同余是产生伪随机序列的一个极其简便流行的手段.但是, 若将原序列原样输出,而不做</li>\n<li>处理的话 ,即使是在不知道模数与乘子的情况下, 序列也能被轻易地重构(即还原出模数与乘子).于是, 为了增强抗攻击力,Knuth 提出了截尾序列生成器</li>\n<li>该生成器模型如下 :<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入初值 x 0 ,递归生成序列&#123;x i &#125;:x i+1 &#x3D;ax i +b mod m , a , b , m ∈ Z ,输出序列&#123;y i &#125;:y i &#x3D;[ x i &#x2F;2 βv ]</span><br></pre></td></tr></table></figure></li>\n<li>其中v 为m 的比特数 , β =1 -α而α为输出y i 的比特数占原x i 的比特数之比例.</li>\n<li>由于对{x i }做了截尾处理, 使重构困难了.早期的计算机上曾广泛使用了类似的方法产生伪随机整数序列 .其方法是将 n 比特数平方后, 丢弃头尾各n/2 比特</li>\n</ul>\n<h1 id=\"J-S算法\"><a href=\"#J-S算法\" class=\"headerlink\" title=\"J.S算法\"></a>J.S算法</h1><ul>\n<li><p>功能 　设得到 n +t 长的序列 ,记为 y 1 , y 2 , …, y t , y t+1 , …, y t+n ,其中 n ≈(2 αt log m)1/2,且原序列{xi}中(x 1 -x 0 , m)=1.J.S.算法能求出模数 m 和乘子a , 从而重构了原模型</p>\n</li>\n<li><p>描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 做Vi&#x3D;[y(i+1) - yi ,  y(i+2)-y(i+1)....,y(i+t)-y(i+t)-1],  i&#x3D;1,2,...,n.</span><br><span class=\"line\">&lt;2&gt; 适当选取 k , 考虑 kV 1 , kV 2 , …, kV n 作输入 , 执行 KILL- 算法 , 得到 λ&#x3D;(λ 1 , λ 2 , …, λ n ), 且∑λ i V i &#x3D;0   (i&#x3D;1，2,...,n), λ 较小.</span><br><span class=\"line\">&lt;3&gt; 做多项式 P(x)&#x3D;Σλi * X^i  (i&#x3D;1,2,...,n)</span><br><span class=\"line\">&lt;4&gt; 重复(1)～ (3)多次 ,得到多项式序列 p 1 , p 2 , …, p r .将p i 自然映射到Z^(n+1) 上.应用LLL-算法于p 1 , p 2 ,…, p r 上, 得到生成的格 L 的一组 LLL-约基 ,计算 d(L),令m &#x3D;d(L),输出 m </span><br><span class=\"line\">&lt;5&gt; 将 L 的基中次数 ≥2的向量乘以大整数 K (K ≥m 2^(n&#x2F;2) ),再构成子格 L′, 执行 LLL-算法 ,找到 L′的一组 LLL-约基 .运用线性代数的知识,利用 LLL-约基, 找到首一多项式 A(x).令a &#x3D;A(0), 输出 a .算法结束 .</span><br></pre></td></tr></table></figure></li>\n<li><p>注意：在（4）中多项式个数r≤（6α-1）㏒ m ㏒ ㏒ m,就可以满足要求了，算法中执行的LLL-算法其实是LLL-算法在输入任意r个向量(有可能线性相关)情况时的改进算法</p>\n</li>\n</ul>\n<h1 id=\"coppersmith的一些定理\"><a href=\"#coppersmith的一些定理\" class=\"headerlink\" title=\"coppersmith的一些定理:\"></a>coppersmith的一些定理:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt;定理3.3 对任意的a &gt; 0 ， 给定N &#x3D; PQR及PQ的高位(1&#x2F;5)(logN,2)比特，我们可以在多项式时间logN内得到N的分解式。这是三个因式的分解。也就是说我们现在是由理论依据的，已知高位是可以在一定时间内分解N。</span><br><span class=\"line\">&lt;2&gt;已知p高位u多少位菜可以进行攻击呢？定理是在《Mathematics_of_Public_Key_Cryptography》这本数里面提到的，我们将我们上面得到的N的值带入上图的式子中。计算(1&#x2F;根号2)*N</span><br></pre></td></tr></table></figure>\n<ul>\n<li>由上式得出：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if p.bit_length &#x3D;&#x3D; 1024 ,p的高位需已知约576位</span><br><span class=\"line\"></span><br><span class=\"line\">if p.bit_length &#x3D;&#x3D; 1024 ,p的高位需已知约288位</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>1.sage里面的small_roots能实现上述的给出已知的p高位进行分解N的函数方法，利用了LLL算法求解非线性低维度多项式方程小根的方法。</p>\n</li>\n<li><p>2.Coppersmith证明了在已知p和q部分比特的情况下，若q和p的未知部分的上界X和Y满足XY &lt;= N ^ (0.5)则Ｎ的多项式可以被分解。<br>这里的0.5可以替换成其他的数，具体原因不详。</p>\n</li>\n<li><p>链接：<br><a href=\"https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots\" target=\"_blank\" rel=\"noopener\">sage里small_roots的具体用法</a></p>\n</li>\n</ul>\n<h1 id=\"已知高位攻击分为三种情况\"><a href=\"#已知高位攻击分为三种情况\" class=\"headerlink\" title=\"已知高位攻击分为三种情况\"></a>已知高位攻击分为三种情况</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt;已知P的高位</span><br><span class=\"line\">&lt;2&gt;已知d的高位</span><br><span class=\"line\">&lt;3&gt;已知m的高位</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知P的高位\"><a href=\"#已知P的高位\" class=\"headerlink\" title=\"已知P的高位\"></a>已知P的高位</h2><ul>\n<li><p>知道p的高位为p的位数的约1/2时即可</p>\n</li>\n<li><p>已知e,n爆破 1024的P，至少需要知道前576位二进制，即前144位16进制(特殊情况下，可能所得到的已知位数稍小于144位，需要爆破两三位，然后使用sage脚本)</p>\n</li>\n<li><p>正好已知144位16进制的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;</span><br><span class=\"line\">p4&#x3D;            #已知P的高位</span><br><span class=\"line\">e&#x3D;</span><br><span class=\"line\">pbits&#x3D;          #P原本的位数</span><br><span class=\"line\"></span><br><span class=\"line\">kbits&#x3D;pbits - p4.nbits()</span><br><span class=\"line\">print p4.nbits()</span><br><span class=\"line\">p4 &#x3D; p4 &lt;&lt; kbits</span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\">f &#x3D; x + p4</span><br><span class=\"line\">roots &#x3D; f.small_roots(X&#x3D;2^kbits,beta&#x3D;0.4)</span><br><span class=\"line\"># 经过以上一些函数处理后，n和p已经被转化为10进制</span><br><span class=\"line\">if roots:</span><br><span class=\"line\">    p&#x3D; p4 + int(roots([0]))</span><br><span class=\"line\">    print &quot;n&quot;,n</span><br><span class=\"line\">    print &quot;p&quot;,p</span><br><span class=\"line\">    print &quot;q&quot;,n&#x2F;p</span><br></pre></td></tr></table></figure></li>\n<li><p>已知142位16进制的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;</span><br><span class=\"line\">p4&#x3D;            #已知P的高位,最后面8位二进制，也就是两位十六进制要参与爆破，所以要用00补充</span><br><span class=\"line\">e&#x3D;</span><br><span class=\"line\">pbits&#x3D;          #P原本的位数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(0,256):        # 要爆破的8位二进制数，为2**8&#x3D;&#x3D;256，表示0~255</span><br><span class=\"line\">    p4 &#x3D;</span><br><span class=\"line\">    p4 &#x3D; p4 + int(hex(i),16)</span><br><span class=\"line\">#print hex(p4)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">kbits&#x3D;pbits - p4.nbits()</span><br><span class=\"line\">print p4.nbits()</span><br><span class=\"line\">p4 &#x3D; p4 &lt;&lt; kbits</span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\">f &#x3D; x + p4</span><br><span class=\"line\">roots &#x3D; f.small_roots(X&#x3D;2^kbits,beta&#x3D;0.4)</span><br><span class=\"line\"># 经过以上一些函数处理后，n和p已经被转化为10进制</span><br><span class=\"line\">if roots:</span><br><span class=\"line\">    p&#x3D; p4 + int(roots([0]))</span><br><span class=\"line\">    print &quot;n&quot;,n</span><br><span class=\"line\">    print &quot;p&quot;,p</span><br><span class=\"line\">    print &quot;q&quot;,n&#x2F;p</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知d的高位\"><a href=\"#已知d的高位\" class=\"headerlink\" title=\"已知d的高位\"></a>已知d的高位</h2></li>\n<li><p>如果知道d的低位，低位约为n的位数的1/4就可以恢复d。已知私钥的512位的低位 Partial Key Exposure Attack(部分私钥暴露攻击)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def partial_p(p0, kbits, n):</span><br><span class=\"line\"> </span><br><span class=\"line\">    PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\"> </span><br><span class=\"line\">    nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    f &#x3D; 2^kbits*x + p0</span><br><span class=\"line\"> </span><br><span class=\"line\">    f &#x3D; f.monic()</span><br><span class=\"line\"> </span><br><span class=\"line\">    roots &#x3D; f.small_roots(X&#x3D;2^(nbits&#x2F;&#x2F;2-kbits), beta&#x3D;0.3)  # find root &lt; 2^(nbits&#x2F;&#x2F;2-kbits) with factor &gt;&#x3D; n^0.3</span><br><span class=\"line\"> </span><br><span class=\"line\">    if roots:</span><br><span class=\"line\"> </span><br><span class=\"line\">        x0 &#x3D; roots[0]</span><br><span class=\"line\"> </span><br><span class=\"line\">        p &#x3D; gcd(2^kbits*x0 + p0, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">        return ZZ(p)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">def find_p(d0, kbits, e, n):</span><br><span class=\"line\"> </span><br><span class=\"line\">    X &#x3D; var(&#39;X&#39;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    for k in xrange(1, e+1):</span><br><span class=\"line\"> </span><br><span class=\"line\">        results &#x3D; solve_mod([e*d0*X - k*X*(n-X+1) + k*n &#x3D;&#x3D; X], 2^kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">        for x in results:</span><br><span class=\"line\"> </span><br><span class=\"line\">            p0 &#x3D; ZZ(x[0])</span><br><span class=\"line\"> </span><br><span class=\"line\">            p &#x3D; partial_p(p0, kbits, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">            if p:</span><br><span class=\"line\"> </span><br><span class=\"line\">                return p</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\"> </span><br><span class=\"line\">    n &#x3D; 0xd463feb999c9292e25acd7f98d49a13413df2c4e74820136e739281bb394a73f2d1e6b53066932f50a73310360e5a5c622507d8662dadaef860b3266222129fd645eb74a0207af9bd79a9794f4bd21f32841ce9e1700b0b049cfadb760993fcfc7c65eca63904aa197df306cad8720b1b228484629cf967d808c13f6caef94a9</span><br><span class=\"line\"> </span><br><span class=\"line\">    e &#x3D; 3</span><br><span class=\"line\"> </span><br><span class=\"line\">    d &#x3D; 0x603d033f2ef6c759aec839f132a45215fc8a635b757f3951a731fe60bc6729b3bcf819b57abfcaba3a93e9edef766c0d499cad3f7adb306bcf1645cfb63400e3</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    beta &#x3D; 0.5</span><br><span class=\"line\"> </span><br><span class=\"line\">    epsilon &#x3D; beta^2&#x2F;7</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;nbits:%d:&quot;%(nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">    #kbits &#x3D; floor(nbits*(beta^2+epsilon))</span><br><span class=\"line\"> </span><br><span class=\"line\">    kbits &#x3D; nbits - d.nbits()-1</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;kbits:%d&quot;%(kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">    d0 &#x3D; d &amp; (2^kbits-1)</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;lower %d bits (of %d bits) is given&quot; % (kbits, nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    p &#x3D; find_p(d0, kbits, e, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;found p: %d&quot; % p</span><br><span class=\"line\"> </span><br><span class=\"line\">    q &#x3D; n&#x2F;&#x2F;p</span><br><span class=\"line\"> </span><br><span class=\"line\">    print d</span><br><span class=\"line\"> </span><br><span class=\"line\">print inverse_mod(e, (p-1)*(q-1))</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知明文m的高位\"><a href=\"#已知明文m的高位\" class=\"headerlink\" title=\"已知明文m的高位\"></a>已知明文m的高位</h2></li>\n<li><p>已知明文的高位，是Stereotyped messages攻击 或 Lattice based attacks </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n &#x3D; 0x2519834a6cc3bf25d078caefc5358e41c726a7a56270e425e21515d1b195b248b82f4189a0b621694586bb254e27010ee4376a849bb373e5e3f2eb622e3e7804d18ddb897463f3516b431e7fc65ec41c42edf736d5940c3139d1e374aed1fc3b70737125e1f540b541a9c671f4bf0ded798d727211116eb8b86cdd6a29aefcc7</span><br><span class=\"line\"></span><br><span class=\"line\">e &#x3D; 3</span><br><span class=\"line\">m &#x3D; randrange(n)</span><br><span class=\"line\">c &#x3D; pow(m, e, n)</span><br><span class=\"line\"></span><br><span class=\"line\">beta &#x3D; 1</span><br><span class=\"line\"> </span><br><span class=\"line\">epsilon &#x3D; beta^2&#x2F;7</span><br><span class=\"line\"> </span><br><span class=\"line\">nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\">kbits &#x3D; floor(nbits*(beta^2&#x2F;e-epsilon))</span><br><span class=\"line\"> </span><br><span class=\"line\">#mbar &#x3D; m &amp; (2^nbits-2^kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">mbar &#x3D; 0xb11ffc4ce423c77035280f1c575696327901daac8a83c057c453973ee5f4e508455648886441c0f3393fe4c922ef1c3a6249c12d21a000000000000000000</span><br><span class=\"line\"> </span><br><span class=\"line\">c &#x3D; 0x1f6f6a8e61f7b5ad8bef738f4376a96724192d8da1e3689dec7ce5d1df615e0910803317f9bafb6671ffe722e0292ce76cca399f2af1952dd31a61b37019da9cf27f82c3ecd4befc03c557efe1a5a29f9bb73c0239f62ed951955718ac0eaa3f60a4c415ef064ea33bbd61abe127c6fc808c0edb034c52c45bd20a219317fb75</span><br><span class=\"line\"> </span><br><span class=\"line\">print &quot;upper %d bits (of %d bits) is given&quot; % (nbits-kbits, nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\"> </span><br><span class=\"line\">f &#x3D; (mbar + x)^e - c</span><br><span class=\"line\"></span><br><span class=\"line\">print m</span><br><span class=\"line\">x0 &#x3D; f.small_roots(X&#x3D;2^kbits, beta&#x3D;1)[0]  # find root &lt; 2^kbits with factor &#x3D; n1</span><br><span class=\"line\">print mbar + x0</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"已知高位攻击利用\"><a href=\"#已知高位攻击利用\" class=\"headerlink\" title=\"已知高位攻击利用\"></a>已知高位攻击利用</h1><ul>\n<li><p>基础讲解：</p>\n<h1 id=\"1-格的基础\"><a href=\"#1-格的基础\" class=\"headerlink\" title=\"1. 格的基础\"></a>1. 格的基础</h1></li>\n<li><p>格的基础概念：设v1,v2,….,vm线性无关，m维格L（v1,v2,….,vm）是指由向量v1,v2,….,vm生成的一个向量集，它的形式为——L（v1,v2,….,vm）=Σ ai * vi, (i=1,2,….,m ai∈Z)<br>称{v1,v2,….,vm}为格L的一组基，且记Dim(L)=m; m、n分别为格L的维数和秩，当m=n时，称格L是满维的。</p>\n<h1 id=\"2-格基规约\"><a href=\"#2-格基规约\" class=\"headerlink\" title=\"2. 格基规约\"></a>2. 格基规约</h1></li>\n<li><p>同一个格可以使用不同的基来表示，解决格上的问题时，即使使用同一种算法，如果选用不同的基，最后的运行时间和运行结果差别也是十分明显的。选择最优的一组基的过程就是格基规约，并称这样的一组基为格的一组规约基。常见的两种规约方法是Gauss规约和LLL规约。<br><img src=\"https://note.youdao.com/yws/api/personal/file/3E79235F98824E54871C18C516CCC71D?method=download&shareKey=719882fdcdade620567084447f055b72\" alt=\"\"></p>\n</li>\n<li><p>其实综上所述，已知高位攻击就是将问题转换到格的数学问题中，转向求格的最短非零向量</p>\n</li>\n<li><p>格基规约算法应用于密码分析的另一个重要方面就是线性同余结尾序列的重构。</p>\n</li>\n</ul>\n<h1 id=\"重点（伪随机序列的还原重构）\"><a href=\"#重点（伪随机序列的还原重构）\" class=\"headerlink\" title=\"重点（伪随机序列的还原重构）\"></a>重点（伪随机序列的还原重构）</h1><h2 id=\"LLL-算法在密码分析中的应用-攻克线性同余结尾序列\"><a href=\"#LLL-算法在密码分析中的应用-攻克线性同余结尾序列\" class=\"headerlink\" title=\"LLL-算法在密码分析中的应用(攻克线性同余结尾序列)\"></a>LLL-算法在密码分析中的应用(攻克线性同余结尾序列)</h2><ul>\n<li>众所周知, 线性同余是产生伪随机序列的一个极其简便流行的手段.但是, 若将原序列原样输出,而不做</li>\n<li>处理的话 ,即使是在不知道模数与乘子的情况下, 序列也能被轻易地重构(即还原出模数与乘子).于是, 为了增强抗攻击力,Knuth 提出了截尾序列生成器</li>\n<li>该生成器模型如下 :<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入初值 x 0 ,递归生成序列&#123;x i &#125;:x i+1 &#x3D;ax i +b mod m , a , b , m ∈ Z ,输出序列&#123;y i &#125;:y i &#x3D;[ x i &#x2F;2 βv ]</span><br></pre></td></tr></table></figure></li>\n<li>其中v 为m 的比特数 , β =1 -α而α为输出y i 的比特数占原x i 的比特数之比例.</li>\n<li>由于对{x i }做了截尾处理, 使重构困难了.早期的计算机上曾广泛使用了类似的方法产生伪随机整数序列 .其方法是将 n 比特数平方后, 丢弃头尾各n/2 比特</li>\n</ul>\n<h1 id=\"J-S算法\"><a href=\"#J-S算法\" class=\"headerlink\" title=\"J.S算法\"></a>J.S算法</h1><ul>\n<li><p>功能 　设得到 n +t 长的序列 ,记为 y 1 , y 2 , …, y t , y t+1 , …, y t+n ,其中 n ≈(2 αt log m)1/2,且原序列{xi}中(x 1 -x 0 , m)=1.J.S.算法能求出模数 m 和乘子a , 从而重构了原模型</p>\n</li>\n<li><p>描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 做Vi&#x3D;[y(i+1) - yi ,  y(i+2)-y(i+1)....,y(i+t)-y(i+t)-1],  i&#x3D;1,2,...,n.</span><br><span class=\"line\">&lt;2&gt; 适当选取 k , 考虑 kV 1 , kV 2 , …, kV n 作输入 , 执行 KILL- 算法 , 得到 λ&#x3D;(λ 1 , λ 2 , …, λ n ), 且∑λ i V i &#x3D;0   (i&#x3D;1，2,...,n), λ 较小.</span><br><span class=\"line\">&lt;3&gt; 做多项式 P(x)&#x3D;Σλi * X^i  (i&#x3D;1,2,...,n)</span><br><span class=\"line\">&lt;4&gt; 重复(1)～ (3)多次 ,得到多项式序列 p 1 , p 2 , …, p r .将p i 自然映射到Z^(n+1) 上.应用LLL-算法于p 1 , p 2 ,…, p r 上, 得到生成的格 L 的一组 LLL-约基 ,计算 d(L),令m &#x3D;d(L),输出 m </span><br><span class=\"line\">&lt;5&gt; 将 L 的基中次数 ≥2的向量乘以大整数 K (K ≥m 2^(n&#x2F;2) ),再构成子格 L′, 执行 LLL-算法 ,找到 L′的一组 LLL-约基 .运用线性代数的知识,利用 LLL-约基, 找到首一多项式 A(x).令a &#x3D;A(0), 输出 a .算法结束 .</span><br></pre></td></tr></table></figure></li>\n<li><p>注意：在（4）中多项式个数r≤（6α-1）㏒ m ㏒ ㏒ m,就可以满足要求了，算法中执行的LLL-算法其实是LLL-算法在输入任意r个向量(有可能线性相关)情况时的改进算法</p>\n</li>\n</ul>\n<h1 id=\"coppersmith的一些定理\"><a href=\"#coppersmith的一些定理\" class=\"headerlink\" title=\"coppersmith的一些定理:\"></a>coppersmith的一些定理:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt;定理3.3 对任意的a &gt; 0 ， 给定N &#x3D; PQR及PQ的高位(1&#x2F;5)(logN,2)比特，我们可以在多项式时间logN内得到N的分解式。这是三个因式的分解。也就是说我们现在是由理论依据的，已知高位是可以在一定时间内分解N。</span><br><span class=\"line\">&lt;2&gt;已知p高位u多少位菜可以进行攻击呢？定理是在《Mathematics_of_Public_Key_Cryptography》这本数里面提到的，我们将我们上面得到的N的值带入上图的式子中。计算(1&#x2F;根号2)*N</span><br></pre></td></tr></table></figure>\n<ul>\n<li>由上式得出：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if p.bit_length &#x3D;&#x3D; 1024 ,p的高位需已知约576位</span><br><span class=\"line\"></span><br><span class=\"line\">if p.bit_length &#x3D;&#x3D; 1024 ,p的高位需已知约288位</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>1.sage里面的small_roots能实现上述的给出已知的p高位进行分解N的函数方法，利用了LLL算法求解非线性低维度多项式方程小根的方法。</p>\n</li>\n<li><p>2.Coppersmith证明了在已知p和q部分比特的情况下，若q和p的未知部分的上界X和Y满足XY &lt;= N ^ (0.5)则Ｎ的多项式可以被分解。<br>这里的0.5可以替换成其他的数，具体原因不详。</p>\n</li>\n<li><p>链接：<br><a href=\"https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots\" target=\"_blank\" rel=\"noopener\">sage里small_roots的具体用法</a></p>\n</li>\n</ul>\n<h1 id=\"已知高位攻击分为三种情况\"><a href=\"#已知高位攻击分为三种情况\" class=\"headerlink\" title=\"已知高位攻击分为三种情况\"></a>已知高位攻击分为三种情况</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt;已知P的高位</span><br><span class=\"line\">&lt;2&gt;已知d的高位</span><br><span class=\"line\">&lt;3&gt;已知m的高位</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知P的高位\"><a href=\"#已知P的高位\" class=\"headerlink\" title=\"已知P的高位\"></a>已知P的高位</h2><ul>\n<li><p>知道p的高位为p的位数的约1/2时即可</p>\n</li>\n<li><p>已知e,n爆破 1024的P，至少需要知道前576位二进制，即前144位16进制(特殊情况下，可能所得到的已知位数稍小于144位，需要爆破两三位，然后使用sage脚本)</p>\n</li>\n<li><p>正好已知144位16进制的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;</span><br><span class=\"line\">p4&#x3D;            #已知P的高位</span><br><span class=\"line\">e&#x3D;</span><br><span class=\"line\">pbits&#x3D;          #P原本的位数</span><br><span class=\"line\"></span><br><span class=\"line\">kbits&#x3D;pbits - p4.nbits()</span><br><span class=\"line\">print p4.nbits()</span><br><span class=\"line\">p4 &#x3D; p4 &lt;&lt; kbits</span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\">f &#x3D; x + p4</span><br><span class=\"line\">roots &#x3D; f.small_roots(X&#x3D;2^kbits,beta&#x3D;0.4)</span><br><span class=\"line\"># 经过以上一些函数处理后，n和p已经被转化为10进制</span><br><span class=\"line\">if roots:</span><br><span class=\"line\">    p&#x3D; p4 + int(roots([0]))</span><br><span class=\"line\">    print &quot;n&quot;,n</span><br><span class=\"line\">    print &quot;p&quot;,p</span><br><span class=\"line\">    print &quot;q&quot;,n&#x2F;p</span><br></pre></td></tr></table></figure></li>\n<li><p>已知142位16进制的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;</span><br><span class=\"line\">p4&#x3D;            #已知P的高位,最后面8位二进制，也就是两位十六进制要参与爆破，所以要用00补充</span><br><span class=\"line\">e&#x3D;</span><br><span class=\"line\">pbits&#x3D;          #P原本的位数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(0,256):        # 要爆破的8位二进制数，为2**8&#x3D;&#x3D;256，表示0~255</span><br><span class=\"line\">    p4 &#x3D;</span><br><span class=\"line\">    p4 &#x3D; p4 + int(hex(i),16)</span><br><span class=\"line\">#print hex(p4)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">kbits&#x3D;pbits - p4.nbits()</span><br><span class=\"line\">print p4.nbits()</span><br><span class=\"line\">p4 &#x3D; p4 &lt;&lt; kbits</span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\">f &#x3D; x + p4</span><br><span class=\"line\">roots &#x3D; f.small_roots(X&#x3D;2^kbits,beta&#x3D;0.4)</span><br><span class=\"line\"># 经过以上一些函数处理后，n和p已经被转化为10进制</span><br><span class=\"line\">if roots:</span><br><span class=\"line\">    p&#x3D; p4 + int(roots([0]))</span><br><span class=\"line\">    print &quot;n&quot;,n</span><br><span class=\"line\">    print &quot;p&quot;,p</span><br><span class=\"line\">    print &quot;q&quot;,n&#x2F;p</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知d的高位\"><a href=\"#已知d的高位\" class=\"headerlink\" title=\"已知d的高位\"></a>已知d的高位</h2></li>\n<li><p>如果知道d的低位，低位约为n的位数的1/4就可以恢复d。已知私钥的512位的低位 Partial Key Exposure Attack(部分私钥暴露攻击)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def partial_p(p0, kbits, n):</span><br><span class=\"line\"> </span><br><span class=\"line\">    PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\"> </span><br><span class=\"line\">    nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    f &#x3D; 2^kbits*x + p0</span><br><span class=\"line\"> </span><br><span class=\"line\">    f &#x3D; f.monic()</span><br><span class=\"line\"> </span><br><span class=\"line\">    roots &#x3D; f.small_roots(X&#x3D;2^(nbits&#x2F;&#x2F;2-kbits), beta&#x3D;0.3)  # find root &lt; 2^(nbits&#x2F;&#x2F;2-kbits) with factor &gt;&#x3D; n^0.3</span><br><span class=\"line\"> </span><br><span class=\"line\">    if roots:</span><br><span class=\"line\"> </span><br><span class=\"line\">        x0 &#x3D; roots[0]</span><br><span class=\"line\"> </span><br><span class=\"line\">        p &#x3D; gcd(2^kbits*x0 + p0, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">        return ZZ(p)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">def find_p(d0, kbits, e, n):</span><br><span class=\"line\"> </span><br><span class=\"line\">    X &#x3D; var(&#39;X&#39;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    for k in xrange(1, e+1):</span><br><span class=\"line\"> </span><br><span class=\"line\">        results &#x3D; solve_mod([e*d0*X - k*X*(n-X+1) + k*n &#x3D;&#x3D; X], 2^kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">        for x in results:</span><br><span class=\"line\"> </span><br><span class=\"line\">            p0 &#x3D; ZZ(x[0])</span><br><span class=\"line\"> </span><br><span class=\"line\">            p &#x3D; partial_p(p0, kbits, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">            if p:</span><br><span class=\"line\"> </span><br><span class=\"line\">                return p</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\"> </span><br><span class=\"line\">    n &#x3D; 0xd463feb999c9292e25acd7f98d49a13413df2c4e74820136e739281bb394a73f2d1e6b53066932f50a73310360e5a5c622507d8662dadaef860b3266222129fd645eb74a0207af9bd79a9794f4bd21f32841ce9e1700b0b049cfadb760993fcfc7c65eca63904aa197df306cad8720b1b228484629cf967d808c13f6caef94a9</span><br><span class=\"line\"> </span><br><span class=\"line\">    e &#x3D; 3</span><br><span class=\"line\"> </span><br><span class=\"line\">    d &#x3D; 0x603d033f2ef6c759aec839f132a45215fc8a635b757f3951a731fe60bc6729b3bcf819b57abfcaba3a93e9edef766c0d499cad3f7adb306bcf1645cfb63400e3</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    beta &#x3D; 0.5</span><br><span class=\"line\"> </span><br><span class=\"line\">    epsilon &#x3D; beta^2&#x2F;7</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;nbits:%d:&quot;%(nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">    #kbits &#x3D; floor(nbits*(beta^2+epsilon))</span><br><span class=\"line\"> </span><br><span class=\"line\">    kbits &#x3D; nbits - d.nbits()-1</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;kbits:%d&quot;%(kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">    d0 &#x3D; d &amp; (2^kbits-1)</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;lower %d bits (of %d bits) is given&quot; % (kbits, nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    p &#x3D; find_p(d0, kbits, e, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;found p: %d&quot; % p</span><br><span class=\"line\"> </span><br><span class=\"line\">    q &#x3D; n&#x2F;&#x2F;p</span><br><span class=\"line\"> </span><br><span class=\"line\">    print d</span><br><span class=\"line\"> </span><br><span class=\"line\">print inverse_mod(e, (p-1)*(q-1))</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知明文m的高位\"><a href=\"#已知明文m的高位\" class=\"headerlink\" title=\"已知明文m的高位\"></a>已知明文m的高位</h2></li>\n<li><p>已知明文的高位，是Stereotyped messages攻击 或 Lattice based attacks </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n &#x3D; 0x2519834a6cc3bf25d078caefc5358e41c726a7a56270e425e21515d1b195b248b82f4189a0b621694586bb254e27010ee4376a849bb373e5e3f2eb622e3e7804d18ddb897463f3516b431e7fc65ec41c42edf736d5940c3139d1e374aed1fc3b70737125e1f540b541a9c671f4bf0ded798d727211116eb8b86cdd6a29aefcc7</span><br><span class=\"line\"></span><br><span class=\"line\">e &#x3D; 3</span><br><span class=\"line\">m &#x3D; randrange(n)</span><br><span class=\"line\">c &#x3D; pow(m, e, n)</span><br><span class=\"line\"></span><br><span class=\"line\">beta &#x3D; 1</span><br><span class=\"line\"> </span><br><span class=\"line\">epsilon &#x3D; beta^2&#x2F;7</span><br><span class=\"line\"> </span><br><span class=\"line\">nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\">kbits &#x3D; floor(nbits*(beta^2&#x2F;e-epsilon))</span><br><span class=\"line\"> </span><br><span class=\"line\">#mbar &#x3D; m &amp; (2^nbits-2^kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">mbar &#x3D; 0xb11ffc4ce423c77035280f1c575696327901daac8a83c057c453973ee5f4e508455648886441c0f3393fe4c922ef1c3a6249c12d21a000000000000000000</span><br><span class=\"line\"> </span><br><span class=\"line\">c &#x3D; 0x1f6f6a8e61f7b5ad8bef738f4376a96724192d8da1e3689dec7ce5d1df615e0910803317f9bafb6671ffe722e0292ce76cca399f2af1952dd31a61b37019da9cf27f82c3ecd4befc03c557efe1a5a29f9bb73c0239f62ed951955718ac0eaa3f60a4c415ef064ea33bbd61abe127c6fc808c0edb034c52c45bd20a219317fb75</span><br><span class=\"line\"> </span><br><span class=\"line\">print &quot;upper %d bits (of %d bits) is given&quot; % (nbits-kbits, nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\"> </span><br><span class=\"line\">f &#x3D; (mbar + x)^e - c</span><br><span class=\"line\"></span><br><span class=\"line\">print m</span><br><span class=\"line\">x0 &#x3D; f.small_roots(X&#x3D;2^kbits, beta&#x3D;1)[0]  # find root &lt; 2^kbits with factor &#x3D; n1</span><br><span class=\"line\">print mbar + x0</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"密码学编码(二)base编码","author":"人生若只如初见","date":"2020-05-27T07:23:00.000Z","_content":"* 我们接着上一节。\n* 上一节我们讲述了ASCII编码，接下来的base系列编码与ASCII之间联系非常紧密。好，我们继续讲解。\n\n* base系列编码：\n* ASCII 是用128（2^8）个字符，对二进制数据进行编码的方式，\n* base64编码是用64（2^6）个字符，对二进制数据进行编码的方式 \n* base32就是用32（2^5）个字符，对二进制数据进行编码的方式\n* base16就是用16（2^4）个字符，对二进制数据进行编码的方式\n\n* 这里我们可以清楚的看到，base系列编码之间的不同，在于用于编码的字符数量的多少。\n\n* 那我们如何直接区分出base16、32、64编码呢？\n* 那可以从编码字符的数量方面入手，对于base16，用于编码的字符只有：1-9，A-F ,只有简单的15个字符。对于base32而言，编码字符有了明显改变，由base16的类型转变为了A-Z,2-7。作为base系列中最完善的base64编码，是在base32的基础上，增加了”a-z,0,1,8,9,+,/“，以及特殊填充字符”=”\n* Base-64编码将一个8位子节序列拆散为6位的片段，并为每个6位的片短分配一个字符，这个字符是Base-64字母表中的64个字符之一。\n\n* 编码解码过程：\n* base系列编码过程都类似，所以我们用base64来说明\n# base64填充\n* base64编码收到一个8位字节序列，将这个二进制序列流划分成6位的块。二进制序列有时不能正好平均地分为6位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为24的倍数(6和8的最小公倍数)。\n* 对已填充的二进制进行编码时，任何完全填充(不包括原始数组中的位)的6位组都有特殊的第65个符号”=”表示。如果6位组是部分填充的，就将填充位设置为0.\n* 下面会写一个填充实例。初始输入字符串为”a:a”为3个字节(24位)。24是6和8的倍数，因此按照上面给出的例子计算。无需填充就会得到base64编码为”YTph”。\n* 然而，再增加一个字符，输入字符串变为”a:aa”,转换为二进制就会有32位长。而6和8的下一个公倍数为48.因此要添加16为的填充码。填充的前4位是与数据位混合在一起的。得到的6位组01xxxx，会被当作010000、十进制中的16，或者base64编码的Q来处理。剩下的两个6位组都是填充码，用=来表示。\n\n```\na:a -- 011000 010011 101001 100001 -- YTph\n\na:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ==\n\na:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE=\n\na:aaaa -- 011000 010011 101001 100001 011000 010110 000101 1000001 -- YTphYWFh\n```\n* 特别注意，Base64编码后的文本的长度总是4的倍数，但是如果再加上1到2个=不就不是4的倍数了吗？\n* 所以并不是先编码，再加上1到2个=，而是编码之后，把最后的1到2个字符（这个字符肯定是A）替换成=\n* 改进：\n\n```\n1.  标准Base64里是包含 + 和 / 的，在URL里不能直接作为参数，所以出现一种 “url safe” 的Base64编码，其实就是把 + 和 / 替换成 - 和 _ 。\n2.  同样的，=也会被误解，所以编码后干脆去掉=，解码时，自动添加一定数量的等号，使得其长度为4的倍数即可正常解码了。\n```\n\n* 对于base系列的编码解码，可在下面的在线网站进行解码： [base16，base32,base64编码在线](https://www.qqxiuzi.cn/bianma/base.php)\n* base16相当于是16进制，可以直接16进制转字符串\n* base64编码图\n\n\n![](/images/pasted-0.png)\n\n## c语言实现base64：\n\n\n* base64编码、解码实现\n* C语言源代码\n\n\n* 使用说明：\n* 命令行参数说明：若有“-d”参数，则为base64解码，否则为base64编码。\n* 若有“-o”参数，后接文件名，则输出到标准输出文件。\n* 输入来自标准输入stdin，输出为标准输出stdout。可重定向输入输出流。\n\n* base64编码：输入任意二进制流，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出纯文本的base64编码。\n\n* base64解码：输入纯文本的base64编码，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出原来的二进制流。\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <io.h>\n#include <fcntl.h>\n#include <stdbool.h>\n\n#ifndef MAX_PATH\n#define MAX_PATH 256\n#endif\n\nconst char * base64char = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nchar * base64_encode( const unsigned char * bindata, char * base64, int binlength )\n{\n    int i, j;\n    unsigned char current;\n\n    for ( i = 0, j = 0 ; i < binlength ; i += 3 )\n    {\n        current = (bindata[i] >> 2) ;\n        current &= (unsigned char)0x3F;\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i] << 4 ) ) & ( (unsigned char)0x30 ) ;\n        if ( i + 1 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+1] >> 4) ) & ( (unsigned char) 0x0F );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i+1] << 2) ) & ( (unsigned char)0x3C ) ;\n        if ( i + 2 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+2] >> 6) ) & ( (unsigned char) 0x03 );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)bindata[i+2] ) & ( (unsigned char)0x3F ) ;\n        base64[j++] = base64char[(int)current];\n    }\n    base64[j] = '\\0';\n    return base64;\n}\n\nint base64_decode( const char * base64, unsigned char * bindata )\n{\n    int i, j;\n    unsigned char k;\n    unsigned char temp[4];\n    for ( i = 0, j = 0; base64[i] != '\\0' ; i += 4 )\n    {\n        memset( temp, 0xFF, sizeof(temp) );\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i] )\n                temp[0]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+1] )\n                temp[1]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+2] )\n                temp[2]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+3] )\n                temp[3]= k;\n        }\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[0] << 2))&0xFC)) |\n                ((unsigned char)((unsigned char)(temp[1]>>4)&0x03));\n        if ( base64[i+2] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[1] << 4))&0xF0)) |\n                ((unsigned char)((unsigned char)(temp[2]>>2)&0x0F));\n        if ( base64[i+3] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[2] << 6))&0xF0)) |\n                ((unsigned char)(temp[3]&0x3F));\n    }\n    return j;\n}\n\nvoid encode(FILE * fp_in, FILE * fp_out)\n{\n    unsigned char bindata[2050];\n    char base64[4096];\n    size_t bytes;\n    while ( !feof( fp_in ) )\n    {\n        bytes = fread( bindata, 1, 2049, fp_in );\n        base64_encode( bindata, base64, bytes );\n        fprintf( fp_out, \"%s\", base64 );\n    }\n}\n\nvoid decode(FILE * fp_in, FILE * fp_out)\n{\n    int i;\n    unsigned char bindata[2050];\n    char base64[4096];\n    size_t bytes;\n    while ( !feof( fp_in ) )\n    {\n        for ( i = 0 ; i < 2048 ; i ++ )\n        {\n            base64[i] = fgetc(fp_in);\n            if ( base64[i] == EOF )\n                break;\n            else if ( base64[i] == '\\n' || base64[i] == '\\r' )\n                i --;\n        }\n        bytes = base64_decode( base64, bindata );\n        fwrite( bindata, bytes, 1, fp_out );\n    }\n}\n\nvoid help(const char * filepath)\n{\n    fprintf( stderr, \"Usage: %s [-d] [input_filename] [-o output_filepath]\\n\", filepath );\n    fprintf( stderr, \"\\t-d\\tdecode data\\n\" );\n    fprintf( stderr, \"\\t-o\\toutput filepath\\n\\n\" );\n}\n\nint main(int argc, char * argv[])\n{\n    FILE * fp_input = NULL;\n    FILE * fp_output = NULL;\n    bool isencode = true;\n    bool needHelp = false;\n    int opt = 0;\n    char input_filename[MAX_PATH] = \"\";\n    char output_filename[MAX_PATH] = \"\";\n\n    opterr = 0;\n    while ( (opt = getopt(argc, argv, \"hdo:\")) != -1 )\n    {\n        switch(opt)\n        {\n        case 'd':\n            isencode = false;\n            break;\n        case 'o':\n            strncpy(output_filename, optarg, sizeof(output_filename));\n            output_filename[sizeof(output_filename)-1] = '\\0';\n            break;\n        case 'h':\n            needHelp = true;\n            break;\n        default:\n            fprintf(stderr, \"%s: invalid option -- %c\\n\", argv[0], optopt);\n            needHelp = true;\n            break;\n        }\n    }\n    if ( optind < argc )\n    {\n        strncpy(input_filename, argv[optind], sizeof(input_filename));\n        input_filename[sizeof(input_filename)-1] = '\\0';\n    }\n\n    if (needHelp)\n    {\n        help(argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    if ( !strcmp(input_filename, \"\") )\n    {\n        fp_input = stdin;\n        if (isencode)\n            _setmode( _fileno(stdin), _O_BINARY );\n    }\n    else\n    {\n        if (isencode)\n            fp_input = fopen(input_filename, \"rb\");\n        else\n            fp_input = fopen(input_filename, \"r\");\n    }\n    if ( fp_input == NULL )\n    {\n        fprintf(stderr, \"Input file open error\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if ( !strcmp(output_filename, \"\") )\n    {\n        fp_output = stdout;\n        if (!isencode)\n            _setmode( _fileno(stdout), _O_BINARY );\n    }\n    else\n    {\n        if (isencode)\n            fp_output = fopen(output_filename, \"w\");\n        else\n            fp_output = fopen(output_filename, \"wb\");\n    }\n    if ( fp_output == NULL )\n    {\n        fclose(fp_input);\n        fp_input = NULL;\n        fprintf(stderr, \"Output file open error\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if (isencode)\n        encode(fp_input, fp_output);\n    else\n        decode(fp_input, fp_output);\n    fclose(fp_input);\n    fclose(fp_output);\n    fp_input = fp_output = NULL;\n    return EXIT_SUCCESS;\n}\n```\n* 除了以上的三种编码外，base系列还有其他的几种\n* base58,base85,base91,base92，base128\n\n* base58的应用：比特币、Monero、Ripple、Flickr都在用这个Base58的编码方式\n\n* base58编码表：\n\n![](/images/pasted-1.png)\n* 也就是字符1代表0，字符2代表1,字符3代表2…字符z代表57。然后回一下辗转相除法。\n* 如要将1234转换为58进制；\n* 第一步：1234除于58，商21，余数为16，查表得H\n* 第二步：21除于58，商0，余数为21，查表得N\n* 所以得到base58编码为：NH\n* 如果待转换的数前面有0怎么办？直接附加编码1来代表，有多少个就附加多少个（编码表中1代表0）\n* 大值思路为：\n\n```\n    将数据转换为大整数x，\n    依次将（x % 58）的值表示的编码添加到输出字符串末尾；\n    令x = ( x / 58 );\n    重复2-3，直到x等于0；\n    将数据前所有0的编码（即“1”）添加到输出字符串末尾；\n    将输出字符串反转，即为Base58编码字符串。\n    由于编码前数据可以视为256进制编码数据，所以转换为58进制编码数据后，数据长度为变长。\n```\n* 即：\n* Base58的本质就是把256进制的值转成58进制的值。\n* 所以它在编码时不需要考虑补\\x00的问题，直接转换即可。\n* 把字节流转成一个256进制的大数，然后不断除以58，保留余数，最后余数当作索引，再倒序，即为转换后的结果。\n\n* 特殊处理：\n* 不同于一个普通的数字转成某个进制，普通数字最高位是不会为0的，而我们要编码的对象是字节流，那么如果字节流的最前面是0（\\x00），那么就会丢失这个信息。所以编码时要特殊记录一下，字节流的开端有多少个\\x00，就直接在转换后的编码前面加上多少个b58Alphabet[0]，同理，解码的时候先记录一下前面的b58Alphabet[0]的个数，然后解码之后再在解码的前面加上相同数量的0x00。\n\n* 假设原长度为Len256，转换为长度为Len58，则：\n* Len58 = Len256 * ( log256 / log58 ) + 1\n* 使用C语言进行base58的加密：\n\n![](/images/pasted-2.png)\n\n![](/images/pasted-3.png)\n\n![](/images/pasted-4.png)\n\n![](/images/pasted-5.png)\n\n![](/images/pasted-6.png)\n\n* 关于base64和base58的总结：\n* 不管是Base64还是Base58，都会造成信息的冗余，使得需要传输的数据量增大，所以不会用在很大的数据上。\n\n```\n    使用Base64最普遍的是URL、邮件文本、图片；\n    相比于Base64直接切割比特的方法（3个比特变为4个比特），Base58采用的大数进制转换，效率更低，所以使用场景的数据更少，例如上面提到的比特币的地址的编码。\n```\n* 下一节我们讲述Unicode编码","source":"_drafts/密码学编码-二-base编码.md","raw":"title: 密码学编码(二)base编码\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 编码\ndate: 2020-05-27 15:23:00\n---\n* 我们接着上一节。\n* 上一节我们讲述了ASCII编码，接下来的base系列编码与ASCII之间联系非常紧密。好，我们继续讲解。\n\n* base系列编码：\n* ASCII 是用128（2^8）个字符，对二进制数据进行编码的方式，\n* base64编码是用64（2^6）个字符，对二进制数据进行编码的方式 \n* base32就是用32（2^5）个字符，对二进制数据进行编码的方式\n* base16就是用16（2^4）个字符，对二进制数据进行编码的方式\n\n* 这里我们可以清楚的看到，base系列编码之间的不同，在于用于编码的字符数量的多少。\n\n* 那我们如何直接区分出base16、32、64编码呢？\n* 那可以从编码字符的数量方面入手，对于base16，用于编码的字符只有：1-9，A-F ,只有简单的15个字符。对于base32而言，编码字符有了明显改变，由base16的类型转变为了A-Z,2-7。作为base系列中最完善的base64编码，是在base32的基础上，增加了”a-z,0,1,8,9,+,/“，以及特殊填充字符”=”\n* Base-64编码将一个8位子节序列拆散为6位的片段，并为每个6位的片短分配一个字符，这个字符是Base-64字母表中的64个字符之一。\n\n* 编码解码过程：\n* base系列编码过程都类似，所以我们用base64来说明\n# base64填充\n* base64编码收到一个8位字节序列，将这个二进制序列流划分成6位的块。二进制序列有时不能正好平均地分为6位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为24的倍数(6和8的最小公倍数)。\n* 对已填充的二进制进行编码时，任何完全填充(不包括原始数组中的位)的6位组都有特殊的第65个符号”=”表示。如果6位组是部分填充的，就将填充位设置为0.\n* 下面会写一个填充实例。初始输入字符串为”a:a”为3个字节(24位)。24是6和8的倍数，因此按照上面给出的例子计算。无需填充就会得到base64编码为”YTph”。\n* 然而，再增加一个字符，输入字符串变为”a:aa”,转换为二进制就会有32位长。而6和8的下一个公倍数为48.因此要添加16为的填充码。填充的前4位是与数据位混合在一起的。得到的6位组01xxxx，会被当作010000、十进制中的16，或者base64编码的Q来处理。剩下的两个6位组都是填充码，用=来表示。\n\n```\na:a -- 011000 010011 101001 100001 -- YTph\n\na:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ==\n\na:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE=\n\na:aaaa -- 011000 010011 101001 100001 011000 010110 000101 1000001 -- YTphYWFh\n```\n* 特别注意，Base64编码后的文本的长度总是4的倍数，但是如果再加上1到2个=不就不是4的倍数了吗？\n* 所以并不是先编码，再加上1到2个=，而是编码之后，把最后的1到2个字符（这个字符肯定是A）替换成=\n* 改进：\n\n```\n1.  标准Base64里是包含 + 和 / 的，在URL里不能直接作为参数，所以出现一种 “url safe” 的Base64编码，其实就是把 + 和 / 替换成 - 和 _ 。\n2.  同样的，=也会被误解，所以编码后干脆去掉=，解码时，自动添加一定数量的等号，使得其长度为4的倍数即可正常解码了。\n```\n\n* 对于base系列的编码解码，可在下面的在线网站进行解码： [base16，base32,base64编码在线](https://www.qqxiuzi.cn/bianma/base.php)\n* base16相当于是16进制，可以直接16进制转字符串\n* base64编码图\n\n\n![](/images/pasted-0.png)\n\n## c语言实现base64：\n\n\n* base64编码、解码实现\n* C语言源代码\n\n\n* 使用说明：\n* 命令行参数说明：若有“-d”参数，则为base64解码，否则为base64编码。\n* 若有“-o”参数，后接文件名，则输出到标准输出文件。\n* 输入来自标准输入stdin，输出为标准输出stdout。可重定向输入输出流。\n\n* base64编码：输入任意二进制流，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出纯文本的base64编码。\n\n* base64解码：输入纯文本的base64编码，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出原来的二进制流。\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <io.h>\n#include <fcntl.h>\n#include <stdbool.h>\n\n#ifndef MAX_PATH\n#define MAX_PATH 256\n#endif\n\nconst char * base64char = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nchar * base64_encode( const unsigned char * bindata, char * base64, int binlength )\n{\n    int i, j;\n    unsigned char current;\n\n    for ( i = 0, j = 0 ; i < binlength ; i += 3 )\n    {\n        current = (bindata[i] >> 2) ;\n        current &= (unsigned char)0x3F;\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i] << 4 ) ) & ( (unsigned char)0x30 ) ;\n        if ( i + 1 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+1] >> 4) ) & ( (unsigned char) 0x0F );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i+1] << 2) ) & ( (unsigned char)0x3C ) ;\n        if ( i + 2 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+2] >> 6) ) & ( (unsigned char) 0x03 );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)bindata[i+2] ) & ( (unsigned char)0x3F ) ;\n        base64[j++] = base64char[(int)current];\n    }\n    base64[j] = '\\0';\n    return base64;\n}\n\nint base64_decode( const char * base64, unsigned char * bindata )\n{\n    int i, j;\n    unsigned char k;\n    unsigned char temp[4];\n    for ( i = 0, j = 0; base64[i] != '\\0' ; i += 4 )\n    {\n        memset( temp, 0xFF, sizeof(temp) );\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i] )\n                temp[0]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+1] )\n                temp[1]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+2] )\n                temp[2]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+3] )\n                temp[3]= k;\n        }\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[0] << 2))&0xFC)) |\n                ((unsigned char)((unsigned char)(temp[1]>>4)&0x03));\n        if ( base64[i+2] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[1] << 4))&0xF0)) |\n                ((unsigned char)((unsigned char)(temp[2]>>2)&0x0F));\n        if ( base64[i+3] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[2] << 6))&0xF0)) |\n                ((unsigned char)(temp[3]&0x3F));\n    }\n    return j;\n}\n\nvoid encode(FILE * fp_in, FILE * fp_out)\n{\n    unsigned char bindata[2050];\n    char base64[4096];\n    size_t bytes;\n    while ( !feof( fp_in ) )\n    {\n        bytes = fread( bindata, 1, 2049, fp_in );\n        base64_encode( bindata, base64, bytes );\n        fprintf( fp_out, \"%s\", base64 );\n    }\n}\n\nvoid decode(FILE * fp_in, FILE * fp_out)\n{\n    int i;\n    unsigned char bindata[2050];\n    char base64[4096];\n    size_t bytes;\n    while ( !feof( fp_in ) )\n    {\n        for ( i = 0 ; i < 2048 ; i ++ )\n        {\n            base64[i] = fgetc(fp_in);\n            if ( base64[i] == EOF )\n                break;\n            else if ( base64[i] == '\\n' || base64[i] == '\\r' )\n                i --;\n        }\n        bytes = base64_decode( base64, bindata );\n        fwrite( bindata, bytes, 1, fp_out );\n    }\n}\n\nvoid help(const char * filepath)\n{\n    fprintf( stderr, \"Usage: %s [-d] [input_filename] [-o output_filepath]\\n\", filepath );\n    fprintf( stderr, \"\\t-d\\tdecode data\\n\" );\n    fprintf( stderr, \"\\t-o\\toutput filepath\\n\\n\" );\n}\n\nint main(int argc, char * argv[])\n{\n    FILE * fp_input = NULL;\n    FILE * fp_output = NULL;\n    bool isencode = true;\n    bool needHelp = false;\n    int opt = 0;\n    char input_filename[MAX_PATH] = \"\";\n    char output_filename[MAX_PATH] = \"\";\n\n    opterr = 0;\n    while ( (opt = getopt(argc, argv, \"hdo:\")) != -1 )\n    {\n        switch(opt)\n        {\n        case 'd':\n            isencode = false;\n            break;\n        case 'o':\n            strncpy(output_filename, optarg, sizeof(output_filename));\n            output_filename[sizeof(output_filename)-1] = '\\0';\n            break;\n        case 'h':\n            needHelp = true;\n            break;\n        default:\n            fprintf(stderr, \"%s: invalid option -- %c\\n\", argv[0], optopt);\n            needHelp = true;\n            break;\n        }\n    }\n    if ( optind < argc )\n    {\n        strncpy(input_filename, argv[optind], sizeof(input_filename));\n        input_filename[sizeof(input_filename)-1] = '\\0';\n    }\n\n    if (needHelp)\n    {\n        help(argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    if ( !strcmp(input_filename, \"\") )\n    {\n        fp_input = stdin;\n        if (isencode)\n            _setmode( _fileno(stdin), _O_BINARY );\n    }\n    else\n    {\n        if (isencode)\n            fp_input = fopen(input_filename, \"rb\");\n        else\n            fp_input = fopen(input_filename, \"r\");\n    }\n    if ( fp_input == NULL )\n    {\n        fprintf(stderr, \"Input file open error\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if ( !strcmp(output_filename, \"\") )\n    {\n        fp_output = stdout;\n        if (!isencode)\n            _setmode( _fileno(stdout), _O_BINARY );\n    }\n    else\n    {\n        if (isencode)\n            fp_output = fopen(output_filename, \"w\");\n        else\n            fp_output = fopen(output_filename, \"wb\");\n    }\n    if ( fp_output == NULL )\n    {\n        fclose(fp_input);\n        fp_input = NULL;\n        fprintf(stderr, \"Output file open error\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if (isencode)\n        encode(fp_input, fp_output);\n    else\n        decode(fp_input, fp_output);\n    fclose(fp_input);\n    fclose(fp_output);\n    fp_input = fp_output = NULL;\n    return EXIT_SUCCESS;\n}\n```\n* 除了以上的三种编码外，base系列还有其他的几种\n* base58,base85,base91,base92，base128\n\n* base58的应用：比特币、Monero、Ripple、Flickr都在用这个Base58的编码方式\n\n* base58编码表：\n\n![](/images/pasted-1.png)\n* 也就是字符1代表0，字符2代表1,字符3代表2…字符z代表57。然后回一下辗转相除法。\n* 如要将1234转换为58进制；\n* 第一步：1234除于58，商21，余数为16，查表得H\n* 第二步：21除于58，商0，余数为21，查表得N\n* 所以得到base58编码为：NH\n* 如果待转换的数前面有0怎么办？直接附加编码1来代表，有多少个就附加多少个（编码表中1代表0）\n* 大值思路为：\n\n```\n    将数据转换为大整数x，\n    依次将（x % 58）的值表示的编码添加到输出字符串末尾；\n    令x = ( x / 58 );\n    重复2-3，直到x等于0；\n    将数据前所有0的编码（即“1”）添加到输出字符串末尾；\n    将输出字符串反转，即为Base58编码字符串。\n    由于编码前数据可以视为256进制编码数据，所以转换为58进制编码数据后，数据长度为变长。\n```\n* 即：\n* Base58的本质就是把256进制的值转成58进制的值。\n* 所以它在编码时不需要考虑补\\x00的问题，直接转换即可。\n* 把字节流转成一个256进制的大数，然后不断除以58，保留余数，最后余数当作索引，再倒序，即为转换后的结果。\n\n* 特殊处理：\n* 不同于一个普通的数字转成某个进制，普通数字最高位是不会为0的，而我们要编码的对象是字节流，那么如果字节流的最前面是0（\\x00），那么就会丢失这个信息。所以编码时要特殊记录一下，字节流的开端有多少个\\x00，就直接在转换后的编码前面加上多少个b58Alphabet[0]，同理，解码的时候先记录一下前面的b58Alphabet[0]的个数，然后解码之后再在解码的前面加上相同数量的0x00。\n\n* 假设原长度为Len256，转换为长度为Len58，则：\n* Len58 = Len256 * ( log256 / log58 ) + 1\n* 使用C语言进行base58的加密：\n\n![](/images/pasted-2.png)\n\n![](/images/pasted-3.png)\n\n![](/images/pasted-4.png)\n\n![](/images/pasted-5.png)\n\n![](/images/pasted-6.png)\n\n* 关于base64和base58的总结：\n* 不管是Base64还是Base58，都会造成信息的冗余，使得需要传输的数据量增大，所以不会用在很大的数据上。\n\n```\n    使用Base64最普遍的是URL、邮件文本、图片；\n    相比于Base64直接切割比特的方法（3个比特变为4个比特），Base58采用的大数进制转换，效率更低，所以使用场景的数据更少，例如上面提到的比特币的地址的编码。\n```\n* 下一节我们讲述Unicode编码","slug":"密码学编码-二-base编码","published":0,"updated":"2020-05-27T09:53:25.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17s000pvcu9doyzdw6r","content":"<ul>\n<li><p>我们接着上一节。</p>\n</li>\n<li><p>上一节我们讲述了ASCII编码，接下来的base系列编码与ASCII之间联系非常紧密。好，我们继续讲解。</p>\n</li>\n<li><p>base系列编码：</p>\n</li>\n<li><p>ASCII 是用128（2^8）个字符，对二进制数据进行编码的方式，</p>\n</li>\n<li><p>base64编码是用64（2^6）个字符，对二进制数据进行编码的方式 </p>\n</li>\n<li><p>base32就是用32（2^5）个字符，对二进制数据进行编码的方式</p>\n</li>\n<li><p>base16就是用16（2^4）个字符，对二进制数据进行编码的方式</p>\n</li>\n<li><p>这里我们可以清楚的看到，base系列编码之间的不同，在于用于编码的字符数量的多少。</p>\n</li>\n<li><p>那我们如何直接区分出base16、32、64编码呢？</p>\n</li>\n<li><p>那可以从编码字符的数量方面入手，对于base16，用于编码的字符只有：1-9，A-F ,只有简单的15个字符。对于base32而言，编码字符有了明显改变，由base16的类型转变为了A-Z,2-7。作为base系列中最完善的base64编码，是在base32的基础上，增加了”a-z,0,1,8,9,+,/“，以及特殊填充字符”=”</p>\n</li>\n<li><p>Base-64编码将一个8位子节序列拆散为6位的片段，并为每个6位的片短分配一个字符，这个字符是Base-64字母表中的64个字符之一。</p>\n</li>\n<li><p>编码解码过程：</p>\n</li>\n<li><p>base系列编码过程都类似，所以我们用base64来说明</p>\n<h1 id=\"base64填充\"><a href=\"#base64填充\" class=\"headerlink\" title=\"base64填充\"></a>base64填充</h1></li>\n<li><p>base64编码收到一个8位字节序列，将这个二进制序列流划分成6位的块。二进制序列有时不能正好平均地分为6位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为24的倍数(6和8的最小公倍数)。</p>\n</li>\n<li><p>对已填充的二进制进行编码时，任何完全填充(不包括原始数组中的位)的6位组都有特殊的第65个符号”=”表示。如果6位组是部分填充的，就将填充位设置为0.</p>\n</li>\n<li><p>下面会写一个填充实例。初始输入字符串为”a:a”为3个字节(24位)。24是6和8的倍数，因此按照上面给出的例子计算。无需填充就会得到base64编码为”YTph”。</p>\n</li>\n<li><p>然而，再增加一个字符，输入字符串变为”a:aa”,转换为二进制就会有32位长。而6和8的下一个公倍数为48.因此要添加16为的填充码。填充的前4位是与数据位混合在一起的。得到的6位组01xxxx，会被当作010000、十进制中的16，或者base64编码的Q来处理。剩下的两个6位组都是填充码，用=来表示。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:a -- 011000 010011 101001 100001 -- YTph</span><br><span class=\"line\"></span><br><span class=\"line\">a:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ&#x3D;&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">a:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">a:aaaa -- 011000 010011 101001 100001 011000 010110 000101 1000001 -- YTphYWFh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特别注意，Base64编码后的文本的长度总是4的倍数，但是如果再加上1到2个=不就不是4的倍数了吗？</li>\n<li>所以并不是先编码，再加上1到2个=，而是编码之后，把最后的1到2个字符（这个字符肯定是A）替换成=</li>\n<li>改进：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.  标准Base64里是包含 + 和 &#x2F; 的，在URL里不能直接作为参数，所以出现一种 “url safe” 的Base64编码，其实就是把 + 和 &#x2F; 替换成 - 和 _ 。</span><br><span class=\"line\">2.  同样的，&#x3D;也会被误解，所以编码后干脆去掉&#x3D;，解码时，自动添加一定数量的等号，使得其长度为4的倍数即可正常解码了。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于base系列的编码解码，可在下面的在线网站进行解码： <a href=\"https://www.qqxiuzi.cn/bianma/base.php\" target=\"_blank\" rel=\"noopener\">base16，base32,base64编码在线</a></li>\n<li>base16相当于是16进制，可以直接16进制转字符串</li>\n<li>base64编码图</li>\n</ul>\n<p><img src=\"/images/pasted-0.png\" alt=\"\"></p>\n<h2 id=\"c语言实现base64：\"><a href=\"#c语言实现base64：\" class=\"headerlink\" title=\"c语言实现base64：\"></a>c语言实现base64：</h2><ul>\n<li>base64编码、解码实现</li>\n<li>C语言源代码</li>\n</ul>\n<ul>\n<li><p>使用说明：</p>\n</li>\n<li><p>命令行参数说明：若有“-d”参数，则为base64解码，否则为base64编码。</p>\n</li>\n<li><p>若有“-o”参数，后接文件名，则输出到标准输出文件。</p>\n</li>\n<li><p>输入来自标准输入stdin，输出为标准输出stdout。可重定向输入输出流。</p>\n</li>\n<li><p>base64编码：输入任意二进制流，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出纯文本的base64编码。</p>\n</li>\n<li><p>base64解码：输入纯文本的base64编码，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出原来的二进制流。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;io.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;stdbool.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#ifndef MAX_PATH</span><br><span class=\"line\">#define MAX_PATH 256</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">const char * base64char &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">char * base64_encode( const unsigned char * bindata, char * base64, int binlength )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, j;</span><br><span class=\"line\">    unsigned char current;</span><br><span class=\"line\"></span><br><span class=\"line\">    for ( i &#x3D; 0, j &#x3D; 0 ; i &lt; binlength ; i +&#x3D; 3 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current &#x3D; (bindata[i] &gt;&gt; 2) ;</span><br><span class=\"line\">        current &amp;&#x3D; (unsigned char)0x3F;</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)(bindata[i] &lt;&lt; 4 ) ) &amp; ( (unsigned char)0x30 ) ;</span><br><span class=\"line\">        if ( i + 1 &gt;&#x3D; binlength )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current |&#x3D; ( (unsigned char)(bindata[i+1] &gt;&gt; 4) ) &amp; ( (unsigned char) 0x0F );</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)(bindata[i+1] &lt;&lt; 2) ) &amp; ( (unsigned char)0x3C ) ;</span><br><span class=\"line\">        if ( i + 2 &gt;&#x3D; binlength )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current |&#x3D; ( (unsigned char)(bindata[i+2] &gt;&gt; 6) ) &amp; ( (unsigned char) 0x03 );</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)bindata[i+2] ) &amp; ( (unsigned char)0x3F ) ;</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    base64[j] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">    return base64;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int base64_decode( const char * base64, unsigned char * bindata )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, j;</span><br><span class=\"line\">    unsigned char k;</span><br><span class=\"line\">    unsigned char temp[4];</span><br><span class=\"line\">    for ( i &#x3D; 0, j &#x3D; 0; base64[i] !&#x3D; &#39;\\0&#39; ; i +&#x3D; 4 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        memset( temp, 0xFF, sizeof(temp) );</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i] )</span><br><span class=\"line\">                temp[0]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+1] )</span><br><span class=\"line\">                temp[1]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+2] )</span><br><span class=\"line\">                temp[2]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+3] )</span><br><span class=\"line\">                temp[3]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[0] &lt;&lt; 2))&amp;0xFC)) |</span><br><span class=\"line\">                ((unsigned char)((unsigned char)(temp[1]&gt;&gt;4)&amp;0x03));</span><br><span class=\"line\">        if ( base64[i+2] &#x3D;&#x3D; &#39;&#x3D;&#39; )</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[1] &lt;&lt; 4))&amp;0xF0)) |</span><br><span class=\"line\">                ((unsigned char)((unsigned char)(temp[2]&gt;&gt;2)&amp;0x0F));</span><br><span class=\"line\">        if ( base64[i+3] &#x3D;&#x3D; &#39;&#x3D;&#39; )</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[2] &lt;&lt; 6))&amp;0xF0)) |</span><br><span class=\"line\">                ((unsigned char)(temp[3]&amp;0x3F));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void encode(FILE * fp_in, FILE * fp_out)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char bindata[2050];</span><br><span class=\"line\">    char base64[4096];</span><br><span class=\"line\">    size_t bytes;</span><br><span class=\"line\">    while ( !feof( fp_in ) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bytes &#x3D; fread( bindata, 1, 2049, fp_in );</span><br><span class=\"line\">        base64_encode( bindata, base64, bytes );</span><br><span class=\"line\">        fprintf( fp_out, &quot;%s&quot;, base64 );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void decode(FILE * fp_in, FILE * fp_out)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    unsigned char bindata[2050];</span><br><span class=\"line\">    char base64[4096];</span><br><span class=\"line\">    size_t bytes;</span><br><span class=\"line\">    while ( !feof( fp_in ) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        for ( i &#x3D; 0 ; i &lt; 2048 ; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[i] &#x3D; fgetc(fp_in);</span><br><span class=\"line\">            if ( base64[i] &#x3D;&#x3D; EOF )</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            else if ( base64[i] &#x3D;&#x3D; &#39;\\n&#39; || base64[i] &#x3D;&#x3D; &#39;\\r&#39; )</span><br><span class=\"line\">                i --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bytes &#x3D; base64_decode( base64, bindata );</span><br><span class=\"line\">        fwrite( bindata, bytes, 1, fp_out );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void help(const char * filepath)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fprintf( stderr, &quot;Usage: %s [-d] [input_filename] [-o output_filepath]\\n&quot;, filepath );</span><br><span class=\"line\">    fprintf( stderr, &quot;\\t-d\\tdecode data\\n&quot; );</span><br><span class=\"line\">    fprintf( stderr, &quot;\\t-o\\toutput filepath\\n\\n&quot; );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char * argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE * fp_input &#x3D; NULL;</span><br><span class=\"line\">    FILE * fp_output &#x3D; NULL;</span><br><span class=\"line\">    bool isencode &#x3D; true;</span><br><span class=\"line\">    bool needHelp &#x3D; false;</span><br><span class=\"line\">    int opt &#x3D; 0;</span><br><span class=\"line\">    char input_filename[MAX_PATH] &#x3D; &quot;&quot;;</span><br><span class=\"line\">    char output_filename[MAX_PATH] &#x3D; &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    opterr &#x3D; 0;</span><br><span class=\"line\">    while ( (opt &#x3D; getopt(argc, argv, &quot;hdo:&quot;)) !&#x3D; -1 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        switch(opt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        case &#39;d&#39;:</span><br><span class=\"line\">            isencode &#x3D; false;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &#39;o&#39;:</span><br><span class=\"line\">            strncpy(output_filename, optarg, sizeof(output_filename));</span><br><span class=\"line\">            output_filename[sizeof(output_filename)-1] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &#39;h&#39;:</span><br><span class=\"line\">            needHelp &#x3D; true;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            fprintf(stderr, &quot;%s: invalid option -- %c\\n&quot;, argv[0], optopt);</span><br><span class=\"line\">            needHelp &#x3D; true;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( optind &lt; argc )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        strncpy(input_filename, argv[optind], sizeof(input_filename));</span><br><span class=\"line\">        input_filename[sizeof(input_filename)-1] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (needHelp)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        help(argv[0]);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ( !strcmp(input_filename, &quot;&quot;) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fp_input &#x3D; stdin;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            _setmode( _fileno(stdin), _O_BINARY );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            fp_input &#x3D; fopen(input_filename, &quot;rb&quot;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            fp_input &#x3D; fopen(input_filename, &quot;r&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( fp_input &#x3D;&#x3D; NULL )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;Input file open error\\n&quot;);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ( !strcmp(output_filename, &quot;&quot;) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fp_output &#x3D; stdout;</span><br><span class=\"line\">        if (!isencode)</span><br><span class=\"line\">            _setmode( _fileno(stdout), _O_BINARY );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            fp_output &#x3D; fopen(output_filename, &quot;w&quot;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            fp_output &#x3D; fopen(output_filename, &quot;wb&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( fp_output &#x3D;&#x3D; NULL )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fclose(fp_input);</span><br><span class=\"line\">        fp_input &#x3D; NULL;</span><br><span class=\"line\">        fprintf(stderr, &quot;Output file open error\\n&quot;);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (isencode)</span><br><span class=\"line\">        encode(fp_input, fp_output);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        decode(fp_input, fp_output);</span><br><span class=\"line\">    fclose(fp_input);</span><br><span class=\"line\">    fclose(fp_output);</span><br><span class=\"line\">    fp_input &#x3D; fp_output &#x3D; NULL;</span><br><span class=\"line\">    return EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>除了以上的三种编码外，base系列还有其他的几种</p>\n</li>\n<li><p>base58,base85,base91,base92，base128</p>\n</li>\n<li><p>base58的应用：比特币、Monero、Ripple、Flickr都在用这个Base58的编码方式</p>\n</li>\n<li><p>base58编码表：</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-1.png\" alt=\"\"></p>\n<ul>\n<li>也就是字符1代表0，字符2代表1,字符3代表2…字符z代表57。然后回一下辗转相除法。</li>\n<li>如要将1234转换为58进制；</li>\n<li>第一步：1234除于58，商21，余数为16，查表得H</li>\n<li>第二步：21除于58，商0，余数为21，查表得N</li>\n<li>所以得到base58编码为：NH</li>\n<li>如果待转换的数前面有0怎么办？直接附加编码1来代表，有多少个就附加多少个（编码表中1代表0）</li>\n<li>大值思路为：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将数据转换为大整数x，</span><br><span class=\"line\">依次将（x % 58）的值表示的编码添加到输出字符串末尾；</span><br><span class=\"line\">令x &#x3D; ( x &#x2F; 58 );</span><br><span class=\"line\">重复2-3，直到x等于0；</span><br><span class=\"line\">将数据前所有0的编码（即“1”）添加到输出字符串末尾；</span><br><span class=\"line\">将输出字符串反转，即为Base58编码字符串。</span><br><span class=\"line\">由于编码前数据可以视为256进制编码数据，所以转换为58进制编码数据后，数据长度为变长。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>即：</p>\n</li>\n<li><p>Base58的本质就是把256进制的值转成58进制的值。</p>\n</li>\n<li><p>所以它在编码时不需要考虑补\\x00的问题，直接转换即可。</p>\n</li>\n<li><p>把字节流转成一个256进制的大数，然后不断除以58，保留余数，最后余数当作索引，再倒序，即为转换后的结果。</p>\n</li>\n<li><p>特殊处理：</p>\n</li>\n<li><p>不同于一个普通的数字转成某个进制，普通数字最高位是不会为0的，而我们要编码的对象是字节流，那么如果字节流的最前面是0（\\x00），那么就会丢失这个信息。所以编码时要特殊记录一下，字节流的开端有多少个\\x00，就直接在转换后的编码前面加上多少个b58Alphabet[0]，同理，解码的时候先记录一下前面的b58Alphabet[0]的个数，然后解码之后再在解码的前面加上相同数量的0x00。</p>\n</li>\n<li><p>假设原长度为Len256，转换为长度为Len58，则：</p>\n</li>\n<li><p>Len58 = Len256 * ( log256 / log58 ) + 1</p>\n</li>\n<li><p>使用C语言进行base58的加密：</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-2.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-3.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-4.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-5.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-6.png\" alt=\"\"></p>\n<ul>\n<li>关于base64和base58的总结：</li>\n<li>不管是Base64还是Base58，都会造成信息的冗余，使得需要传输的数据量增大，所以不会用在很大的数据上。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用Base64最普遍的是URL、邮件文本、图片；</span><br><span class=\"line\">相比于Base64直接切割比特的方法（3个比特变为4个比特），Base58采用的大数进制转换，效率更低，所以使用场景的数据更少，例如上面提到的比特币的地址的编码。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下一节我们讲述Unicode编码</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>我们接着上一节。</p>\n</li>\n<li><p>上一节我们讲述了ASCII编码，接下来的base系列编码与ASCII之间联系非常紧密。好，我们继续讲解。</p>\n</li>\n<li><p>base系列编码：</p>\n</li>\n<li><p>ASCII 是用128（2^8）个字符，对二进制数据进行编码的方式，</p>\n</li>\n<li><p>base64编码是用64（2^6）个字符，对二进制数据进行编码的方式 </p>\n</li>\n<li><p>base32就是用32（2^5）个字符，对二进制数据进行编码的方式</p>\n</li>\n<li><p>base16就是用16（2^4）个字符，对二进制数据进行编码的方式</p>\n</li>\n<li><p>这里我们可以清楚的看到，base系列编码之间的不同，在于用于编码的字符数量的多少。</p>\n</li>\n<li><p>那我们如何直接区分出base16、32、64编码呢？</p>\n</li>\n<li><p>那可以从编码字符的数量方面入手，对于base16，用于编码的字符只有：1-9，A-F ,只有简单的15个字符。对于base32而言，编码字符有了明显改变，由base16的类型转变为了A-Z,2-7。作为base系列中最完善的base64编码，是在base32的基础上，增加了”a-z,0,1,8,9,+,/“，以及特殊填充字符”=”</p>\n</li>\n<li><p>Base-64编码将一个8位子节序列拆散为6位的片段，并为每个6位的片短分配一个字符，这个字符是Base-64字母表中的64个字符之一。</p>\n</li>\n<li><p>编码解码过程：</p>\n</li>\n<li><p>base系列编码过程都类似，所以我们用base64来说明</p>\n<h1 id=\"base64填充\"><a href=\"#base64填充\" class=\"headerlink\" title=\"base64填充\"></a>base64填充</h1></li>\n<li><p>base64编码收到一个8位字节序列，将这个二进制序列流划分成6位的块。二进制序列有时不能正好平均地分为6位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为24的倍数(6和8的最小公倍数)。</p>\n</li>\n<li><p>对已填充的二进制进行编码时，任何完全填充(不包括原始数组中的位)的6位组都有特殊的第65个符号”=”表示。如果6位组是部分填充的，就将填充位设置为0.</p>\n</li>\n<li><p>下面会写一个填充实例。初始输入字符串为”a:a”为3个字节(24位)。24是6和8的倍数，因此按照上面给出的例子计算。无需填充就会得到base64编码为”YTph”。</p>\n</li>\n<li><p>然而，再增加一个字符，输入字符串变为”a:aa”,转换为二进制就会有32位长。而6和8的下一个公倍数为48.因此要添加16为的填充码。填充的前4位是与数据位混合在一起的。得到的6位组01xxxx，会被当作010000、十进制中的16，或者base64编码的Q来处理。剩下的两个6位组都是填充码，用=来表示。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:a -- 011000 010011 101001 100001 -- YTph</span><br><span class=\"line\"></span><br><span class=\"line\">a:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ&#x3D;&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">a:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">a:aaaa -- 011000 010011 101001 100001 011000 010110 000101 1000001 -- YTphYWFh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特别注意，Base64编码后的文本的长度总是4的倍数，但是如果再加上1到2个=不就不是4的倍数了吗？</li>\n<li>所以并不是先编码，再加上1到2个=，而是编码之后，把最后的1到2个字符（这个字符肯定是A）替换成=</li>\n<li>改进：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.  标准Base64里是包含 + 和 &#x2F; 的，在URL里不能直接作为参数，所以出现一种 “url safe” 的Base64编码，其实就是把 + 和 &#x2F; 替换成 - 和 _ 。</span><br><span class=\"line\">2.  同样的，&#x3D;也会被误解，所以编码后干脆去掉&#x3D;，解码时，自动添加一定数量的等号，使得其长度为4的倍数即可正常解码了。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于base系列的编码解码，可在下面的在线网站进行解码： <a href=\"https://www.qqxiuzi.cn/bianma/base.php\" target=\"_blank\" rel=\"noopener\">base16，base32,base64编码在线</a></li>\n<li>base16相当于是16进制，可以直接16进制转字符串</li>\n<li>base64编码图</li>\n</ul>\n<p><img src=\"/images/pasted-0.png\" alt=\"\"></p>\n<h2 id=\"c语言实现base64：\"><a href=\"#c语言实现base64：\" class=\"headerlink\" title=\"c语言实现base64：\"></a>c语言实现base64：</h2><ul>\n<li>base64编码、解码实现</li>\n<li>C语言源代码</li>\n</ul>\n<ul>\n<li><p>使用说明：</p>\n</li>\n<li><p>命令行参数说明：若有“-d”参数，则为base64解码，否则为base64编码。</p>\n</li>\n<li><p>若有“-o”参数，后接文件名，则输出到标准输出文件。</p>\n</li>\n<li><p>输入来自标准输入stdin，输出为标准输出stdout。可重定向输入输出流。</p>\n</li>\n<li><p>base64编码：输入任意二进制流，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出纯文本的base64编码。</p>\n</li>\n<li><p>base64解码：输入纯文本的base64编码，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出原来的二进制流。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;io.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;stdbool.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#ifndef MAX_PATH</span><br><span class=\"line\">#define MAX_PATH 256</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">const char * base64char &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">char * base64_encode( const unsigned char * bindata, char * base64, int binlength )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, j;</span><br><span class=\"line\">    unsigned char current;</span><br><span class=\"line\"></span><br><span class=\"line\">    for ( i &#x3D; 0, j &#x3D; 0 ; i &lt; binlength ; i +&#x3D; 3 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current &#x3D; (bindata[i] &gt;&gt; 2) ;</span><br><span class=\"line\">        current &amp;&#x3D; (unsigned char)0x3F;</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)(bindata[i] &lt;&lt; 4 ) ) &amp; ( (unsigned char)0x30 ) ;</span><br><span class=\"line\">        if ( i + 1 &gt;&#x3D; binlength )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current |&#x3D; ( (unsigned char)(bindata[i+1] &gt;&gt; 4) ) &amp; ( (unsigned char) 0x0F );</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)(bindata[i+1] &lt;&lt; 2) ) &amp; ( (unsigned char)0x3C ) ;</span><br><span class=\"line\">        if ( i + 2 &gt;&#x3D; binlength )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current |&#x3D; ( (unsigned char)(bindata[i+2] &gt;&gt; 6) ) &amp; ( (unsigned char) 0x03 );</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)bindata[i+2] ) &amp; ( (unsigned char)0x3F ) ;</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    base64[j] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">    return base64;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int base64_decode( const char * base64, unsigned char * bindata )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, j;</span><br><span class=\"line\">    unsigned char k;</span><br><span class=\"line\">    unsigned char temp[4];</span><br><span class=\"line\">    for ( i &#x3D; 0, j &#x3D; 0; base64[i] !&#x3D; &#39;\\0&#39; ; i +&#x3D; 4 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        memset( temp, 0xFF, sizeof(temp) );</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i] )</span><br><span class=\"line\">                temp[0]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+1] )</span><br><span class=\"line\">                temp[1]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+2] )</span><br><span class=\"line\">                temp[2]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+3] )</span><br><span class=\"line\">                temp[3]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[0] &lt;&lt; 2))&amp;0xFC)) |</span><br><span class=\"line\">                ((unsigned char)((unsigned char)(temp[1]&gt;&gt;4)&amp;0x03));</span><br><span class=\"line\">        if ( base64[i+2] &#x3D;&#x3D; &#39;&#x3D;&#39; )</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[1] &lt;&lt; 4))&amp;0xF0)) |</span><br><span class=\"line\">                ((unsigned char)((unsigned char)(temp[2]&gt;&gt;2)&amp;0x0F));</span><br><span class=\"line\">        if ( base64[i+3] &#x3D;&#x3D; &#39;&#x3D;&#39; )</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[2] &lt;&lt; 6))&amp;0xF0)) |</span><br><span class=\"line\">                ((unsigned char)(temp[3]&amp;0x3F));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void encode(FILE * fp_in, FILE * fp_out)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char bindata[2050];</span><br><span class=\"line\">    char base64[4096];</span><br><span class=\"line\">    size_t bytes;</span><br><span class=\"line\">    while ( !feof( fp_in ) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bytes &#x3D; fread( bindata, 1, 2049, fp_in );</span><br><span class=\"line\">        base64_encode( bindata, base64, bytes );</span><br><span class=\"line\">        fprintf( fp_out, &quot;%s&quot;, base64 );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void decode(FILE * fp_in, FILE * fp_out)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    unsigned char bindata[2050];</span><br><span class=\"line\">    char base64[4096];</span><br><span class=\"line\">    size_t bytes;</span><br><span class=\"line\">    while ( !feof( fp_in ) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        for ( i &#x3D; 0 ; i &lt; 2048 ; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[i] &#x3D; fgetc(fp_in);</span><br><span class=\"line\">            if ( base64[i] &#x3D;&#x3D; EOF )</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            else if ( base64[i] &#x3D;&#x3D; &#39;\\n&#39; || base64[i] &#x3D;&#x3D; &#39;\\r&#39; )</span><br><span class=\"line\">                i --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bytes &#x3D; base64_decode( base64, bindata );</span><br><span class=\"line\">        fwrite( bindata, bytes, 1, fp_out );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void help(const char * filepath)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fprintf( stderr, &quot;Usage: %s [-d] [input_filename] [-o output_filepath]\\n&quot;, filepath );</span><br><span class=\"line\">    fprintf( stderr, &quot;\\t-d\\tdecode data\\n&quot; );</span><br><span class=\"line\">    fprintf( stderr, &quot;\\t-o\\toutput filepath\\n\\n&quot; );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char * argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE * fp_input &#x3D; NULL;</span><br><span class=\"line\">    FILE * fp_output &#x3D; NULL;</span><br><span class=\"line\">    bool isencode &#x3D; true;</span><br><span class=\"line\">    bool needHelp &#x3D; false;</span><br><span class=\"line\">    int opt &#x3D; 0;</span><br><span class=\"line\">    char input_filename[MAX_PATH] &#x3D; &quot;&quot;;</span><br><span class=\"line\">    char output_filename[MAX_PATH] &#x3D; &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    opterr &#x3D; 0;</span><br><span class=\"line\">    while ( (opt &#x3D; getopt(argc, argv, &quot;hdo:&quot;)) !&#x3D; -1 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        switch(opt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        case &#39;d&#39;:</span><br><span class=\"line\">            isencode &#x3D; false;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &#39;o&#39;:</span><br><span class=\"line\">            strncpy(output_filename, optarg, sizeof(output_filename));</span><br><span class=\"line\">            output_filename[sizeof(output_filename)-1] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &#39;h&#39;:</span><br><span class=\"line\">            needHelp &#x3D; true;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            fprintf(stderr, &quot;%s: invalid option -- %c\\n&quot;, argv[0], optopt);</span><br><span class=\"line\">            needHelp &#x3D; true;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( optind &lt; argc )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        strncpy(input_filename, argv[optind], sizeof(input_filename));</span><br><span class=\"line\">        input_filename[sizeof(input_filename)-1] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (needHelp)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        help(argv[0]);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ( !strcmp(input_filename, &quot;&quot;) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fp_input &#x3D; stdin;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            _setmode( _fileno(stdin), _O_BINARY );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            fp_input &#x3D; fopen(input_filename, &quot;rb&quot;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            fp_input &#x3D; fopen(input_filename, &quot;r&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( fp_input &#x3D;&#x3D; NULL )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;Input file open error\\n&quot;);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ( !strcmp(output_filename, &quot;&quot;) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fp_output &#x3D; stdout;</span><br><span class=\"line\">        if (!isencode)</span><br><span class=\"line\">            _setmode( _fileno(stdout), _O_BINARY );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            fp_output &#x3D; fopen(output_filename, &quot;w&quot;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            fp_output &#x3D; fopen(output_filename, &quot;wb&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( fp_output &#x3D;&#x3D; NULL )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fclose(fp_input);</span><br><span class=\"line\">        fp_input &#x3D; NULL;</span><br><span class=\"line\">        fprintf(stderr, &quot;Output file open error\\n&quot;);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (isencode)</span><br><span class=\"line\">        encode(fp_input, fp_output);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        decode(fp_input, fp_output);</span><br><span class=\"line\">    fclose(fp_input);</span><br><span class=\"line\">    fclose(fp_output);</span><br><span class=\"line\">    fp_input &#x3D; fp_output &#x3D; NULL;</span><br><span class=\"line\">    return EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>除了以上的三种编码外，base系列还有其他的几种</p>\n</li>\n<li><p>base58,base85,base91,base92，base128</p>\n</li>\n<li><p>base58的应用：比特币、Monero、Ripple、Flickr都在用这个Base58的编码方式</p>\n</li>\n<li><p>base58编码表：</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-1.png\" alt=\"\"></p>\n<ul>\n<li>也就是字符1代表0，字符2代表1,字符3代表2…字符z代表57。然后回一下辗转相除法。</li>\n<li>如要将1234转换为58进制；</li>\n<li>第一步：1234除于58，商21，余数为16，查表得H</li>\n<li>第二步：21除于58，商0，余数为21，查表得N</li>\n<li>所以得到base58编码为：NH</li>\n<li>如果待转换的数前面有0怎么办？直接附加编码1来代表，有多少个就附加多少个（编码表中1代表0）</li>\n<li>大值思路为：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将数据转换为大整数x，</span><br><span class=\"line\">依次将（x % 58）的值表示的编码添加到输出字符串末尾；</span><br><span class=\"line\">令x &#x3D; ( x &#x2F; 58 );</span><br><span class=\"line\">重复2-3，直到x等于0；</span><br><span class=\"line\">将数据前所有0的编码（即“1”）添加到输出字符串末尾；</span><br><span class=\"line\">将输出字符串反转，即为Base58编码字符串。</span><br><span class=\"line\">由于编码前数据可以视为256进制编码数据，所以转换为58进制编码数据后，数据长度为变长。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>即：</p>\n</li>\n<li><p>Base58的本质就是把256进制的值转成58进制的值。</p>\n</li>\n<li><p>所以它在编码时不需要考虑补\\x00的问题，直接转换即可。</p>\n</li>\n<li><p>把字节流转成一个256进制的大数，然后不断除以58，保留余数，最后余数当作索引，再倒序，即为转换后的结果。</p>\n</li>\n<li><p>特殊处理：</p>\n</li>\n<li><p>不同于一个普通的数字转成某个进制，普通数字最高位是不会为0的，而我们要编码的对象是字节流，那么如果字节流的最前面是0（\\x00），那么就会丢失这个信息。所以编码时要特殊记录一下，字节流的开端有多少个\\x00，就直接在转换后的编码前面加上多少个b58Alphabet[0]，同理，解码的时候先记录一下前面的b58Alphabet[0]的个数，然后解码之后再在解码的前面加上相同数量的0x00。</p>\n</li>\n<li><p>假设原长度为Len256，转换为长度为Len58，则：</p>\n</li>\n<li><p>Len58 = Len256 * ( log256 / log58 ) + 1</p>\n</li>\n<li><p>使用C语言进行base58的加密：</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-2.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-3.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-4.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-5.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-6.png\" alt=\"\"></p>\n<ul>\n<li>关于base64和base58的总结：</li>\n<li>不管是Base64还是Base58，都会造成信息的冗余，使得需要传输的数据量增大，所以不会用在很大的数据上。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用Base64最普遍的是URL、邮件文本、图片；</span><br><span class=\"line\">相比于Base64直接切割比特的方法（3个比特变为4个比特），Base58采用的大数进制转换，效率更低，所以使用场景的数据更少，例如上面提到的比特币的地址的编码。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下一节我们讲述Unicode编码</li>\n</ul>\n"},{"title":"红黑树的删除和变色","author":"人生若只如初见","date":"2020-05-28T11:02:00.000Z","_content":"# 二叉搜索树和红黑树简介\n\n* 二叉搜索树：\n\n```\n二叉搜索树是一种节点值之间具有一定数量级次序的二叉树\n对于树中的每个节点：如果存在左子树，则左子树的值小于根节点的值\n如果存在右子树，则右子树的值一定大于根节点的值\n```\n\n* 红黑树：自平衡的二叉搜索树。\n\n## 性质\n\n```\n\t性质1：每个节点要么是黑色，要么是红色。 \n\t性质2：根节点是黑色。 \n\t性质3：每个叶子节点（NIL）是黑色。 \n\t性质4：每个红色结点的两个子结点一定都是黑色。 \n\t性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。\n```\n\n# 红黑树的自平衡\n\n* \t自平衡的三种操作：左旋、右旋和变色\n*\t左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子节点，左子结点不变。\n*\t右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。\n*\t变色：结点颜色由红变黑或者由黑变红。\n\n\n![](/images/pasted-26.png)\n\n![](/images/pasted-27.png)\n\n* 红黑树左旋/右旋的实际操作意义：\n\n```\n<1> 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪。\n<2> 右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪。\n<3> 所以旋转操作是局部的。旋转保持红黑树平衡的端详：当一边子树的结点少了，那么向另外一边子树“借”一\t些结点；当一边的子树的结点多了，那么向另外一边子树“租”一些结点。\n```\n\n# 红黑树的查找\n\n* 因为红黑树是一颗二叉平衡树，并且查找并不会破坏树的平衡，所以查找和二叉平衡树的查找无异。\n\n```\n1、从根节点开始查找，把根节点设置为当前结点；\n2、若当前结点为空，返回NULL；\n3、若当前结点不为空，用当前结点的key跟查找key作比较；\n4、若当前结点key等于查找key，那么该key就是查找目标，返回当前结点； \n5、若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2； \n6、若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；\n```\n\n![](/images/pasted-28.png)\n\n# 红黑树的删除\n\n* 删除时先作为普通二叉树进行删除：\n\n```\n1、若删除结点无子结点，直接删除。\n2、若删除结点只有一个子结点，用子结点替换删除结点。\n3、若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点。（回到1和2）\n```\n\n* \t寻找前继结点和后继结点的方法：将二叉树所有结点投射到X轴上，所有结点都是从左到右排序的，所有目标结点的前后结点就是对应前继和后继结点。\n\n![](/images/pasted-29.png)\n\n* 我们在删除红黑树结点时是先将他作为普通的二叉搜索树进行操作的，我们将结点删除后，再进行变色，避免同时操作时发生混乱。\n\n\n![](/images/pasted-30.png)\n\n* 在删除结点时，我们可以将单一的结点树进行操作，而将未进行操作的树保留在一旁；整个的删除过程全部满足红黑树本身的五条性质，也就是说在变换过程中，对红黑树的一切操作都是为了让整个红黑树删除结点后依旧满足红黑树的性质。","source":"_drafts/红黑树的删除和变色.md","raw":"title: 红黑树的删除和变色\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 算法\ndate: 2020-05-28 19:02:00\n---\n# 二叉搜索树和红黑树简介\n\n* 二叉搜索树：\n\n```\n二叉搜索树是一种节点值之间具有一定数量级次序的二叉树\n对于树中的每个节点：如果存在左子树，则左子树的值小于根节点的值\n如果存在右子树，则右子树的值一定大于根节点的值\n```\n\n* 红黑树：自平衡的二叉搜索树。\n\n## 性质\n\n```\n\t性质1：每个节点要么是黑色，要么是红色。 \n\t性质2：根节点是黑色。 \n\t性质3：每个叶子节点（NIL）是黑色。 \n\t性质4：每个红色结点的两个子结点一定都是黑色。 \n\t性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。\n```\n\n# 红黑树的自平衡\n\n* \t自平衡的三种操作：左旋、右旋和变色\n*\t左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子节点，左子结点不变。\n*\t右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。\n*\t变色：结点颜色由红变黑或者由黑变红。\n\n\n![](/images/pasted-26.png)\n\n![](/images/pasted-27.png)\n\n* 红黑树左旋/右旋的实际操作意义：\n\n```\n<1> 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪。\n<2> 右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪。\n<3> 所以旋转操作是局部的。旋转保持红黑树平衡的端详：当一边子树的结点少了，那么向另外一边子树“借”一\t些结点；当一边的子树的结点多了，那么向另外一边子树“租”一些结点。\n```\n\n# 红黑树的查找\n\n* 因为红黑树是一颗二叉平衡树，并且查找并不会破坏树的平衡，所以查找和二叉平衡树的查找无异。\n\n```\n1、从根节点开始查找，把根节点设置为当前结点；\n2、若当前结点为空，返回NULL；\n3、若当前结点不为空，用当前结点的key跟查找key作比较；\n4、若当前结点key等于查找key，那么该key就是查找目标，返回当前结点； \n5、若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2； \n6、若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；\n```\n\n![](/images/pasted-28.png)\n\n# 红黑树的删除\n\n* 删除时先作为普通二叉树进行删除：\n\n```\n1、若删除结点无子结点，直接删除。\n2、若删除结点只有一个子结点，用子结点替换删除结点。\n3、若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点。（回到1和2）\n```\n\n* \t寻找前继结点和后继结点的方法：将二叉树所有结点投射到X轴上，所有结点都是从左到右排序的，所有目标结点的前后结点就是对应前继和后继结点。\n\n![](/images/pasted-29.png)\n\n* 我们在删除红黑树结点时是先将他作为普通的二叉搜索树进行操作的，我们将结点删除后，再进行变色，避免同时操作时发生混乱。\n\n\n![](/images/pasted-30.png)\n\n* 在删除结点时，我们可以将单一的结点树进行操作，而将未进行操作的树保留在一旁；整个的删除过程全部满足红黑树本身的五条性质，也就是说在变换过程中，对红黑树的一切操作都是为了让整个红黑树删除结点后依旧满足红黑树的性质。","slug":"红黑树的删除和变色","published":0,"updated":"2020-05-28T14:17:59.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17t000svcu9e8hh8n0t","content":"<h1 id=\"二叉搜索树和红黑树简介\"><a href=\"#二叉搜索树和红黑树简介\" class=\"headerlink\" title=\"二叉搜索树和红黑树简介\"></a>二叉搜索树和红黑树简介</h1><ul>\n<li>二叉搜索树：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二叉搜索树是一种节点值之间具有一定数量级次序的二叉树</span><br><span class=\"line\">对于树中的每个节点：如果存在左子树，则左子树的值小于根节点的值</span><br><span class=\"line\">如果存在右子树，则右子树的值一定大于根节点的值</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>红黑树：自平衡的二叉搜索树。</li>\n</ul>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">性质1：每个节点要么是黑色，要么是红色。 </span><br><span class=\"line\">性质2：根节点是黑色。 </span><br><span class=\"line\">性质3：每个叶子节点（NIL）是黑色。 </span><br><span class=\"line\">性质4：每个红色结点的两个子结点一定都是黑色。 </span><br><span class=\"line\">性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"红黑树的自平衡\"><a href=\"#红黑树的自平衡\" class=\"headerlink\" title=\"红黑树的自平衡\"></a>红黑树的自平衡</h1><ul>\n<li>自平衡的三种操作：左旋、右旋和变色</li>\n<li>左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子节点，左子结点不变。</li>\n<li>右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</li>\n<li>变色：结点颜色由红变黑或者由黑变红。</li>\n</ul>\n<p><img src=\"/images/pasted-26.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-27.png\" alt=\"\"></p>\n<ul>\n<li>红黑树左旋/右旋的实际操作意义：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪。</span><br><span class=\"line\">&lt;2&gt; 右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪。</span><br><span class=\"line\">&lt;3&gt; 所以旋转操作是局部的。旋转保持红黑树平衡的端详：当一边子树的结点少了，那么向另外一边子树“借”一\t些结点；当一边的子树的结点多了，那么向另外一边子树“租”一些结点。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"红黑树的查找\"><a href=\"#红黑树的查找\" class=\"headerlink\" title=\"红黑树的查找\"></a>红黑树的查找</h1><ul>\n<li>因为红黑树是一颗二叉平衡树，并且查找并不会破坏树的平衡，所以查找和二叉平衡树的查找无异。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、从根节点开始查找，把根节点设置为当前结点；</span><br><span class=\"line\">2、若当前结点为空，返回NULL；</span><br><span class=\"line\">3、若当前结点不为空，用当前结点的key跟查找key作比较；</span><br><span class=\"line\">4、若当前结点key等于查找key，那么该key就是查找目标，返回当前结点； </span><br><span class=\"line\">5、若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2； </span><br><span class=\"line\">6、若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/pasted-28.png\" alt=\"\"></p>\n<h1 id=\"红黑树的删除\"><a href=\"#红黑树的删除\" class=\"headerlink\" title=\"红黑树的删除\"></a>红黑树的删除</h1><ul>\n<li>删除时先作为普通二叉树进行删除：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、若删除结点无子结点，直接删除。</span><br><span class=\"line\">2、若删除结点只有一个子结点，用子结点替换删除结点。</span><br><span class=\"line\">3、若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点。（回到1和2）</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>寻找前继结点和后继结点的方法：将二叉树所有结点投射到X轴上，所有结点都是从左到右排序的，所有目标结点的前后结点就是对应前继和后继结点。</li>\n</ul>\n<p><img src=\"/images/pasted-29.png\" alt=\"\"></p>\n<ul>\n<li>我们在删除红黑树结点时是先将他作为普通的二叉搜索树进行操作的，我们将结点删除后，再进行变色，避免同时操作时发生混乱。</li>\n</ul>\n<p><img src=\"/images/pasted-30.png\" alt=\"\"></p>\n<ul>\n<li>在删除结点时，我们可以将单一的结点树进行操作，而将未进行操作的树保留在一旁；整个的删除过程全部满足红黑树本身的五条性质，也就是说在变换过程中，对红黑树的一切操作都是为了让整个红黑树删除结点后依旧满足红黑树的性质。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"二叉搜索树和红黑树简介\"><a href=\"#二叉搜索树和红黑树简介\" class=\"headerlink\" title=\"二叉搜索树和红黑树简介\"></a>二叉搜索树和红黑树简介</h1><ul>\n<li>二叉搜索树：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二叉搜索树是一种节点值之间具有一定数量级次序的二叉树</span><br><span class=\"line\">对于树中的每个节点：如果存在左子树，则左子树的值小于根节点的值</span><br><span class=\"line\">如果存在右子树，则右子树的值一定大于根节点的值</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>红黑树：自平衡的二叉搜索树。</li>\n</ul>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">性质1：每个节点要么是黑色，要么是红色。 </span><br><span class=\"line\">性质2：根节点是黑色。 </span><br><span class=\"line\">性质3：每个叶子节点（NIL）是黑色。 </span><br><span class=\"line\">性质4：每个红色结点的两个子结点一定都是黑色。 </span><br><span class=\"line\">性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"红黑树的自平衡\"><a href=\"#红黑树的自平衡\" class=\"headerlink\" title=\"红黑树的自平衡\"></a>红黑树的自平衡</h1><ul>\n<li>自平衡的三种操作：左旋、右旋和变色</li>\n<li>左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子节点，左子结点不变。</li>\n<li>右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</li>\n<li>变色：结点颜色由红变黑或者由黑变红。</li>\n</ul>\n<p><img src=\"/images/pasted-26.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-27.png\" alt=\"\"></p>\n<ul>\n<li>红黑树左旋/右旋的实际操作意义：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪。</span><br><span class=\"line\">&lt;2&gt; 右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪。</span><br><span class=\"line\">&lt;3&gt; 所以旋转操作是局部的。旋转保持红黑树平衡的端详：当一边子树的结点少了，那么向另外一边子树“借”一\t些结点；当一边的子树的结点多了，那么向另外一边子树“租”一些结点。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"红黑树的查找\"><a href=\"#红黑树的查找\" class=\"headerlink\" title=\"红黑树的查找\"></a>红黑树的查找</h1><ul>\n<li>因为红黑树是一颗二叉平衡树，并且查找并不会破坏树的平衡，所以查找和二叉平衡树的查找无异。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、从根节点开始查找，把根节点设置为当前结点；</span><br><span class=\"line\">2、若当前结点为空，返回NULL；</span><br><span class=\"line\">3、若当前结点不为空，用当前结点的key跟查找key作比较；</span><br><span class=\"line\">4、若当前结点key等于查找key，那么该key就是查找目标，返回当前结点； </span><br><span class=\"line\">5、若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2； </span><br><span class=\"line\">6、若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/pasted-28.png\" alt=\"\"></p>\n<h1 id=\"红黑树的删除\"><a href=\"#红黑树的删除\" class=\"headerlink\" title=\"红黑树的删除\"></a>红黑树的删除</h1><ul>\n<li>删除时先作为普通二叉树进行删除：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、若删除结点无子结点，直接删除。</span><br><span class=\"line\">2、若删除结点只有一个子结点，用子结点替换删除结点。</span><br><span class=\"line\">3、若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点。（回到1和2）</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>寻找前继结点和后继结点的方法：将二叉树所有结点投射到X轴上，所有结点都是从左到右排序的，所有目标结点的前后结点就是对应前继和后继结点。</li>\n</ul>\n<p><img src=\"/images/pasted-29.png\" alt=\"\"></p>\n<ul>\n<li>我们在删除红黑树结点时是先将他作为普通的二叉搜索树进行操作的，我们将结点删除后，再进行变色，避免同时操作时发生混乱。</li>\n</ul>\n<p><img src=\"/images/pasted-30.png\" alt=\"\"></p>\n<ul>\n<li>在删除结点时，我们可以将单一的结点树进行操作，而将未进行操作的树保留在一旁；整个的删除过程全部满足红黑树本身的五条性质，也就是说在变换过程中，对红黑树的一切操作都是为了让整个红黑树删除结点后依旧满足红黑树的性质。</li>\n</ul>\n"},{"title":"网鼎杯2020青龙组crypto","author":"人生若只如初见","date":"2020-06-24T01:06:00.000Z","_content":"# Boom\n* IDA打开，发现有三个验证，第一个验证md5值相等，解密得到en5oy,第二个解密三元一次方程，得到x=74,y=68,z=31,第三个解一元二次方程，正整数根x=89127561，得到flag\n\n\n![](/images/pasted-31.png)\n\n\n![](/images/pasted-32.png)\n\n# You raise me up\n\n* sage求离散对数\n* 脚本如下：\n\n```\nimport binascii\nm = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075\nc = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499\nn=2**512\n\na=Mod(m,n)\nb=Mod(c,n)\n\nflag_bin=discrete_log(b,a)\nprint (binascii.unhexlify(hex(flag_bin)[2:].strip(\"L\")))\n```\n\n# easy_ya\n\n* nc每次连接会改变加密方式，直接爆破\n\n\n```\nfrom hashlib import *\nfrom pwn import *\nimport string\nimport itertools\n#context.log_level = \"debug\"\nio = remote(\"39.96.90.217\", \"17497\")\nio.recvuntil(\"= \")\nsuffix = io.recvline().strip().decode(\"utf-8\")\nprint(suffix)\nio.recvuntil(\"openssl_\")\nmode = io.recvuntil(\">\")[:-1].decode(\"utf-8\")\nprint(mode)\npts = itertools.product(string.printable, repeat=4)\nlen = 100**4\ncnt = 0\nfor pt in pts:\n    if cnt % 1000 == 0:\n        print(\"{}%\".format(100*cnt/len))\n    p = \"\".join(list(pt))\n    if mode == \"sha1\":\n        ct = sha1(p.encode()).hexdigest()\n    elif mode == \"sha224\":\n        ct = sha224(p.encode()).hexdigest()\n    elif mode == \"sha256\":\n        ct = sha256(p.encode()).hexdigest()\n    elif mode == \"sha384\":\n        ct = sha384(p.encode()).hexdigest()\n    elif mode == \"sha512\":\n        ct = sha512(p.encode()).hexdigest()\n    elif mode == \"md5\":\n        ct = md5(p.encode()).hexdigest()\n    else:\n        exit(0)\n    if ct[:20] == suffix:\n        print(p)\n        break\n    cnt += 1\nio.interactive()\n\n```\n\n* 提交token之后得到rsa中的n1 c1 n2 c2\n* 找到n1和n2的公约数，侧面分解n1,.n2\n* 解得ek是中文：愿我所爱无忧恙岁长安，根据ek生成规则得到key,算出题目的a,b,c,d\n\n\n* 题目在加密时，每8个字符作为一组，利用该组生成y和z然后对y和z进行运算，返回结果。注意到返回的结果为hex((y << 52) ^ (pads << 20) ^ z)\n* 所以可以知道\n\n```\n\t1.返回结果（视作84位）的前32位是y；\n\t2.返回结果的第33位至第54位为pads的前20位，第55位至第64位为pads的后12位和z的前12位异或的结果。\n```\n    \n* 注意到y和z一共运算了32轮，所以这时pads应该是limit(32*pad)，其后5位是0，所以pads的情况相当于：\n\n```\n????? ******** ******** ****???? ???00000\n```\n\n* 其中 * 代表已知，? 代表未知，0就是0。去掉后边5个0后，另外32位就是pad。\n* 这个pad中，未知的地方只有12位，总计4096种情况，每种情况对应唯一的z。\n* 所以可以通过爆破这4096种情况，逆推32轮得到初始的y和z，再观察其转为字符后是否在string.printable中来确定答案。完整代码如下\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport gmpy2\nfrom libnum import n2s,s2n\nimport string\n\nn1 = 523302236767994199900474363344509016779069116440336509402579663927023212822016176967224920257215697515649639915194389392664393435704126520500342935380422629852958893595198501678886910437288107490865842806189885864227955305292596726620737250011643028592306930279653650874633693082819617471411085797465171317473575199984137570425840763157847215554005503026976635376775672263338018024842152016782550728415532850496820668169596712488535626476321971915772540785626943870257914929277013026283202706480202573253694027965561121582254805059775814137542861056288774182091519461752761702279929984980399296157122817271523455097901334302748985253698791419583126820263035649222528798493821648538568572195005358978375666451378629463679501572550304224399031869931606326980885244883575380615433423693907673692911481956161922234589747374211957098461625670478121184734721478951324090304946630772999533103517416951906651316589244984076827527352185687877958699658011472950078992791104307370649334689901210147765149584862868749574640976109508247204313701721196275177445231013673265642224568068643851710967790673640935447579098048865343477978938147696617434878198467680874826616766904653374028721826187308127128623535689512750830887981058826202565202400511\nc1 = 498116479126828060721351777093052860074248131123861633687756928866328288114135612849582257727497809922257024131348207980532057240060103798568227977564521497134127080257805342446192248133124844549442334197110567598270256443362563074473166503647429611051333058467042150637666479765740465760837773368463067714839472516227071241189038004851446423799255357523722335018334006275302424683874359612832738469924300750750078529793617519763670882091967677827342326944222743651042579235831828367996040140715066967834876505105847352068608085060284716208922782057542541292881761158407247706056426656079240060590899310402168208571288608455268870805780135942398347873755131825844602660879197979908250552518202142180574849619997871142575611493295891685289794234943270549985371377356916876993228441993132176346052582480841840804748103391892367360829385946406970449784716173650039815882209635063166095389007982620077884907738945623441531598991729082106049943909989119158441101967074276580858829052824691525753913860208906309655761578594225039981683717544420716889594252263165426914121554799496094906541367521362681696570717997925590955291849918357945303214885384216817697786187947817980231717851370305526120464677525392225631245022522492166336294567990\nn2 = 536990588699972595171044696252776619032179414787125154102250364726703105272855466989014009336094247702108918440942171080587326115929077717421949560294869471182366684971337895133599697112193778007924450399107079732471847945598232349103839178632745959014098099259478108015237884846605377823461726458684486899249980041743056079896277510838968230729745020510029386228057731944169220820085059789541971092769832034181463596023438597531006332700648910769750936607476390311140301912742677001065893470340950419360642998700303488716826766066363262819042158064398656956185348135880225267894029419814797931720405594656777311094389676998338309809990367862926139317751409984908306801799152005179724137997626023826392780245630698648023945119617679627945415398046106871715475183890738417311925747430222040725394347022734489930069712092197629163647317772330355887387543008085150959104427391942023985298997288368357638062454066636100000548473809891299732343069825793293706407805782587150123342081839983609199059401502925783039760450730519603070519136086703825438807058787688044991172737575437559249668471352046085614345186161595152256193672994722540039920217058451215889862638946510188311582046866299423997659515395934871167522463706085186962242421859\nc2 = 164402111514416870480151927449107349163820084533580709383993929301187569338852498622073106678649496858117593538947720740640339668153033620409471744700183709591276280704323985437330452541949262852531710176243561888397374683972759177181684560891529123569371241980602358823138808014488471284855401456011020109937046905434967828616466812821052222924691090808870700970795942705766163862790406417148540210339722273902825469460099520769061522024042123766536620554426683612099219790921573403278241760344418925630823806366949039901279532624187976211611528860461687073096888450694175459321193571925480949635977079339284905452476161156840739751431793628217796061271713787710176980187083301171958573364765677389306720995362317264018186392366551999368657422142163919262968449796794407119199996178284891867472060688293602896147398028717874542567143635071645595076767066361989345197270110842062044509038468406120271061465308775126927579741460684420290619983532930017201223504143911140388202527374930493248620993306321032961537876323380443523093814730204234290659449391857198796743587265894069493376291713198073023178977070834614584650913597763729414655680380751407408769289343905637501434637829997447542901620528323133332447667258731683700542347651\np = gmpy2.gcd(n1, n2)\nq1 = n1 // p\nq2 = n2 // p\ne = 0x10001\nphi1 = (p-1)*(q1-1)\nd1 = gmpy2.invert(e, phi1)\nm = pow(c1, d1, n1)\nek = n2s(m)\n\nkey = '8891898088b197a0bfa78199b28195bfae89'.decode('hex')\nlimit = lambda n: n & 0xffffffff\n\nKey  = [ord(i) for i in key]\na = limit((Key[0] << 24) | (Key[1] << 16) | (Key[2] << 8) | Key[3])\nb = limit((Key[4] << 24) | (Key[5] << 16) | (Key[6] << 8) | Key[7])\nc = limit((Key[8] << 24) | (Key[9] << 16) | (Key[10] << 8) | Key[11])\nd = limit((Key[12] << 24) | (Key[13] << 16) | (Key[14] << 8) | Key[15])\n\noutputs = [0x65d4ce3b0b1b3f48bb9fdL, 0xf0230f43414a9c9ac0488L, 0xbd592ebe04025b783fb5bL, 0x28d194dcd1c79b4bb8074L, 0x7c493be8f0fdbb740ec29L]\n\ndef reversecalc(a, b, c, d, y, z, pad):\n    for i in range(32, 0, -1):\n        # print 'Round %d: %d, %d' % (i, y, z)\n        pads = limit(pad * i)\n        paramz = (y*16+c)^(y+pads)^((y>>5)+d)\n        if(z < paramz):\n            z = limit(z - paramz + 0x100000000)\n        else:\n            z = limit(z - paramz)\n        paramy = (z*16+a)^(z+pads)^((z>>5)+b)\n        if(y < paramy):\n            y = limit(y - paramy + 0x100000000)\n        else:\n            y = limit(y - paramy)\n        # print (y, z)\n    return y, z\n\nfor output in outputs:\n    print hex(output)\n    binout = bin(output)[2:]\n    binout = '0'*(84-len(binout))+binout\n    y = int(binout[:32], 2)\n    for i in range(4096):\n        bini = bin(i)[2:]\n        bini = '0'*(12-len(bini))+bini\n        tmpbinpads = bini[0:5] + binout[32:52] + bini[5:12] + '00000'\n        pad = int(tmpbinpads, 2) / 32\n        pads = limit(int(tmpbinpads, 2))\n        z = output ^ (y<<52) ^ (pads<<20)\n        y0, z0 = reversecalc(a, b, c, d, y, z, pad)\n        tmpstr = n2s(y0)+n2s(z0)\n        valid = True\n        for j in tmpstr:\n            if (not j in string.printable)and(j != '\\x00'):\n                valid = False\n                break\n        if(valid):\n            print tmpstr\n```\n\n* 输出结果：\n\n```\n0x65d4ce3b0b1b3f48bb9fdL\nS60 '\\M(\nflag{5fe\n0xf0230f43414a9c9ac0488L\n86c73a3e\n0xbd592ebe04025b783fb5bL\nUs\nNU\\KNP-F\n381ee168\n0x28d194dcd1c79b4bb8074L\n)^C04<b5\nZ\"N*'U_x000C_=\n83c04451\nGNM1!Uyl\n0x7c493be8f0fdbb740ec29L\n9o`YE\n1356f}\nQG_x000C_rVHZo\n7ju-px/_x000C\n```\n\n* 寻找其中看起来像的拼接得到flag\n\n\n","source":"_drafts/网鼎杯2020青龙组crypto.md","raw":"title: 网鼎杯2020青龙组crypto\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - ctf\ndate: 2020-06-24 09:06:00\n---\n# Boom\n* IDA打开，发现有三个验证，第一个验证md5值相等，解密得到en5oy,第二个解密三元一次方程，得到x=74,y=68,z=31,第三个解一元二次方程，正整数根x=89127561，得到flag\n\n\n![](/images/pasted-31.png)\n\n\n![](/images/pasted-32.png)\n\n# You raise me up\n\n* sage求离散对数\n* 脚本如下：\n\n```\nimport binascii\nm = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075\nc = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499\nn=2**512\n\na=Mod(m,n)\nb=Mod(c,n)\n\nflag_bin=discrete_log(b,a)\nprint (binascii.unhexlify(hex(flag_bin)[2:].strip(\"L\")))\n```\n\n# easy_ya\n\n* nc每次连接会改变加密方式，直接爆破\n\n\n```\nfrom hashlib import *\nfrom pwn import *\nimport string\nimport itertools\n#context.log_level = \"debug\"\nio = remote(\"39.96.90.217\", \"17497\")\nio.recvuntil(\"= \")\nsuffix = io.recvline().strip().decode(\"utf-8\")\nprint(suffix)\nio.recvuntil(\"openssl_\")\nmode = io.recvuntil(\">\")[:-1].decode(\"utf-8\")\nprint(mode)\npts = itertools.product(string.printable, repeat=4)\nlen = 100**4\ncnt = 0\nfor pt in pts:\n    if cnt % 1000 == 0:\n        print(\"{}%\".format(100*cnt/len))\n    p = \"\".join(list(pt))\n    if mode == \"sha1\":\n        ct = sha1(p.encode()).hexdigest()\n    elif mode == \"sha224\":\n        ct = sha224(p.encode()).hexdigest()\n    elif mode == \"sha256\":\n        ct = sha256(p.encode()).hexdigest()\n    elif mode == \"sha384\":\n        ct = sha384(p.encode()).hexdigest()\n    elif mode == \"sha512\":\n        ct = sha512(p.encode()).hexdigest()\n    elif mode == \"md5\":\n        ct = md5(p.encode()).hexdigest()\n    else:\n        exit(0)\n    if ct[:20] == suffix:\n        print(p)\n        break\n    cnt += 1\nio.interactive()\n\n```\n\n* 提交token之后得到rsa中的n1 c1 n2 c2\n* 找到n1和n2的公约数，侧面分解n1,.n2\n* 解得ek是中文：愿我所爱无忧恙岁长安，根据ek生成规则得到key,算出题目的a,b,c,d\n\n\n* 题目在加密时，每8个字符作为一组，利用该组生成y和z然后对y和z进行运算，返回结果。注意到返回的结果为hex((y << 52) ^ (pads << 20) ^ z)\n* 所以可以知道\n\n```\n\t1.返回结果（视作84位）的前32位是y；\n\t2.返回结果的第33位至第54位为pads的前20位，第55位至第64位为pads的后12位和z的前12位异或的结果。\n```\n    \n* 注意到y和z一共运算了32轮，所以这时pads应该是limit(32*pad)，其后5位是0，所以pads的情况相当于：\n\n```\n????? ******** ******** ****???? ???00000\n```\n\n* 其中 * 代表已知，? 代表未知，0就是0。去掉后边5个0后，另外32位就是pad。\n* 这个pad中，未知的地方只有12位，总计4096种情况，每种情况对应唯一的z。\n* 所以可以通过爆破这4096种情况，逆推32轮得到初始的y和z，再观察其转为字符后是否在string.printable中来确定答案。完整代码如下\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport gmpy2\nfrom libnum import n2s,s2n\nimport string\n\nn1 = 523302236767994199900474363344509016779069116440336509402579663927023212822016176967224920257215697515649639915194389392664393435704126520500342935380422629852958893595198501678886910437288107490865842806189885864227955305292596726620737250011643028592306930279653650874633693082819617471411085797465171317473575199984137570425840763157847215554005503026976635376775672263338018024842152016782550728415532850496820668169596712488535626476321971915772540785626943870257914929277013026283202706480202573253694027965561121582254805059775814137542861056288774182091519461752761702279929984980399296157122817271523455097901334302748985253698791419583126820263035649222528798493821648538568572195005358978375666451378629463679501572550304224399031869931606326980885244883575380615433423693907673692911481956161922234589747374211957098461625670478121184734721478951324090304946630772999533103517416951906651316589244984076827527352185687877958699658011472950078992791104307370649334689901210147765149584862868749574640976109508247204313701721196275177445231013673265642224568068643851710967790673640935447579098048865343477978938147696617434878198467680874826616766904653374028721826187308127128623535689512750830887981058826202565202400511\nc1 = 498116479126828060721351777093052860074248131123861633687756928866328288114135612849582257727497809922257024131348207980532057240060103798568227977564521497134127080257805342446192248133124844549442334197110567598270256443362563074473166503647429611051333058467042150637666479765740465760837773368463067714839472516227071241189038004851446423799255357523722335018334006275302424683874359612832738469924300750750078529793617519763670882091967677827342326944222743651042579235831828367996040140715066967834876505105847352068608085060284716208922782057542541292881761158407247706056426656079240060590899310402168208571288608455268870805780135942398347873755131825844602660879197979908250552518202142180574849619997871142575611493295891685289794234943270549985371377356916876993228441993132176346052582480841840804748103391892367360829385946406970449784716173650039815882209635063166095389007982620077884907738945623441531598991729082106049943909989119158441101967074276580858829052824691525753913860208906309655761578594225039981683717544420716889594252263165426914121554799496094906541367521362681696570717997925590955291849918357945303214885384216817697786187947817980231717851370305526120464677525392225631245022522492166336294567990\nn2 = 536990588699972595171044696252776619032179414787125154102250364726703105272855466989014009336094247702108918440942171080587326115929077717421949560294869471182366684971337895133599697112193778007924450399107079732471847945598232349103839178632745959014098099259478108015237884846605377823461726458684486899249980041743056079896277510838968230729745020510029386228057731944169220820085059789541971092769832034181463596023438597531006332700648910769750936607476390311140301912742677001065893470340950419360642998700303488716826766066363262819042158064398656956185348135880225267894029419814797931720405594656777311094389676998338309809990367862926139317751409984908306801799152005179724137997626023826392780245630698648023945119617679627945415398046106871715475183890738417311925747430222040725394347022734489930069712092197629163647317772330355887387543008085150959104427391942023985298997288368357638062454066636100000548473809891299732343069825793293706407805782587150123342081839983609199059401502925783039760450730519603070519136086703825438807058787688044991172737575437559249668471352046085614345186161595152256193672994722540039920217058451215889862638946510188311582046866299423997659515395934871167522463706085186962242421859\nc2 = 164402111514416870480151927449107349163820084533580709383993929301187569338852498622073106678649496858117593538947720740640339668153033620409471744700183709591276280704323985437330452541949262852531710176243561888397374683972759177181684560891529123569371241980602358823138808014488471284855401456011020109937046905434967828616466812821052222924691090808870700970795942705766163862790406417148540210339722273902825469460099520769061522024042123766536620554426683612099219790921573403278241760344418925630823806366949039901279532624187976211611528860461687073096888450694175459321193571925480949635977079339284905452476161156840739751431793628217796061271713787710176980187083301171958573364765677389306720995362317264018186392366551999368657422142163919262968449796794407119199996178284891867472060688293602896147398028717874542567143635071645595076767066361989345197270110842062044509038468406120271061465308775126927579741460684420290619983532930017201223504143911140388202527374930493248620993306321032961537876323380443523093814730204234290659449391857198796743587265894069493376291713198073023178977070834614584650913597763729414655680380751407408769289343905637501434637829997447542901620528323133332447667258731683700542347651\np = gmpy2.gcd(n1, n2)\nq1 = n1 // p\nq2 = n2 // p\ne = 0x10001\nphi1 = (p-1)*(q1-1)\nd1 = gmpy2.invert(e, phi1)\nm = pow(c1, d1, n1)\nek = n2s(m)\n\nkey = '8891898088b197a0bfa78199b28195bfae89'.decode('hex')\nlimit = lambda n: n & 0xffffffff\n\nKey  = [ord(i) for i in key]\na = limit((Key[0] << 24) | (Key[1] << 16) | (Key[2] << 8) | Key[3])\nb = limit((Key[4] << 24) | (Key[5] << 16) | (Key[6] << 8) | Key[7])\nc = limit((Key[8] << 24) | (Key[9] << 16) | (Key[10] << 8) | Key[11])\nd = limit((Key[12] << 24) | (Key[13] << 16) | (Key[14] << 8) | Key[15])\n\noutputs = [0x65d4ce3b0b1b3f48bb9fdL, 0xf0230f43414a9c9ac0488L, 0xbd592ebe04025b783fb5bL, 0x28d194dcd1c79b4bb8074L, 0x7c493be8f0fdbb740ec29L]\n\ndef reversecalc(a, b, c, d, y, z, pad):\n    for i in range(32, 0, -1):\n        # print 'Round %d: %d, %d' % (i, y, z)\n        pads = limit(pad * i)\n        paramz = (y*16+c)^(y+pads)^((y>>5)+d)\n        if(z < paramz):\n            z = limit(z - paramz + 0x100000000)\n        else:\n            z = limit(z - paramz)\n        paramy = (z*16+a)^(z+pads)^((z>>5)+b)\n        if(y < paramy):\n            y = limit(y - paramy + 0x100000000)\n        else:\n            y = limit(y - paramy)\n        # print (y, z)\n    return y, z\n\nfor output in outputs:\n    print hex(output)\n    binout = bin(output)[2:]\n    binout = '0'*(84-len(binout))+binout\n    y = int(binout[:32], 2)\n    for i in range(4096):\n        bini = bin(i)[2:]\n        bini = '0'*(12-len(bini))+bini\n        tmpbinpads = bini[0:5] + binout[32:52] + bini[5:12] + '00000'\n        pad = int(tmpbinpads, 2) / 32\n        pads = limit(int(tmpbinpads, 2))\n        z = output ^ (y<<52) ^ (pads<<20)\n        y0, z0 = reversecalc(a, b, c, d, y, z, pad)\n        tmpstr = n2s(y0)+n2s(z0)\n        valid = True\n        for j in tmpstr:\n            if (not j in string.printable)and(j != '\\x00'):\n                valid = False\n                break\n        if(valid):\n            print tmpstr\n```\n\n* 输出结果：\n\n```\n0x65d4ce3b0b1b3f48bb9fdL\nS60 '\\M(\nflag{5fe\n0xf0230f43414a9c9ac0488L\n86c73a3e\n0xbd592ebe04025b783fb5bL\nUs\nNU\\KNP-F\n381ee168\n0x28d194dcd1c79b4bb8074L\n)^C04<b5\nZ\"N*'U_x000C_=\n83c04451\nGNM1!Uyl\n0x7c493be8f0fdbb740ec29L\n9o`YE\n1356f}\nQG_x000C_rVHZo\n7ju-px/_x000C\n```\n\n* 寻找其中看起来像的拼接得到flag\n\n\n","slug":"网鼎杯2020青龙组crypto","published":0,"updated":"2020-06-24T01:16:23.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r17u000uvcu9268r8exx","content":"<h1 id=\"Boom\"><a href=\"#Boom\" class=\"headerlink\" title=\"Boom\"></a>Boom</h1><ul>\n<li>IDA打开，发现有三个验证，第一个验证md5值相等，解密得到en5oy,第二个解密三元一次方程，得到x=74,y=68,z=31,第三个解一元二次方程，正整数根x=89127561，得到flag</li>\n</ul>\n<p><img src=\"/images/pasted-31.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-32.png\" alt=\"\"></p>\n<h1 id=\"You-raise-me-up\"><a href=\"#You-raise-me-up\" class=\"headerlink\" title=\"You raise me up\"></a>You raise me up</h1><ul>\n<li>sage求离散对数</li>\n<li>脚本如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import binascii</span><br><span class=\"line\">m &#x3D; 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075</span><br><span class=\"line\">c &#x3D; 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499</span><br><span class=\"line\">n&#x3D;2**512</span><br><span class=\"line\"></span><br><span class=\"line\">a&#x3D;Mod(m,n)</span><br><span class=\"line\">b&#x3D;Mod(c,n)</span><br><span class=\"line\"></span><br><span class=\"line\">flag_bin&#x3D;discrete_log(b,a)</span><br><span class=\"line\">print (binascii.unhexlify(hex(flag_bin)[2:].strip(&quot;L&quot;)))</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"easy-ya\"><a href=\"#easy-ya\" class=\"headerlink\" title=\"easy_ya\"></a>easy_ya</h1><ul>\n<li>nc每次连接会改变加密方式，直接爆破</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from hashlib import *</span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\">import string</span><br><span class=\"line\">import itertools</span><br><span class=\"line\">#context.log_level &#x3D; &quot;debug&quot;</span><br><span class=\"line\">io &#x3D; remote(&quot;39.96.90.217&quot;, &quot;17497&quot;)</span><br><span class=\"line\">io.recvuntil(&quot;&#x3D; &quot;)</span><br><span class=\"line\">suffix &#x3D; io.recvline().strip().decode(&quot;utf-8&quot;)</span><br><span class=\"line\">print(suffix)</span><br><span class=\"line\">io.recvuntil(&quot;openssl_&quot;)</span><br><span class=\"line\">mode &#x3D; io.recvuntil(&quot;&gt;&quot;)[:-1].decode(&quot;utf-8&quot;)</span><br><span class=\"line\">print(mode)</span><br><span class=\"line\">pts &#x3D; itertools.product(string.printable, repeat&#x3D;4)</span><br><span class=\"line\">len &#x3D; 100**4</span><br><span class=\"line\">cnt &#x3D; 0</span><br><span class=\"line\">for pt in pts:</span><br><span class=\"line\">    if cnt % 1000 &#x3D;&#x3D; 0:</span><br><span class=\"line\">        print(&quot;&#123;&#125;%&quot;.format(100*cnt&#x2F;len))</span><br><span class=\"line\">    p &#x3D; &quot;&quot;.join(list(pt))</span><br><span class=\"line\">    if mode &#x3D;&#x3D; &quot;sha1&quot;:</span><br><span class=\"line\">        ct &#x3D; sha1(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha224&quot;:</span><br><span class=\"line\">        ct &#x3D; sha224(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha256&quot;:</span><br><span class=\"line\">        ct &#x3D; sha256(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha384&quot;:</span><br><span class=\"line\">        ct &#x3D; sha384(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha512&quot;:</span><br><span class=\"line\">        ct &#x3D; sha512(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;md5&quot;:</span><br><span class=\"line\">        ct &#x3D; md5(p.encode()).hexdigest()</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        exit(0)</span><br><span class=\"line\">    if ct[:20] &#x3D;&#x3D; suffix:</span><br><span class=\"line\">        print(p)</span><br><span class=\"line\">        break</span><br><span class=\"line\">    cnt +&#x3D; 1</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提交token之后得到rsa中的n1 c1 n2 c2</li>\n<li>找到n1和n2的公约数，侧面分解n1,.n2</li>\n<li>解得ek是中文：愿我所爱无忧恙岁长安，根据ek生成规则得到key,算出题目的a,b,c,d</li>\n</ul>\n<ul>\n<li>题目在加密时，每8个字符作为一组，利用该组生成y和z然后对y和z进行运算，返回结果。注意到返回的结果为hex((y &lt;&lt; 52) ^ (pads &lt;&lt; 20) ^ z)</li>\n<li>所以可以知道</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.返回结果（视作84位）的前32位是y；</span><br><span class=\"line\">2.返回结果的第33位至第54位为pads的前20位，第55位至第64位为pads的后12位和z的前12位异或的结果。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意到y和z一共运算了32轮，所以这时pads应该是limit(32*pad)，其后5位是0，所以pads的情况相当于：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">????? ******** ******** ****???? ???00000</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其中 * 代表已知，? 代表未知，0就是0。去掉后边5个0后，另外32位就是pad。</li>\n<li>这个pad中，未知的地方只有12位，总计4096种情况，每种情况对应唯一的z。</li>\n<li>所以可以通过爆破这4096种情况，逆推32轮得到初始的y和z，再观察其转为字符后是否在string.printable中来确定答案。完整代码如下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">import gmpy2</span><br><span class=\"line\">from libnum import n2s,s2n</span><br><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">n1 &#x3D; 523302236767994199900474363344509016779069116440336509402579663927023212822016176967224920257215697515649639915194389392664393435704126520500342935380422629852958893595198501678886910437288107490865842806189885864227955305292596726620737250011643028592306930279653650874633693082819617471411085797465171317473575199984137570425840763157847215554005503026976635376775672263338018024842152016782550728415532850496820668169596712488535626476321971915772540785626943870257914929277013026283202706480202573253694027965561121582254805059775814137542861056288774182091519461752761702279929984980399296157122817271523455097901334302748985253698791419583126820263035649222528798493821648538568572195005358978375666451378629463679501572550304224399031869931606326980885244883575380615433423693907673692911481956161922234589747374211957098461625670478121184734721478951324090304946630772999533103517416951906651316589244984076827527352185687877958699658011472950078992791104307370649334689901210147765149584862868749574640976109508247204313701721196275177445231013673265642224568068643851710967790673640935447579098048865343477978938147696617434878198467680874826616766904653374028721826187308127128623535689512750830887981058826202565202400511</span><br><span class=\"line\">c1 &#x3D; 498116479126828060721351777093052860074248131123861633687756928866328288114135612849582257727497809922257024131348207980532057240060103798568227977564521497134127080257805342446192248133124844549442334197110567598270256443362563074473166503647429611051333058467042150637666479765740465760837773368463067714839472516227071241189038004851446423799255357523722335018334006275302424683874359612832738469924300750750078529793617519763670882091967677827342326944222743651042579235831828367996040140715066967834876505105847352068608085060284716208922782057542541292881761158407247706056426656079240060590899310402168208571288608455268870805780135942398347873755131825844602660879197979908250552518202142180574849619997871142575611493295891685289794234943270549985371377356916876993228441993132176346052582480841840804748103391892367360829385946406970449784716173650039815882209635063166095389007982620077884907738945623441531598991729082106049943909989119158441101967074276580858829052824691525753913860208906309655761578594225039981683717544420716889594252263165426914121554799496094906541367521362681696570717997925590955291849918357945303214885384216817697786187947817980231717851370305526120464677525392225631245022522492166336294567990</span><br><span class=\"line\">n2 &#x3D; 536990588699972595171044696252776619032179414787125154102250364726703105272855466989014009336094247702108918440942171080587326115929077717421949560294869471182366684971337895133599697112193778007924450399107079732471847945598232349103839178632745959014098099259478108015237884846605377823461726458684486899249980041743056079896277510838968230729745020510029386228057731944169220820085059789541971092769832034181463596023438597531006332700648910769750936607476390311140301912742677001065893470340950419360642998700303488716826766066363262819042158064398656956185348135880225267894029419814797931720405594656777311094389676998338309809990367862926139317751409984908306801799152005179724137997626023826392780245630698648023945119617679627945415398046106871715475183890738417311925747430222040725394347022734489930069712092197629163647317772330355887387543008085150959104427391942023985298997288368357638062454066636100000548473809891299732343069825793293706407805782587150123342081839983609199059401502925783039760450730519603070519136086703825438807058787688044991172737575437559249668471352046085614345186161595152256193672994722540039920217058451215889862638946510188311582046866299423997659515395934871167522463706085186962242421859</span><br><span class=\"line\">c2 &#x3D; 164402111514416870480151927449107349163820084533580709383993929301187569338852498622073106678649496858117593538947720740640339668153033620409471744700183709591276280704323985437330452541949262852531710176243561888397374683972759177181684560891529123569371241980602358823138808014488471284855401456011020109937046905434967828616466812821052222924691090808870700970795942705766163862790406417148540210339722273902825469460099520769061522024042123766536620554426683612099219790921573403278241760344418925630823806366949039901279532624187976211611528860461687073096888450694175459321193571925480949635977079339284905452476161156840739751431793628217796061271713787710176980187083301171958573364765677389306720995362317264018186392366551999368657422142163919262968449796794407119199996178284891867472060688293602896147398028717874542567143635071645595076767066361989345197270110842062044509038468406120271061465308775126927579741460684420290619983532930017201223504143911140388202527374930493248620993306321032961537876323380443523093814730204234290659449391857198796743587265894069493376291713198073023178977070834614584650913597763729414655680380751407408769289343905637501434637829997447542901620528323133332447667258731683700542347651</span><br><span class=\"line\">p &#x3D; gmpy2.gcd(n1, n2)</span><br><span class=\"line\">q1 &#x3D; n1 &#x2F;&#x2F; p</span><br><span class=\"line\">q2 &#x3D; n2 &#x2F;&#x2F; p</span><br><span class=\"line\">e &#x3D; 0x10001</span><br><span class=\"line\">phi1 &#x3D; (p-1)*(q1-1)</span><br><span class=\"line\">d1 &#x3D; gmpy2.invert(e, phi1)</span><br><span class=\"line\">m &#x3D; pow(c1, d1, n1)</span><br><span class=\"line\">ek &#x3D; n2s(m)</span><br><span class=\"line\"></span><br><span class=\"line\">key &#x3D; &#39;8891898088b197a0bfa78199b28195bfae89&#39;.decode(&#39;hex&#39;)</span><br><span class=\"line\">limit &#x3D; lambda n: n &amp; 0xffffffff</span><br><span class=\"line\"></span><br><span class=\"line\">Key  &#x3D; [ord(i) for i in key]</span><br><span class=\"line\">a &#x3D; limit((Key[0] &lt;&lt; 24) | (Key[1] &lt;&lt; 16) | (Key[2] &lt;&lt; 8) | Key[3])</span><br><span class=\"line\">b &#x3D; limit((Key[4] &lt;&lt; 24) | (Key[5] &lt;&lt; 16) | (Key[6] &lt;&lt; 8) | Key[7])</span><br><span class=\"line\">c &#x3D; limit((Key[8] &lt;&lt; 24) | (Key[9] &lt;&lt; 16) | (Key[10] &lt;&lt; 8) | Key[11])</span><br><span class=\"line\">d &#x3D; limit((Key[12] &lt;&lt; 24) | (Key[13] &lt;&lt; 16) | (Key[14] &lt;&lt; 8) | Key[15])</span><br><span class=\"line\"></span><br><span class=\"line\">outputs &#x3D; [0x65d4ce3b0b1b3f48bb9fdL, 0xf0230f43414a9c9ac0488L, 0xbd592ebe04025b783fb5bL, 0x28d194dcd1c79b4bb8074L, 0x7c493be8f0fdbb740ec29L]</span><br><span class=\"line\"></span><br><span class=\"line\">def reversecalc(a, b, c, d, y, z, pad):</span><br><span class=\"line\">    for i in range(32, 0, -1):</span><br><span class=\"line\">        # print &#39;Round %d: %d, %d&#39; % (i, y, z)</span><br><span class=\"line\">        pads &#x3D; limit(pad * i)</span><br><span class=\"line\">        paramz &#x3D; (y*16+c)^(y+pads)^((y&gt;&gt;5)+d)</span><br><span class=\"line\">        if(z &lt; paramz):</span><br><span class=\"line\">            z &#x3D; limit(z - paramz + 0x100000000)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            z &#x3D; limit(z - paramz)</span><br><span class=\"line\">        paramy &#x3D; (z*16+a)^(z+pads)^((z&gt;&gt;5)+b)</span><br><span class=\"line\">        if(y &lt; paramy):</span><br><span class=\"line\">            y &#x3D; limit(y - paramy + 0x100000000)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y &#x3D; limit(y - paramy)</span><br><span class=\"line\">        # print (y, z)</span><br><span class=\"line\">    return y, z</span><br><span class=\"line\"></span><br><span class=\"line\">for output in outputs:</span><br><span class=\"line\">    print hex(output)</span><br><span class=\"line\">    binout &#x3D; bin(output)[2:]</span><br><span class=\"line\">    binout &#x3D; &#39;0&#39;*(84-len(binout))+binout</span><br><span class=\"line\">    y &#x3D; int(binout[:32], 2)</span><br><span class=\"line\">    for i in range(4096):</span><br><span class=\"line\">        bini &#x3D; bin(i)[2:]</span><br><span class=\"line\">        bini &#x3D; &#39;0&#39;*(12-len(bini))+bini</span><br><span class=\"line\">        tmpbinpads &#x3D; bini[0:5] + binout[32:52] + bini[5:12] + &#39;00000&#39;</span><br><span class=\"line\">        pad &#x3D; int(tmpbinpads, 2) &#x2F; 32</span><br><span class=\"line\">        pads &#x3D; limit(int(tmpbinpads, 2))</span><br><span class=\"line\">        z &#x3D; output ^ (y&lt;&lt;52) ^ (pads&lt;&lt;20)</span><br><span class=\"line\">        y0, z0 &#x3D; reversecalc(a, b, c, d, y, z, pad)</span><br><span class=\"line\">        tmpstr &#x3D; n2s(y0)+n2s(z0)</span><br><span class=\"line\">        valid &#x3D; True</span><br><span class=\"line\">        for j in tmpstr:</span><br><span class=\"line\">            if (not j in string.printable)and(j !&#x3D; &#39;\\x00&#39;):</span><br><span class=\"line\">                valid &#x3D; False</span><br><span class=\"line\">                break</span><br><span class=\"line\">        if(valid):</span><br><span class=\"line\">            print tmpstr</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>输出结果：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x65d4ce3b0b1b3f48bb9fdL</span><br><span class=\"line\">S60 &#39;\\M(</span><br><span class=\"line\">flag&#123;5fe</span><br><span class=\"line\">0xf0230f43414a9c9ac0488L</span><br><span class=\"line\">86c73a3e</span><br><span class=\"line\">0xbd592ebe04025b783fb5bL</span><br><span class=\"line\">Us</span><br><span class=\"line\">NU\\KNP-F</span><br><span class=\"line\">381ee168</span><br><span class=\"line\">0x28d194dcd1c79b4bb8074L</span><br><span class=\"line\">)^C04&lt;b5</span><br><span class=\"line\">Z&quot;N*&#39;U_x000C_&#x3D;</span><br><span class=\"line\">83c04451</span><br><span class=\"line\">GNM1!Uyl</span><br><span class=\"line\">0x7c493be8f0fdbb740ec29L</span><br><span class=\"line\">9o&#96;YE</span><br><span class=\"line\">1356f&#125;</span><br><span class=\"line\">QG_x000C_rVHZo</span><br><span class=\"line\">7ju-px&#x2F;_x000C</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>寻找其中看起来像的拼接得到flag</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Boom\"><a href=\"#Boom\" class=\"headerlink\" title=\"Boom\"></a>Boom</h1><ul>\n<li>IDA打开，发现有三个验证，第一个验证md5值相等，解密得到en5oy,第二个解密三元一次方程，得到x=74,y=68,z=31,第三个解一元二次方程，正整数根x=89127561，得到flag</li>\n</ul>\n<p><img src=\"/images/pasted-31.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-32.png\" alt=\"\"></p>\n<h1 id=\"You-raise-me-up\"><a href=\"#You-raise-me-up\" class=\"headerlink\" title=\"You raise me up\"></a>You raise me up</h1><ul>\n<li>sage求离散对数</li>\n<li>脚本如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import binascii</span><br><span class=\"line\">m &#x3D; 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075</span><br><span class=\"line\">c &#x3D; 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499</span><br><span class=\"line\">n&#x3D;2**512</span><br><span class=\"line\"></span><br><span class=\"line\">a&#x3D;Mod(m,n)</span><br><span class=\"line\">b&#x3D;Mod(c,n)</span><br><span class=\"line\"></span><br><span class=\"line\">flag_bin&#x3D;discrete_log(b,a)</span><br><span class=\"line\">print (binascii.unhexlify(hex(flag_bin)[2:].strip(&quot;L&quot;)))</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"easy-ya\"><a href=\"#easy-ya\" class=\"headerlink\" title=\"easy_ya\"></a>easy_ya</h1><ul>\n<li>nc每次连接会改变加密方式，直接爆破</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from hashlib import *</span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\">import string</span><br><span class=\"line\">import itertools</span><br><span class=\"line\">#context.log_level &#x3D; &quot;debug&quot;</span><br><span class=\"line\">io &#x3D; remote(&quot;39.96.90.217&quot;, &quot;17497&quot;)</span><br><span class=\"line\">io.recvuntil(&quot;&#x3D; &quot;)</span><br><span class=\"line\">suffix &#x3D; io.recvline().strip().decode(&quot;utf-8&quot;)</span><br><span class=\"line\">print(suffix)</span><br><span class=\"line\">io.recvuntil(&quot;openssl_&quot;)</span><br><span class=\"line\">mode &#x3D; io.recvuntil(&quot;&gt;&quot;)[:-1].decode(&quot;utf-8&quot;)</span><br><span class=\"line\">print(mode)</span><br><span class=\"line\">pts &#x3D; itertools.product(string.printable, repeat&#x3D;4)</span><br><span class=\"line\">len &#x3D; 100**4</span><br><span class=\"line\">cnt &#x3D; 0</span><br><span class=\"line\">for pt in pts:</span><br><span class=\"line\">    if cnt % 1000 &#x3D;&#x3D; 0:</span><br><span class=\"line\">        print(&quot;&#123;&#125;%&quot;.format(100*cnt&#x2F;len))</span><br><span class=\"line\">    p &#x3D; &quot;&quot;.join(list(pt))</span><br><span class=\"line\">    if mode &#x3D;&#x3D; &quot;sha1&quot;:</span><br><span class=\"line\">        ct &#x3D; sha1(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha224&quot;:</span><br><span class=\"line\">        ct &#x3D; sha224(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha256&quot;:</span><br><span class=\"line\">        ct &#x3D; sha256(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha384&quot;:</span><br><span class=\"line\">        ct &#x3D; sha384(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha512&quot;:</span><br><span class=\"line\">        ct &#x3D; sha512(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;md5&quot;:</span><br><span class=\"line\">        ct &#x3D; md5(p.encode()).hexdigest()</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        exit(0)</span><br><span class=\"line\">    if ct[:20] &#x3D;&#x3D; suffix:</span><br><span class=\"line\">        print(p)</span><br><span class=\"line\">        break</span><br><span class=\"line\">    cnt +&#x3D; 1</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提交token之后得到rsa中的n1 c1 n2 c2</li>\n<li>找到n1和n2的公约数，侧面分解n1,.n2</li>\n<li>解得ek是中文：愿我所爱无忧恙岁长安，根据ek生成规则得到key,算出题目的a,b,c,d</li>\n</ul>\n<ul>\n<li>题目在加密时，每8个字符作为一组，利用该组生成y和z然后对y和z进行运算，返回结果。注意到返回的结果为hex((y &lt;&lt; 52) ^ (pads &lt;&lt; 20) ^ z)</li>\n<li>所以可以知道</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.返回结果（视作84位）的前32位是y；</span><br><span class=\"line\">2.返回结果的第33位至第54位为pads的前20位，第55位至第64位为pads的后12位和z的前12位异或的结果。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意到y和z一共运算了32轮，所以这时pads应该是limit(32*pad)，其后5位是0，所以pads的情况相当于：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">????? ******** ******** ****???? ???00000</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其中 * 代表已知，? 代表未知，0就是0。去掉后边5个0后，另外32位就是pad。</li>\n<li>这个pad中，未知的地方只有12位，总计4096种情况，每种情况对应唯一的z。</li>\n<li>所以可以通过爆破这4096种情况，逆推32轮得到初始的y和z，再观察其转为字符后是否在string.printable中来确定答案。完整代码如下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">import gmpy2</span><br><span class=\"line\">from libnum import n2s,s2n</span><br><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">n1 &#x3D; 523302236767994199900474363344509016779069116440336509402579663927023212822016176967224920257215697515649639915194389392664393435704126520500342935380422629852958893595198501678886910437288107490865842806189885864227955305292596726620737250011643028592306930279653650874633693082819617471411085797465171317473575199984137570425840763157847215554005503026976635376775672263338018024842152016782550728415532850496820668169596712488535626476321971915772540785626943870257914929277013026283202706480202573253694027965561121582254805059775814137542861056288774182091519461752761702279929984980399296157122817271523455097901334302748985253698791419583126820263035649222528798493821648538568572195005358978375666451378629463679501572550304224399031869931606326980885244883575380615433423693907673692911481956161922234589747374211957098461625670478121184734721478951324090304946630772999533103517416951906651316589244984076827527352185687877958699658011472950078992791104307370649334689901210147765149584862868749574640976109508247204313701721196275177445231013673265642224568068643851710967790673640935447579098048865343477978938147696617434878198467680874826616766904653374028721826187308127128623535689512750830887981058826202565202400511</span><br><span class=\"line\">c1 &#x3D; 498116479126828060721351777093052860074248131123861633687756928866328288114135612849582257727497809922257024131348207980532057240060103798568227977564521497134127080257805342446192248133124844549442334197110567598270256443362563074473166503647429611051333058467042150637666479765740465760837773368463067714839472516227071241189038004851446423799255357523722335018334006275302424683874359612832738469924300750750078529793617519763670882091967677827342326944222743651042579235831828367996040140715066967834876505105847352068608085060284716208922782057542541292881761158407247706056426656079240060590899310402168208571288608455268870805780135942398347873755131825844602660879197979908250552518202142180574849619997871142575611493295891685289794234943270549985371377356916876993228441993132176346052582480841840804748103391892367360829385946406970449784716173650039815882209635063166095389007982620077884907738945623441531598991729082106049943909989119158441101967074276580858829052824691525753913860208906309655761578594225039981683717544420716889594252263165426914121554799496094906541367521362681696570717997925590955291849918357945303214885384216817697786187947817980231717851370305526120464677525392225631245022522492166336294567990</span><br><span class=\"line\">n2 &#x3D; 536990588699972595171044696252776619032179414787125154102250364726703105272855466989014009336094247702108918440942171080587326115929077717421949560294869471182366684971337895133599697112193778007924450399107079732471847945598232349103839178632745959014098099259478108015237884846605377823461726458684486899249980041743056079896277510838968230729745020510029386228057731944169220820085059789541971092769832034181463596023438597531006332700648910769750936607476390311140301912742677001065893470340950419360642998700303488716826766066363262819042158064398656956185348135880225267894029419814797931720405594656777311094389676998338309809990367862926139317751409984908306801799152005179724137997626023826392780245630698648023945119617679627945415398046106871715475183890738417311925747430222040725394347022734489930069712092197629163647317772330355887387543008085150959104427391942023985298997288368357638062454066636100000548473809891299732343069825793293706407805782587150123342081839983609199059401502925783039760450730519603070519136086703825438807058787688044991172737575437559249668471352046085614345186161595152256193672994722540039920217058451215889862638946510188311582046866299423997659515395934871167522463706085186962242421859</span><br><span class=\"line\">c2 &#x3D; 164402111514416870480151927449107349163820084533580709383993929301187569338852498622073106678649496858117593538947720740640339668153033620409471744700183709591276280704323985437330452541949262852531710176243561888397374683972759177181684560891529123569371241980602358823138808014488471284855401456011020109937046905434967828616466812821052222924691090808870700970795942705766163862790406417148540210339722273902825469460099520769061522024042123766536620554426683612099219790921573403278241760344418925630823806366949039901279532624187976211611528860461687073096888450694175459321193571925480949635977079339284905452476161156840739751431793628217796061271713787710176980187083301171958573364765677389306720995362317264018186392366551999368657422142163919262968449796794407119199996178284891867472060688293602896147398028717874542567143635071645595076767066361989345197270110842062044509038468406120271061465308775126927579741460684420290619983532930017201223504143911140388202527374930493248620993306321032961537876323380443523093814730204234290659449391857198796743587265894069493376291713198073023178977070834614584650913597763729414655680380751407408769289343905637501434637829997447542901620528323133332447667258731683700542347651</span><br><span class=\"line\">p &#x3D; gmpy2.gcd(n1, n2)</span><br><span class=\"line\">q1 &#x3D; n1 &#x2F;&#x2F; p</span><br><span class=\"line\">q2 &#x3D; n2 &#x2F;&#x2F; p</span><br><span class=\"line\">e &#x3D; 0x10001</span><br><span class=\"line\">phi1 &#x3D; (p-1)*(q1-1)</span><br><span class=\"line\">d1 &#x3D; gmpy2.invert(e, phi1)</span><br><span class=\"line\">m &#x3D; pow(c1, d1, n1)</span><br><span class=\"line\">ek &#x3D; n2s(m)</span><br><span class=\"line\"></span><br><span class=\"line\">key &#x3D; &#39;8891898088b197a0bfa78199b28195bfae89&#39;.decode(&#39;hex&#39;)</span><br><span class=\"line\">limit &#x3D; lambda n: n &amp; 0xffffffff</span><br><span class=\"line\"></span><br><span class=\"line\">Key  &#x3D; [ord(i) for i in key]</span><br><span class=\"line\">a &#x3D; limit((Key[0] &lt;&lt; 24) | (Key[1] &lt;&lt; 16) | (Key[2] &lt;&lt; 8) | Key[3])</span><br><span class=\"line\">b &#x3D; limit((Key[4] &lt;&lt; 24) | (Key[5] &lt;&lt; 16) | (Key[6] &lt;&lt; 8) | Key[7])</span><br><span class=\"line\">c &#x3D; limit((Key[8] &lt;&lt; 24) | (Key[9] &lt;&lt; 16) | (Key[10] &lt;&lt; 8) | Key[11])</span><br><span class=\"line\">d &#x3D; limit((Key[12] &lt;&lt; 24) | (Key[13] &lt;&lt; 16) | (Key[14] &lt;&lt; 8) | Key[15])</span><br><span class=\"line\"></span><br><span class=\"line\">outputs &#x3D; [0x65d4ce3b0b1b3f48bb9fdL, 0xf0230f43414a9c9ac0488L, 0xbd592ebe04025b783fb5bL, 0x28d194dcd1c79b4bb8074L, 0x7c493be8f0fdbb740ec29L]</span><br><span class=\"line\"></span><br><span class=\"line\">def reversecalc(a, b, c, d, y, z, pad):</span><br><span class=\"line\">    for i in range(32, 0, -1):</span><br><span class=\"line\">        # print &#39;Round %d: %d, %d&#39; % (i, y, z)</span><br><span class=\"line\">        pads &#x3D; limit(pad * i)</span><br><span class=\"line\">        paramz &#x3D; (y*16+c)^(y+pads)^((y&gt;&gt;5)+d)</span><br><span class=\"line\">        if(z &lt; paramz):</span><br><span class=\"line\">            z &#x3D; limit(z - paramz + 0x100000000)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            z &#x3D; limit(z - paramz)</span><br><span class=\"line\">        paramy &#x3D; (z*16+a)^(z+pads)^((z&gt;&gt;5)+b)</span><br><span class=\"line\">        if(y &lt; paramy):</span><br><span class=\"line\">            y &#x3D; limit(y - paramy + 0x100000000)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y &#x3D; limit(y - paramy)</span><br><span class=\"line\">        # print (y, z)</span><br><span class=\"line\">    return y, z</span><br><span class=\"line\"></span><br><span class=\"line\">for output in outputs:</span><br><span class=\"line\">    print hex(output)</span><br><span class=\"line\">    binout &#x3D; bin(output)[2:]</span><br><span class=\"line\">    binout &#x3D; &#39;0&#39;*(84-len(binout))+binout</span><br><span class=\"line\">    y &#x3D; int(binout[:32], 2)</span><br><span class=\"line\">    for i in range(4096):</span><br><span class=\"line\">        bini &#x3D; bin(i)[2:]</span><br><span class=\"line\">        bini &#x3D; &#39;0&#39;*(12-len(bini))+bini</span><br><span class=\"line\">        tmpbinpads &#x3D; bini[0:5] + binout[32:52] + bini[5:12] + &#39;00000&#39;</span><br><span class=\"line\">        pad &#x3D; int(tmpbinpads, 2) &#x2F; 32</span><br><span class=\"line\">        pads &#x3D; limit(int(tmpbinpads, 2))</span><br><span class=\"line\">        z &#x3D; output ^ (y&lt;&lt;52) ^ (pads&lt;&lt;20)</span><br><span class=\"line\">        y0, z0 &#x3D; reversecalc(a, b, c, d, y, z, pad)</span><br><span class=\"line\">        tmpstr &#x3D; n2s(y0)+n2s(z0)</span><br><span class=\"line\">        valid &#x3D; True</span><br><span class=\"line\">        for j in tmpstr:</span><br><span class=\"line\">            if (not j in string.printable)and(j !&#x3D; &#39;\\x00&#39;):</span><br><span class=\"line\">                valid &#x3D; False</span><br><span class=\"line\">                break</span><br><span class=\"line\">        if(valid):</span><br><span class=\"line\">            print tmpstr</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>输出结果：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x65d4ce3b0b1b3f48bb9fdL</span><br><span class=\"line\">S60 &#39;\\M(</span><br><span class=\"line\">flag&#123;5fe</span><br><span class=\"line\">0xf0230f43414a9c9ac0488L</span><br><span class=\"line\">86c73a3e</span><br><span class=\"line\">0xbd592ebe04025b783fb5bL</span><br><span class=\"line\">Us</span><br><span class=\"line\">NU\\KNP-F</span><br><span class=\"line\">381ee168</span><br><span class=\"line\">0x28d194dcd1c79b4bb8074L</span><br><span class=\"line\">)^C04&lt;b5</span><br><span class=\"line\">Z&quot;N*&#39;U_x000C_&#x3D;</span><br><span class=\"line\">83c04451</span><br><span class=\"line\">GNM1!Uyl</span><br><span class=\"line\">0x7c493be8f0fdbb740ec29L</span><br><span class=\"line\">9o&#96;YE</span><br><span class=\"line\">1356f&#125;</span><br><span class=\"line\">QG_x000C_rVHZo</span><br><span class=\"line\">7ju-px&#x2F;_x000C</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>寻找其中看起来像的拼接得到flag</li>\n</ul>\n"},{"title":"Ecc椭圆曲线基础","author":"人生若只如初见","date":"2020-05-27T10:16:00.000Z","_content":"* 一般，椭圆曲线可以用以下二元三阶方程的形式来表示：\n\n```\ny² = x³ + ax + b，其中a、b为系数。\n```\n\n* 它大概的几何形状如下图：\n\n![](/images/pasted-14.png)\n* 而本文要介绍的加法和乘法，就是基于这样一个奇怪的几何图形来做到的。\n* 椭圆曲线加法（非有限域）：在椭圆曲线上取一点P(Xp,Yp)，再取一点Q(Xq,Yq)，连接P、Q两点作一条直线，这条直线将在椭圆曲线上交于第三点G，过G点作垂直于X轴的直线，将过椭圆曲线另一点R（一般是关于X轴对称的点），R点则被定义为P+Q的结果，既P+Q=R：\n\n![](/images/pasted-15.png)\n\n* 当P=Q的情况下，直线将是椭圆曲线在P（Q）点上的切线，而G点是这条切线和曲线的另一个交点，同样，P+Q=R\n\n![](/images/pasted-16.png)\n\n* 通过上述的图片和文字描述，已经在几何图形上给出了椭圆曲线加法的定义，可是如果要公式化，该如何快速计算呢？\n* 这里只提供快速计算公式，不提供证明，证明可以自己再去解方程组推导一下：\n* 计算P+Q=R\n* 当P！=Q时，两点纵坐标相减的值与横坐标相减的值就是直线的斜率：\n\n```\nλ = (Yq - Yp)/(Xq - Xp)\n\n```\n* 当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除：\n\n```\nλ = (3Xp² + a)/2Yp\n```\n* 斜率计算之后，对点R的坐标进行计算，公式如下：\n\n```\nXr = (λ² - Xp - Xq)\nYr = (λ(Xp - Xr) - Yp)\n```\n* 通过上述公式，可以快速计算椭圆曲线上任意两点的加法和，这里给出加法实现的python代码：\n\n```\nif P == Q:\naaa=(3pow(P[0],2) + a)\nbbb=(2G[1])\nk=(aaa/bbb)\nelse:\naaa=(Q[1]-P[1])\nbbb=(Q[0]-P[0])\nk=(aaa/bbb)\n\nRx=(pow(k,2)-P[0] - Q[0])\nRy=(k*(P[0]-Rx) - P[1])\n椭圆曲线加法（有限域）\n```\n\n* 实数范围上光滑的椭圆曲线在密码学应用上并不合适，需要进行有限域下的离散化操作才能使用。\n\n![](/images/pasted-18.png)\n* 现在将上述的椭圆曲线加法计算公式适当修改，以适应有限域下的计算：\n\n\n```\n当P！=Q时，两点纵坐标相减的值与横坐标相减的值需要与p进行取余操作：\n\tλ = (Yq - Yp)/(Xq - Xp) mod p\n\n当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除，结果也需要与p进行取余操作：\n\n\tλ = (3Xp² + a)/2Yp mod p\n\n斜率计算之后，对点R的坐标进行计算，公式如下：\n\n\tXr = (λ² - Xp - Xq) mod p\n\n\tYr = (λ(Xp - Xr) - Yp) mod p\n\n通过比较，有限域下的计算只是对结果进行了取余操作，上述公式看起来已经解决了有限域下的椭圆曲线加法。\n\n但是如果在编写代码，计算实际的例子时，有很大可能会得到错误的结果，其根源在于\n\n\tλ = (Yq - Yp)/(Xq - Xp) mod p或λ = (3Xp² + a)/2Yp mod p\n    \n在进行取余计算之前，除数和被除数之前可能并不是一个整除的关系。如：1/4 mod 23，如果直接进行处理，将会得到结果0。\n\n但是在分数求模计算中，是如下定义的：\n\n\t计算a/b(mod n)\n\n\ta/b (mod n)=a*b^-1(mod n)\n\n计算1/b mod n=b^(-1) mod n\n就是求y，满足：\n\n\tyb = 1 mod n\n\ty是有限域F(n)上x的乘法逆元素\n\n简单点说，假设需要求上述的1/4 mod 23，可以转化为14（-1次方） mod 23，又可以转化为1(4和23的乘法逆元) mod 23。\n而计算乘法逆元，可以通过拓展欧几里得计算得到，这里对拓展欧几里得不作展开，只提供一个简单算法流程描述：\n\t\tExtendedEuclid(d,f) \n\t1 （X1,X2,X3):=(1,0,f) \n\t2   (Y1,Y2,Y3):=(0,1,d) \n\t3  if (Y3=0) then return  d'=null//无逆元 \n\t4  if (Y3=1) then return  d'=Y2  //Y2为逆元 \n\t5  Q:=X3 div Y3 \n\t6  (T1,T2,T3):=(X1-Q*Y1,X2-Q*Y2,X3-Q*Y3) \n\t7 （X1,X2,X3):=(Y1,Y2,Y3) \n\t8  (Y1,Y2,Y3):=(T1,T2,T3) \n\t9  goto 3\n```\n\n* 得到乘法逆元后，椭圆曲线上的加法运算计算就简单了，实现Python代码如下:\n\n```\n#coding:utf-8\n#欧几里得算法求最大公约数\ndef get_gcd(a, b):\n    k = a // b\n    remainder = a % b\n    while remainder != 0:\n        a = b \n        b = remainder\n        k = a // b\n        remainder = a % b\n    return b\n    \n#改进欧几里得算法求线性方程的x与y\ndef get_(a, b):\n    if b == 0:\n        return 1, 0\n    else:\n        k = a // b\n        remainder = a % b       \n        x1, y1 = get_(b, remainder)\n        x, y = y1, x1 - k * y1          \n    return x, y\n\n#返回乘法逆元\ndef yunsle(a,b):\n    #将初始b的绝对值进行保存\n    if b < 0:\n        m = abs(b)\n    else:\n    m = b\n    flag = get_gcd(a, b)\n\n    #判断最大公约数是否为1，若不是则没有逆元\n    if flag == 1:   \n    x, y = get_(a, b)   \n    x0 = x % m #对于Python '%'就是求模运算，因此不需要'+m'\n    #print(x0) #x0就是所求的逆元\n        return x0\n    else:\n    print(\"Do not have!\")\n\n\nif P == Q:\n        aaa=(3*pow(P[0],2) + a)\n        bbb=(2*P[1])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod \nelse:\n        aaa=(Q[1]-P[1])\n        bbb=(Q[0]-P[0])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod \n\nRx=(pow(k,2)-P[0] - Q[0])  % mod\nRy=(k*(P[0]-Rx) - P[1])  % mod\n```\n\n## 椭圆曲线乘法\n\n* 简单介绍完椭圆曲线上定义的加法运算，椭圆曲线上的乘法运算就比较简单了，因为加法可以退化为加法运算，就像算数上的1*3等价与1+1+1。\n\n* 假设我们需要求2P，则可以化简为P+P=2P\n\n* 同理，当我们需要求3P时，可以化简为P+2P=3P，其中2P=P+P\n\n* 最后，我们可以得到规律，当求nP时（n为任意正整数），P+(n-1)P=nP，其中(n-1)P=P+(n-2)P\n\n* 这样，通过上述介绍的椭圆曲线加法公式，完全可以进行椭圆曲线的乘法计算\n* 以本文开头的题目为例，给出Python代码实现：\n\n```\n#coding:utf-8\n#欧几里得算法求最大公约数\ndef get_gcd(a, b):\n    k = a // b\n    remainder = a % b\n    while remainder != 0:\n        a = b \n        b = remainder\n        k = a // b\n        remainder = a % b\n    return b\n    \n#改进欧几里得算法求线性方程的x与y\ndef get_(a, b):\n    if b == 0:\n        return 1, 0\n    else:\n        k = a // b\n        remainder = a % b       \n        x1, y1 = get_(b, remainder)\n        x, y = y1, x1 - k * y1          \n    return x, y\n\n#返回乘法逆元\ndef yunsle(a,b):\n    #将初始b的绝对值进行保存\n    if b < 0:\n        m = abs(b)\n    else:\n    m = b\n    flag = get_gcd(a, b)\n\n    #判断最大公约数是否为1，若不是则没有逆元\n    if flag == 1:   \n    x, y = get_(a, b)   \n    x0 = x % m #对于Python '%'就是求模运算，因此不需要'+m'\n    #print(x0) #x0就是所求的逆元\n        return x0\n    else:\n    print(\"Do not have!\")\n\n\nmod=15424654874903\n#mod=23\na=16546484\n#a=1\nb=4548674875\n#b=1\nG=[6478678675,5636379357093]\n#G=[3,10]\n#次数\nk=546768\ntemp=[6478678675,5636379357093]\n#temp=[3,10]\nfor i in range(0,k):\n    if i == 0:\n        aaa=(3*pow(G[0],2) + a)\n        bbb=(2*G[1])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod\n    else:\n        aaa=(temp[1]-G[1])\n        bbb=(temp[0]-G[0])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod\n\n    #print y\n    Rx=(pow(y,2)-G[0] - temp[0]) % mod\n    Ry=(y*(G[0]-Rx) - G[1]) % mod\n    temp=[Rx,Ry]\n    #print temp\n\nprint temp\n```\n* 参考文献：\n\n[讲解了受限域的曲线下的加法实现计算](http://blog.51cto.com/11821908/2057726)\n\n\n[只讲解了无受限域下曲线的加法](https://www.jianshu.com/p/2e6031ac3d50)\n\n\n[分数求模原理介绍](https://wenku.baidu.com/view/6f2879cca1c7aa00b52acb5f.html)\n\n\n[看雪论坛上的详细介绍，提供了加法运算的验证集](https://www.pediy.com/kssd/pediy06/pediy6014.htm)\n\n[乘法逆元求解的python实现](https://blog.csdn.net/baidu_38271024/article/details/78881031)\n","source":"_posts/Ecc椭圆曲线基础.md","raw":"title: Ecc椭圆曲线基础\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - ECC\ndate: 2020-05-27 18:16:00\n---\n* 一般，椭圆曲线可以用以下二元三阶方程的形式来表示：\n\n```\ny² = x³ + ax + b，其中a、b为系数。\n```\n\n* 它大概的几何形状如下图：\n\n![](/images/pasted-14.png)\n* 而本文要介绍的加法和乘法，就是基于这样一个奇怪的几何图形来做到的。\n* 椭圆曲线加法（非有限域）：在椭圆曲线上取一点P(Xp,Yp)，再取一点Q(Xq,Yq)，连接P、Q两点作一条直线，这条直线将在椭圆曲线上交于第三点G，过G点作垂直于X轴的直线，将过椭圆曲线另一点R（一般是关于X轴对称的点），R点则被定义为P+Q的结果，既P+Q=R：\n\n![](/images/pasted-15.png)\n\n* 当P=Q的情况下，直线将是椭圆曲线在P（Q）点上的切线，而G点是这条切线和曲线的另一个交点，同样，P+Q=R\n\n![](/images/pasted-16.png)\n\n* 通过上述的图片和文字描述，已经在几何图形上给出了椭圆曲线加法的定义，可是如果要公式化，该如何快速计算呢？\n* 这里只提供快速计算公式，不提供证明，证明可以自己再去解方程组推导一下：\n* 计算P+Q=R\n* 当P！=Q时，两点纵坐标相减的值与横坐标相减的值就是直线的斜率：\n\n```\nλ = (Yq - Yp)/(Xq - Xp)\n\n```\n* 当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除：\n\n```\nλ = (3Xp² + a)/2Yp\n```\n* 斜率计算之后，对点R的坐标进行计算，公式如下：\n\n```\nXr = (λ² - Xp - Xq)\nYr = (λ(Xp - Xr) - Yp)\n```\n* 通过上述公式，可以快速计算椭圆曲线上任意两点的加法和，这里给出加法实现的python代码：\n\n```\nif P == Q:\naaa=(3pow(P[0],2) + a)\nbbb=(2G[1])\nk=(aaa/bbb)\nelse:\naaa=(Q[1]-P[1])\nbbb=(Q[0]-P[0])\nk=(aaa/bbb)\n\nRx=(pow(k,2)-P[0] - Q[0])\nRy=(k*(P[0]-Rx) - P[1])\n椭圆曲线加法（有限域）\n```\n\n* 实数范围上光滑的椭圆曲线在密码学应用上并不合适，需要进行有限域下的离散化操作才能使用。\n\n![](/images/pasted-18.png)\n* 现在将上述的椭圆曲线加法计算公式适当修改，以适应有限域下的计算：\n\n\n```\n当P！=Q时，两点纵坐标相减的值与横坐标相减的值需要与p进行取余操作：\n\tλ = (Yq - Yp)/(Xq - Xp) mod p\n\n当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除，结果也需要与p进行取余操作：\n\n\tλ = (3Xp² + a)/2Yp mod p\n\n斜率计算之后，对点R的坐标进行计算，公式如下：\n\n\tXr = (λ² - Xp - Xq) mod p\n\n\tYr = (λ(Xp - Xr) - Yp) mod p\n\n通过比较，有限域下的计算只是对结果进行了取余操作，上述公式看起来已经解决了有限域下的椭圆曲线加法。\n\n但是如果在编写代码，计算实际的例子时，有很大可能会得到错误的结果，其根源在于\n\n\tλ = (Yq - Yp)/(Xq - Xp) mod p或λ = (3Xp² + a)/2Yp mod p\n    \n在进行取余计算之前，除数和被除数之前可能并不是一个整除的关系。如：1/4 mod 23，如果直接进行处理，将会得到结果0。\n\n但是在分数求模计算中，是如下定义的：\n\n\t计算a/b(mod n)\n\n\ta/b (mod n)=a*b^-1(mod n)\n\n计算1/b mod n=b^(-1) mod n\n就是求y，满足：\n\n\tyb = 1 mod n\n\ty是有限域F(n)上x的乘法逆元素\n\n简单点说，假设需要求上述的1/4 mod 23，可以转化为14（-1次方） mod 23，又可以转化为1(4和23的乘法逆元) mod 23。\n而计算乘法逆元，可以通过拓展欧几里得计算得到，这里对拓展欧几里得不作展开，只提供一个简单算法流程描述：\n\t\tExtendedEuclid(d,f) \n\t1 （X1,X2,X3):=(1,0,f) \n\t2   (Y1,Y2,Y3):=(0,1,d) \n\t3  if (Y3=0) then return  d'=null//无逆元 \n\t4  if (Y3=1) then return  d'=Y2  //Y2为逆元 \n\t5  Q:=X3 div Y3 \n\t6  (T1,T2,T3):=(X1-Q*Y1,X2-Q*Y2,X3-Q*Y3) \n\t7 （X1,X2,X3):=(Y1,Y2,Y3) \n\t8  (Y1,Y2,Y3):=(T1,T2,T3) \n\t9  goto 3\n```\n\n* 得到乘法逆元后，椭圆曲线上的加法运算计算就简单了，实现Python代码如下:\n\n```\n#coding:utf-8\n#欧几里得算法求最大公约数\ndef get_gcd(a, b):\n    k = a // b\n    remainder = a % b\n    while remainder != 0:\n        a = b \n        b = remainder\n        k = a // b\n        remainder = a % b\n    return b\n    \n#改进欧几里得算法求线性方程的x与y\ndef get_(a, b):\n    if b == 0:\n        return 1, 0\n    else:\n        k = a // b\n        remainder = a % b       \n        x1, y1 = get_(b, remainder)\n        x, y = y1, x1 - k * y1          \n    return x, y\n\n#返回乘法逆元\ndef yunsle(a,b):\n    #将初始b的绝对值进行保存\n    if b < 0:\n        m = abs(b)\n    else:\n    m = b\n    flag = get_gcd(a, b)\n\n    #判断最大公约数是否为1，若不是则没有逆元\n    if flag == 1:   \n    x, y = get_(a, b)   \n    x0 = x % m #对于Python '%'就是求模运算，因此不需要'+m'\n    #print(x0) #x0就是所求的逆元\n        return x0\n    else:\n    print(\"Do not have!\")\n\n\nif P == Q:\n        aaa=(3*pow(P[0],2) + a)\n        bbb=(2*P[1])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod \nelse:\n        aaa=(Q[1]-P[1])\n        bbb=(Q[0]-P[0])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod \n\nRx=(pow(k,2)-P[0] - Q[0])  % mod\nRy=(k*(P[0]-Rx) - P[1])  % mod\n```\n\n## 椭圆曲线乘法\n\n* 简单介绍完椭圆曲线上定义的加法运算，椭圆曲线上的乘法运算就比较简单了，因为加法可以退化为加法运算，就像算数上的1*3等价与1+1+1。\n\n* 假设我们需要求2P，则可以化简为P+P=2P\n\n* 同理，当我们需要求3P时，可以化简为P+2P=3P，其中2P=P+P\n\n* 最后，我们可以得到规律，当求nP时（n为任意正整数），P+(n-1)P=nP，其中(n-1)P=P+(n-2)P\n\n* 这样，通过上述介绍的椭圆曲线加法公式，完全可以进行椭圆曲线的乘法计算\n* 以本文开头的题目为例，给出Python代码实现：\n\n```\n#coding:utf-8\n#欧几里得算法求最大公约数\ndef get_gcd(a, b):\n    k = a // b\n    remainder = a % b\n    while remainder != 0:\n        a = b \n        b = remainder\n        k = a // b\n        remainder = a % b\n    return b\n    \n#改进欧几里得算法求线性方程的x与y\ndef get_(a, b):\n    if b == 0:\n        return 1, 0\n    else:\n        k = a // b\n        remainder = a % b       \n        x1, y1 = get_(b, remainder)\n        x, y = y1, x1 - k * y1          \n    return x, y\n\n#返回乘法逆元\ndef yunsle(a,b):\n    #将初始b的绝对值进行保存\n    if b < 0:\n        m = abs(b)\n    else:\n    m = b\n    flag = get_gcd(a, b)\n\n    #判断最大公约数是否为1，若不是则没有逆元\n    if flag == 1:   \n    x, y = get_(a, b)   \n    x0 = x % m #对于Python '%'就是求模运算，因此不需要'+m'\n    #print(x0) #x0就是所求的逆元\n        return x0\n    else:\n    print(\"Do not have!\")\n\n\nmod=15424654874903\n#mod=23\na=16546484\n#a=1\nb=4548674875\n#b=1\nG=[6478678675,5636379357093]\n#G=[3,10]\n#次数\nk=546768\ntemp=[6478678675,5636379357093]\n#temp=[3,10]\nfor i in range(0,k):\n    if i == 0:\n        aaa=(3*pow(G[0],2) + a)\n        bbb=(2*G[1])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod\n    else:\n        aaa=(temp[1]-G[1])\n        bbb=(temp[0]-G[0])\n        if aaa % bbb !=0:\n            val=yunsle(bbb,mod)\n            y=(aaa*val) % mod\n        else:\n            y=(aaa/bbb) % mod\n\n    #print y\n    Rx=(pow(y,2)-G[0] - temp[0]) % mod\n    Ry=(y*(G[0]-Rx) - G[1]) % mod\n    temp=[Rx,Ry]\n    #print temp\n\nprint temp\n```\n* 参考文献：\n\n[讲解了受限域的曲线下的加法实现计算](http://blog.51cto.com/11821908/2057726)\n\n\n[只讲解了无受限域下曲线的加法](https://www.jianshu.com/p/2e6031ac3d50)\n\n\n[分数求模原理介绍](https://wenku.baidu.com/view/6f2879cca1c7aa00b52acb5f.html)\n\n\n[看雪论坛上的详细介绍，提供了加法运算的验证集](https://www.pediy.com/kssd/pediy06/pediy6014.htm)\n\n[乘法逆元求解的python实现](https://blog.csdn.net/baidu_38271024/article/details/78881031)\n","slug":"Ecc椭圆曲线基础","published":1,"updated":"2020-05-27T10:26:38.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18e001tvcu9a9sxfw5o","content":"<ul>\n<li>一般，椭圆曲线可以用以下二元三阶方程的形式来表示：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y² &#x3D; x³ + ax + b，其中a、b为系数。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>它大概的几何形状如下图：</li>\n</ul>\n<p><img src=\"/images/pasted-14.png\" alt=\"\"></p>\n<ul>\n<li>而本文要介绍的加法和乘法，就是基于这样一个奇怪的几何图形来做到的。</li>\n<li>椭圆曲线加法（非有限域）：在椭圆曲线上取一点P(Xp,Yp)，再取一点Q(Xq,Yq)，连接P、Q两点作一条直线，这条直线将在椭圆曲线上交于第三点G，过G点作垂直于X轴的直线，将过椭圆曲线另一点R（一般是关于X轴对称的点），R点则被定义为P+Q的结果，既P+Q=R：</li>\n</ul>\n<p><img src=\"/images/pasted-15.png\" alt=\"\"></p>\n<ul>\n<li>当P=Q的情况下，直线将是椭圆曲线在P（Q）点上的切线，而G点是这条切线和曲线的另一个交点，同样，P+Q=R</li>\n</ul>\n<p><img src=\"/images/pasted-16.png\" alt=\"\"></p>\n<ul>\n<li>通过上述的图片和文字描述，已经在几何图形上给出了椭圆曲线加法的定义，可是如果要公式化，该如何快速计算呢？</li>\n<li>这里只提供快速计算公式，不提供证明，证明可以自己再去解方程组推导一下：</li>\n<li>计算P+Q=R</li>\n<li>当P！=Q时，两点纵坐标相减的值与横坐标相减的值就是直线的斜率：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">λ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">λ &#x3D; (3Xp² + a)&#x2F;2Yp</span><br></pre></td></tr></table></figure>\n<ul>\n<li>斜率计算之后，对点R的坐标进行计算，公式如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Xr &#x3D; (λ² - Xp - Xq)</span><br><span class=\"line\">Yr &#x3D; (λ(Xp - Xr) - Yp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过上述公式，可以快速计算椭圆曲线上任意两点的加法和，这里给出加法实现的python代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if P &#x3D;&#x3D; Q:</span><br><span class=\"line\">aaa&#x3D;(3pow(P[0],2) + a)</span><br><span class=\"line\">bbb&#x3D;(2G[1])</span><br><span class=\"line\">k&#x3D;(aaa&#x2F;bbb)</span><br><span class=\"line\">else:</span><br><span class=\"line\">aaa&#x3D;(Q[1]-P[1])</span><br><span class=\"line\">bbb&#x3D;(Q[0]-P[0])</span><br><span class=\"line\">k&#x3D;(aaa&#x2F;bbb)</span><br><span class=\"line\"></span><br><span class=\"line\">Rx&#x3D;(pow(k,2)-P[0] - Q[0])</span><br><span class=\"line\">Ry&#x3D;(k*(P[0]-Rx) - P[1])</span><br><span class=\"line\">椭圆曲线加法（有限域）</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实数范围上光滑的椭圆曲线在密码学应用上并不合适，需要进行有限域下的离散化操作才能使用。</li>\n</ul>\n<p><img src=\"/images/pasted-18.png\" alt=\"\"></p>\n<ul>\n<li>现在将上述的椭圆曲线加法计算公式适当修改，以适应有限域下的计算：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当P！&#x3D;Q时，两点纵坐标相减的值与横坐标相减的值需要与p进行取余操作：</span><br><span class=\"line\">\tλ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">当P&#x3D;Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除，结果也需要与p进行取余操作：</span><br><span class=\"line\"></span><br><span class=\"line\">\tλ &#x3D; (3Xp² + a)&#x2F;2Yp mod p</span><br><span class=\"line\"></span><br><span class=\"line\">斜率计算之后，对点R的坐标进行计算，公式如下：</span><br><span class=\"line\"></span><br><span class=\"line\">\tXr &#x3D; (λ² - Xp - Xq) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">\tYr &#x3D; (λ(Xp - Xr) - Yp) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">通过比较，有限域下的计算只是对结果进行了取余操作，上述公式看起来已经解决了有限域下的椭圆曲线加法。</span><br><span class=\"line\"></span><br><span class=\"line\">但是如果在编写代码，计算实际的例子时，有很大可能会得到错误的结果，其根源在于</span><br><span class=\"line\"></span><br><span class=\"line\">\tλ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp) mod p或λ &#x3D; (3Xp² + a)&#x2F;2Yp mod p</span><br><span class=\"line\">    </span><br><span class=\"line\">在进行取余计算之前，除数和被除数之前可能并不是一个整除的关系。如：1&#x2F;4 mod 23，如果直接进行处理，将会得到结果0。</span><br><span class=\"line\"></span><br><span class=\"line\">但是在分数求模计算中，是如下定义的：</span><br><span class=\"line\"></span><br><span class=\"line\">\t计算a&#x2F;b(mod n)</span><br><span class=\"line\"></span><br><span class=\"line\">\ta&#x2F;b (mod n)&#x3D;a*b^-1(mod n)</span><br><span class=\"line\"></span><br><span class=\"line\">计算1&#x2F;b mod n&#x3D;b^(-1) mod n</span><br><span class=\"line\">就是求y，满足：</span><br><span class=\"line\"></span><br><span class=\"line\">\tyb &#x3D; 1 mod n</span><br><span class=\"line\">\ty是有限域F(n)上x的乘法逆元素</span><br><span class=\"line\"></span><br><span class=\"line\">简单点说，假设需要求上述的1&#x2F;4 mod 23，可以转化为14（-1次方） mod 23，又可以转化为1(4和23的乘法逆元) mod 23。</span><br><span class=\"line\">而计算乘法逆元，可以通过拓展欧几里得计算得到，这里对拓展欧几里得不作展开，只提供一个简单算法流程描述：</span><br><span class=\"line\">\t\tExtendedEuclid(d,f) </span><br><span class=\"line\">\t1 （X1,X2,X3):&#x3D;(1,0,f) </span><br><span class=\"line\">\t2   (Y1,Y2,Y3):&#x3D;(0,1,d) </span><br><span class=\"line\">\t3  if (Y3&#x3D;0) then return  d&#39;&#x3D;null&#x2F;&#x2F;无逆元 </span><br><span class=\"line\">\t4  if (Y3&#x3D;1) then return  d&#39;&#x3D;Y2  &#x2F;&#x2F;Y2为逆元 </span><br><span class=\"line\">\t5  Q:&#x3D;X3 div Y3 </span><br><span class=\"line\">\t6  (T1,T2,T3):&#x3D;(X1-Q*Y1,X2-Q*Y2,X3-Q*Y3) </span><br><span class=\"line\">\t7 （X1,X2,X3):&#x3D;(Y1,Y2,Y3) </span><br><span class=\"line\">\t8  (Y1,Y2,Y3):&#x3D;(T1,T2,T3) </span><br><span class=\"line\">\t9  goto 3</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>得到乘法逆元后，椭圆曲线上的加法运算计算就简单了，实现Python代码如下:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">#欧几里得算法求最大公约数</span><br><span class=\"line\">def get_gcd(a, b):</span><br><span class=\"line\">    k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">    remainder &#x3D; a % b</span><br><span class=\"line\">    while remainder !&#x3D; 0:</span><br><span class=\"line\">        a &#x3D; b </span><br><span class=\"line\">        b &#x3D; remainder</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b</span><br><span class=\"line\">    return b</span><br><span class=\"line\">    </span><br><span class=\"line\">#改进欧几里得算法求线性方程的x与y</span><br><span class=\"line\">def get_(a, b):</span><br><span class=\"line\">    if b &#x3D;&#x3D; 0:</span><br><span class=\"line\">        return 1, 0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b       </span><br><span class=\"line\">        x1, y1 &#x3D; get_(b, remainder)</span><br><span class=\"line\">        x, y &#x3D; y1, x1 - k * y1          </span><br><span class=\"line\">    return x, y</span><br><span class=\"line\"></span><br><span class=\"line\">#返回乘法逆元</span><br><span class=\"line\">def yunsle(a,b):</span><br><span class=\"line\">    #将初始b的绝对值进行保存</span><br><span class=\"line\">    if b &lt; 0:</span><br><span class=\"line\">        m &#x3D; abs(b)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    m &#x3D; b</span><br><span class=\"line\">    flag &#x3D; get_gcd(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">    #判断最大公约数是否为1，若不是则没有逆元</span><br><span class=\"line\">    if flag &#x3D;&#x3D; 1:   </span><br><span class=\"line\">    x, y &#x3D; get_(a, b)   </span><br><span class=\"line\">    x0 &#x3D; x % m #对于Python &#39;%&#39;就是求模运算，因此不需要&#39;+m&#39;</span><br><span class=\"line\">    #print(x0) #x0就是所求的逆元</span><br><span class=\"line\">        return x0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    print(&quot;Do not have!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if P &#x3D;&#x3D; Q:</span><br><span class=\"line\">        aaa&#x3D;(3*pow(P[0],2) + a)</span><br><span class=\"line\">        bbb&#x3D;(2*P[1])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod </span><br><span class=\"line\">else:</span><br><span class=\"line\">        aaa&#x3D;(Q[1]-P[1])</span><br><span class=\"line\">        bbb&#x3D;(Q[0]-P[0])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod </span><br><span class=\"line\"></span><br><span class=\"line\">Rx&#x3D;(pow(k,2)-P[0] - Q[0])  % mod</span><br><span class=\"line\">Ry&#x3D;(k*(P[0]-Rx) - P[1])  % mod</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"椭圆曲线乘法\"><a href=\"#椭圆曲线乘法\" class=\"headerlink\" title=\"椭圆曲线乘法\"></a>椭圆曲线乘法</h2><ul>\n<li><p>简单介绍完椭圆曲线上定义的加法运算，椭圆曲线上的乘法运算就比较简单了，因为加法可以退化为加法运算，就像算数上的1*3等价与1+1+1。</p>\n</li>\n<li><p>假设我们需要求2P，则可以化简为P+P=2P</p>\n</li>\n<li><p>同理，当我们需要求3P时，可以化简为P+2P=3P，其中2P=P+P</p>\n</li>\n<li><p>最后，我们可以得到规律，当求nP时（n为任意正整数），P+(n-1)P=nP，其中(n-1)P=P+(n-2)P</p>\n</li>\n<li><p>这样，通过上述介绍的椭圆曲线加法公式，完全可以进行椭圆曲线的乘法计算</p>\n</li>\n<li><p>以本文开头的题目为例，给出Python代码实现：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">#欧几里得算法求最大公约数</span><br><span class=\"line\">def get_gcd(a, b):</span><br><span class=\"line\">    k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">    remainder &#x3D; a % b</span><br><span class=\"line\">    while remainder !&#x3D; 0:</span><br><span class=\"line\">        a &#x3D; b </span><br><span class=\"line\">        b &#x3D; remainder</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b</span><br><span class=\"line\">    return b</span><br><span class=\"line\">    </span><br><span class=\"line\">#改进欧几里得算法求线性方程的x与y</span><br><span class=\"line\">def get_(a, b):</span><br><span class=\"line\">    if b &#x3D;&#x3D; 0:</span><br><span class=\"line\">        return 1, 0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b       </span><br><span class=\"line\">        x1, y1 &#x3D; get_(b, remainder)</span><br><span class=\"line\">        x, y &#x3D; y1, x1 - k * y1          </span><br><span class=\"line\">    return x, y</span><br><span class=\"line\"></span><br><span class=\"line\">#返回乘法逆元</span><br><span class=\"line\">def yunsle(a,b):</span><br><span class=\"line\">    #将初始b的绝对值进行保存</span><br><span class=\"line\">    if b &lt; 0:</span><br><span class=\"line\">        m &#x3D; abs(b)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    m &#x3D; b</span><br><span class=\"line\">    flag &#x3D; get_gcd(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">    #判断最大公约数是否为1，若不是则没有逆元</span><br><span class=\"line\">    if flag &#x3D;&#x3D; 1:   </span><br><span class=\"line\">    x, y &#x3D; get_(a, b)   </span><br><span class=\"line\">    x0 &#x3D; x % m #对于Python &#39;%&#39;就是求模运算，因此不需要&#39;+m&#39;</span><br><span class=\"line\">    #print(x0) #x0就是所求的逆元</span><br><span class=\"line\">        return x0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    print(&quot;Do not have!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mod&#x3D;15424654874903</span><br><span class=\"line\">#mod&#x3D;23</span><br><span class=\"line\">a&#x3D;16546484</span><br><span class=\"line\">#a&#x3D;1</span><br><span class=\"line\">b&#x3D;4548674875</span><br><span class=\"line\">#b&#x3D;1</span><br><span class=\"line\">G&#x3D;[6478678675,5636379357093]</span><br><span class=\"line\">#G&#x3D;[3,10]</span><br><span class=\"line\">#次数</span><br><span class=\"line\">k&#x3D;546768</span><br><span class=\"line\">temp&#x3D;[6478678675,5636379357093]</span><br><span class=\"line\">#temp&#x3D;[3,10]</span><br><span class=\"line\">for i in range(0,k):</span><br><span class=\"line\">    if i &#x3D;&#x3D; 0:</span><br><span class=\"line\">        aaa&#x3D;(3*pow(G[0],2) + a)</span><br><span class=\"line\">        bbb&#x3D;(2*G[1])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        aaa&#x3D;(temp[1]-G[1])</span><br><span class=\"line\">        bbb&#x3D;(temp[0]-G[0])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod</span><br><span class=\"line\"></span><br><span class=\"line\">    #print y</span><br><span class=\"line\">    Rx&#x3D;(pow(y,2)-G[0] - temp[0]) % mod</span><br><span class=\"line\">    Ry&#x3D;(y*(G[0]-Rx) - G[1]) % mod</span><br><span class=\"line\">    temp&#x3D;[Rx,Ry]</span><br><span class=\"line\">    #print temp</span><br><span class=\"line\"></span><br><span class=\"line\">print temp</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参考文献：</li>\n</ul>\n<p><a href=\"http://blog.51cto.com/11821908/2057726\" target=\"_blank\" rel=\"noopener\">讲解了受限域的曲线下的加法实现计算</a></p>\n<p><a href=\"https://www.jianshu.com/p/2e6031ac3d50\" target=\"_blank\" rel=\"noopener\">只讲解了无受限域下曲线的加法</a></p>\n<p><a href=\"https://wenku.baidu.com/view/6f2879cca1c7aa00b52acb5f.html\" target=\"_blank\" rel=\"noopener\">分数求模原理介绍</a></p>\n<p><a href=\"https://www.pediy.com/kssd/pediy06/pediy6014.htm\" target=\"_blank\" rel=\"noopener\">看雪论坛上的详细介绍，提供了加法运算的验证集</a></p>\n<p><a href=\"https://blog.csdn.net/baidu_38271024/article/details/78881031\" target=\"_blank\" rel=\"noopener\">乘法逆元求解的python实现</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>一般，椭圆曲线可以用以下二元三阶方程的形式来表示：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y² &#x3D; x³ + ax + b，其中a、b为系数。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>它大概的几何形状如下图：</li>\n</ul>\n<p><img src=\"/images/pasted-14.png\" alt=\"\"></p>\n<ul>\n<li>而本文要介绍的加法和乘法，就是基于这样一个奇怪的几何图形来做到的。</li>\n<li>椭圆曲线加法（非有限域）：在椭圆曲线上取一点P(Xp,Yp)，再取一点Q(Xq,Yq)，连接P、Q两点作一条直线，这条直线将在椭圆曲线上交于第三点G，过G点作垂直于X轴的直线，将过椭圆曲线另一点R（一般是关于X轴对称的点），R点则被定义为P+Q的结果，既P+Q=R：</li>\n</ul>\n<p><img src=\"/images/pasted-15.png\" alt=\"\"></p>\n<ul>\n<li>当P=Q的情况下，直线将是椭圆曲线在P（Q）点上的切线，而G点是这条切线和曲线的另一个交点，同样，P+Q=R</li>\n</ul>\n<p><img src=\"/images/pasted-16.png\" alt=\"\"></p>\n<ul>\n<li>通过上述的图片和文字描述，已经在几何图形上给出了椭圆曲线加法的定义，可是如果要公式化，该如何快速计算呢？</li>\n<li>这里只提供快速计算公式，不提供证明，证明可以自己再去解方程组推导一下：</li>\n<li>计算P+Q=R</li>\n<li>当P！=Q时，两点纵坐标相减的值与横坐标相减的值就是直线的斜率：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">λ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当P=Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">λ &#x3D; (3Xp² + a)&#x2F;2Yp</span><br></pre></td></tr></table></figure>\n<ul>\n<li>斜率计算之后，对点R的坐标进行计算，公式如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Xr &#x3D; (λ² - Xp - Xq)</span><br><span class=\"line\">Yr &#x3D; (λ(Xp - Xr) - Yp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过上述公式，可以快速计算椭圆曲线上任意两点的加法和，这里给出加法实现的python代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if P &#x3D;&#x3D; Q:</span><br><span class=\"line\">aaa&#x3D;(3pow(P[0],2) + a)</span><br><span class=\"line\">bbb&#x3D;(2G[1])</span><br><span class=\"line\">k&#x3D;(aaa&#x2F;bbb)</span><br><span class=\"line\">else:</span><br><span class=\"line\">aaa&#x3D;(Q[1]-P[1])</span><br><span class=\"line\">bbb&#x3D;(Q[0]-P[0])</span><br><span class=\"line\">k&#x3D;(aaa&#x2F;bbb)</span><br><span class=\"line\"></span><br><span class=\"line\">Rx&#x3D;(pow(k,2)-P[0] - Q[0])</span><br><span class=\"line\">Ry&#x3D;(k*(P[0]-Rx) - P[1])</span><br><span class=\"line\">椭圆曲线加法（有限域）</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实数范围上光滑的椭圆曲线在密码学应用上并不合适，需要进行有限域下的离散化操作才能使用。</li>\n</ul>\n<p><img src=\"/images/pasted-18.png\" alt=\"\"></p>\n<ul>\n<li>现在将上述的椭圆曲线加法计算公式适当修改，以适应有限域下的计算：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当P！&#x3D;Q时，两点纵坐标相减的值与横坐标相减的值需要与p进行取余操作：</span><br><span class=\"line\">\tλ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">当P&#x3D;Q，计算过P（Q）点切线的斜率，既椭圆曲线公式两边求导相除，结果也需要与p进行取余操作：</span><br><span class=\"line\"></span><br><span class=\"line\">\tλ &#x3D; (3Xp² + a)&#x2F;2Yp mod p</span><br><span class=\"line\"></span><br><span class=\"line\">斜率计算之后，对点R的坐标进行计算，公式如下：</span><br><span class=\"line\"></span><br><span class=\"line\">\tXr &#x3D; (λ² - Xp - Xq) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">\tYr &#x3D; (λ(Xp - Xr) - Yp) mod p</span><br><span class=\"line\"></span><br><span class=\"line\">通过比较，有限域下的计算只是对结果进行了取余操作，上述公式看起来已经解决了有限域下的椭圆曲线加法。</span><br><span class=\"line\"></span><br><span class=\"line\">但是如果在编写代码，计算实际的例子时，有很大可能会得到错误的结果，其根源在于</span><br><span class=\"line\"></span><br><span class=\"line\">\tλ &#x3D; (Yq - Yp)&#x2F;(Xq - Xp) mod p或λ &#x3D; (3Xp² + a)&#x2F;2Yp mod p</span><br><span class=\"line\">    </span><br><span class=\"line\">在进行取余计算之前，除数和被除数之前可能并不是一个整除的关系。如：1&#x2F;4 mod 23，如果直接进行处理，将会得到结果0。</span><br><span class=\"line\"></span><br><span class=\"line\">但是在分数求模计算中，是如下定义的：</span><br><span class=\"line\"></span><br><span class=\"line\">\t计算a&#x2F;b(mod n)</span><br><span class=\"line\"></span><br><span class=\"line\">\ta&#x2F;b (mod n)&#x3D;a*b^-1(mod n)</span><br><span class=\"line\"></span><br><span class=\"line\">计算1&#x2F;b mod n&#x3D;b^(-1) mod n</span><br><span class=\"line\">就是求y，满足：</span><br><span class=\"line\"></span><br><span class=\"line\">\tyb &#x3D; 1 mod n</span><br><span class=\"line\">\ty是有限域F(n)上x的乘法逆元素</span><br><span class=\"line\"></span><br><span class=\"line\">简单点说，假设需要求上述的1&#x2F;4 mod 23，可以转化为14（-1次方） mod 23，又可以转化为1(4和23的乘法逆元) mod 23。</span><br><span class=\"line\">而计算乘法逆元，可以通过拓展欧几里得计算得到，这里对拓展欧几里得不作展开，只提供一个简单算法流程描述：</span><br><span class=\"line\">\t\tExtendedEuclid(d,f) </span><br><span class=\"line\">\t1 （X1,X2,X3):&#x3D;(1,0,f) </span><br><span class=\"line\">\t2   (Y1,Y2,Y3):&#x3D;(0,1,d) </span><br><span class=\"line\">\t3  if (Y3&#x3D;0) then return  d&#39;&#x3D;null&#x2F;&#x2F;无逆元 </span><br><span class=\"line\">\t4  if (Y3&#x3D;1) then return  d&#39;&#x3D;Y2  &#x2F;&#x2F;Y2为逆元 </span><br><span class=\"line\">\t5  Q:&#x3D;X3 div Y3 </span><br><span class=\"line\">\t6  (T1,T2,T3):&#x3D;(X1-Q*Y1,X2-Q*Y2,X3-Q*Y3) </span><br><span class=\"line\">\t7 （X1,X2,X3):&#x3D;(Y1,Y2,Y3) </span><br><span class=\"line\">\t8  (Y1,Y2,Y3):&#x3D;(T1,T2,T3) </span><br><span class=\"line\">\t9  goto 3</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>得到乘法逆元后，椭圆曲线上的加法运算计算就简单了，实现Python代码如下:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">#欧几里得算法求最大公约数</span><br><span class=\"line\">def get_gcd(a, b):</span><br><span class=\"line\">    k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">    remainder &#x3D; a % b</span><br><span class=\"line\">    while remainder !&#x3D; 0:</span><br><span class=\"line\">        a &#x3D; b </span><br><span class=\"line\">        b &#x3D; remainder</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b</span><br><span class=\"line\">    return b</span><br><span class=\"line\">    </span><br><span class=\"line\">#改进欧几里得算法求线性方程的x与y</span><br><span class=\"line\">def get_(a, b):</span><br><span class=\"line\">    if b &#x3D;&#x3D; 0:</span><br><span class=\"line\">        return 1, 0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b       </span><br><span class=\"line\">        x1, y1 &#x3D; get_(b, remainder)</span><br><span class=\"line\">        x, y &#x3D; y1, x1 - k * y1          </span><br><span class=\"line\">    return x, y</span><br><span class=\"line\"></span><br><span class=\"line\">#返回乘法逆元</span><br><span class=\"line\">def yunsle(a,b):</span><br><span class=\"line\">    #将初始b的绝对值进行保存</span><br><span class=\"line\">    if b &lt; 0:</span><br><span class=\"line\">        m &#x3D; abs(b)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    m &#x3D; b</span><br><span class=\"line\">    flag &#x3D; get_gcd(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">    #判断最大公约数是否为1，若不是则没有逆元</span><br><span class=\"line\">    if flag &#x3D;&#x3D; 1:   </span><br><span class=\"line\">    x, y &#x3D; get_(a, b)   </span><br><span class=\"line\">    x0 &#x3D; x % m #对于Python &#39;%&#39;就是求模运算，因此不需要&#39;+m&#39;</span><br><span class=\"line\">    #print(x0) #x0就是所求的逆元</span><br><span class=\"line\">        return x0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    print(&quot;Do not have!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if P &#x3D;&#x3D; Q:</span><br><span class=\"line\">        aaa&#x3D;(3*pow(P[0],2) + a)</span><br><span class=\"line\">        bbb&#x3D;(2*P[1])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod </span><br><span class=\"line\">else:</span><br><span class=\"line\">        aaa&#x3D;(Q[1]-P[1])</span><br><span class=\"line\">        bbb&#x3D;(Q[0]-P[0])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod </span><br><span class=\"line\"></span><br><span class=\"line\">Rx&#x3D;(pow(k,2)-P[0] - Q[0])  % mod</span><br><span class=\"line\">Ry&#x3D;(k*(P[0]-Rx) - P[1])  % mod</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"椭圆曲线乘法\"><a href=\"#椭圆曲线乘法\" class=\"headerlink\" title=\"椭圆曲线乘法\"></a>椭圆曲线乘法</h2><ul>\n<li><p>简单介绍完椭圆曲线上定义的加法运算，椭圆曲线上的乘法运算就比较简单了，因为加法可以退化为加法运算，就像算数上的1*3等价与1+1+1。</p>\n</li>\n<li><p>假设我们需要求2P，则可以化简为P+P=2P</p>\n</li>\n<li><p>同理，当我们需要求3P时，可以化简为P+2P=3P，其中2P=P+P</p>\n</li>\n<li><p>最后，我们可以得到规律，当求nP时（n为任意正整数），P+(n-1)P=nP，其中(n-1)P=P+(n-2)P</p>\n</li>\n<li><p>这样，通过上述介绍的椭圆曲线加法公式，完全可以进行椭圆曲线的乘法计算</p>\n</li>\n<li><p>以本文开头的题目为例，给出Python代码实现：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">#欧几里得算法求最大公约数</span><br><span class=\"line\">def get_gcd(a, b):</span><br><span class=\"line\">    k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">    remainder &#x3D; a % b</span><br><span class=\"line\">    while remainder !&#x3D; 0:</span><br><span class=\"line\">        a &#x3D; b </span><br><span class=\"line\">        b &#x3D; remainder</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b</span><br><span class=\"line\">    return b</span><br><span class=\"line\">    </span><br><span class=\"line\">#改进欧几里得算法求线性方程的x与y</span><br><span class=\"line\">def get_(a, b):</span><br><span class=\"line\">    if b &#x3D;&#x3D; 0:</span><br><span class=\"line\">        return 1, 0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        k &#x3D; a &#x2F;&#x2F; b</span><br><span class=\"line\">        remainder &#x3D; a % b       </span><br><span class=\"line\">        x1, y1 &#x3D; get_(b, remainder)</span><br><span class=\"line\">        x, y &#x3D; y1, x1 - k * y1          </span><br><span class=\"line\">    return x, y</span><br><span class=\"line\"></span><br><span class=\"line\">#返回乘法逆元</span><br><span class=\"line\">def yunsle(a,b):</span><br><span class=\"line\">    #将初始b的绝对值进行保存</span><br><span class=\"line\">    if b &lt; 0:</span><br><span class=\"line\">        m &#x3D; abs(b)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    m &#x3D; b</span><br><span class=\"line\">    flag &#x3D; get_gcd(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">    #判断最大公约数是否为1，若不是则没有逆元</span><br><span class=\"line\">    if flag &#x3D;&#x3D; 1:   </span><br><span class=\"line\">    x, y &#x3D; get_(a, b)   </span><br><span class=\"line\">    x0 &#x3D; x % m #对于Python &#39;%&#39;就是求模运算，因此不需要&#39;+m&#39;</span><br><span class=\"line\">    #print(x0) #x0就是所求的逆元</span><br><span class=\"line\">        return x0</span><br><span class=\"line\">    else:</span><br><span class=\"line\">    print(&quot;Do not have!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mod&#x3D;15424654874903</span><br><span class=\"line\">#mod&#x3D;23</span><br><span class=\"line\">a&#x3D;16546484</span><br><span class=\"line\">#a&#x3D;1</span><br><span class=\"line\">b&#x3D;4548674875</span><br><span class=\"line\">#b&#x3D;1</span><br><span class=\"line\">G&#x3D;[6478678675,5636379357093]</span><br><span class=\"line\">#G&#x3D;[3,10]</span><br><span class=\"line\">#次数</span><br><span class=\"line\">k&#x3D;546768</span><br><span class=\"line\">temp&#x3D;[6478678675,5636379357093]</span><br><span class=\"line\">#temp&#x3D;[3,10]</span><br><span class=\"line\">for i in range(0,k):</span><br><span class=\"line\">    if i &#x3D;&#x3D; 0:</span><br><span class=\"line\">        aaa&#x3D;(3*pow(G[0],2) + a)</span><br><span class=\"line\">        bbb&#x3D;(2*G[1])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        aaa&#x3D;(temp[1]-G[1])</span><br><span class=\"line\">        bbb&#x3D;(temp[0]-G[0])</span><br><span class=\"line\">        if aaa % bbb !&#x3D;0:</span><br><span class=\"line\">            val&#x3D;yunsle(bbb,mod)</span><br><span class=\"line\">            y&#x3D;(aaa*val) % mod</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y&#x3D;(aaa&#x2F;bbb) % mod</span><br><span class=\"line\"></span><br><span class=\"line\">    #print y</span><br><span class=\"line\">    Rx&#x3D;(pow(y,2)-G[0] - temp[0]) % mod</span><br><span class=\"line\">    Ry&#x3D;(y*(G[0]-Rx) - G[1]) % mod</span><br><span class=\"line\">    temp&#x3D;[Rx,Ry]</span><br><span class=\"line\">    #print temp</span><br><span class=\"line\"></span><br><span class=\"line\">print temp</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参考文献：</li>\n</ul>\n<p><a href=\"http://blog.51cto.com/11821908/2057726\" target=\"_blank\" rel=\"noopener\">讲解了受限域的曲线下的加法实现计算</a></p>\n<p><a href=\"https://www.jianshu.com/p/2e6031ac3d50\" target=\"_blank\" rel=\"noopener\">只讲解了无受限域下曲线的加法</a></p>\n<p><a href=\"https://wenku.baidu.com/view/6f2879cca1c7aa00b52acb5f.html\" target=\"_blank\" rel=\"noopener\">分数求模原理介绍</a></p>\n<p><a href=\"https://www.pediy.com/kssd/pediy06/pediy6014.htm\" target=\"_blank\" rel=\"noopener\">看雪论坛上的详细介绍，提供了加法运算的验证集</a></p>\n<p><a href=\"https://blog.csdn.net/baidu_38271024/article/details/78881031\" target=\"_blank\" rel=\"noopener\">乘法逆元求解的python实现</a></p>\n"},{"title":"MRctf2020密码","author":"人生若只如初见","date":"2020-05-29T03:35:00.000Z","_content":"# babyrsa\n* 根据主函数可知，首要目的是找到_P和_Q，首先来看_P\n* 可以发现\n![](https://img-blog.csdnimg.cn/20200329224856124.png)\n* 题目已给出P[9],所以直接目的可以手动测试周围素数，直到找到全部（这里是一部分）\n![](https://img-blog.csdnimg.cn/20200329225022887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 这里我们可以得到N\n* \n```\nfactor = pow(p, base, n)\n```\n\n* 这一句说明我们应该将这个简单RSA解出来，此时按照一般RSA的步骤求得d\n![](https://img-blog.csdnimg.cn/20200329225008750.png)\n* 这里已经得到N的所有因数，所以此时N的欧拉函数为所有因数减1相乘，即(p1-1)*(p2-1)*(...)*(p17-1)， 到此得到P的值\n* 接下来是Q\n![](https://img-blog.csdnimg.cn/20200329225330826.png)\n* 可以看到的是所有的参数已经给出，但是如果我们按照这个去算会很慢，因为数值是比较大的，所以这里我们用到了快速幂模\n\n```\nQ_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521\nQ_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743\nsub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651\ndef fastExpMod(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        # b, b^2, b^4, b^8, ... , b^(2^n)\n        b = (b*b) % m\n    return result\n_q=fastExpMod(sub_Q,Q_2 , Q_1)\n_q=sympy.nextprime(_q)\n```\n\n* 通过这个得到最终的Q的值\n* 最后按照常规RSA的解密，完成此题（完整代码）\n\n```\nimport sympy\nimport gmpy2 \nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytes\n\nbase=65537\n\nfactor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839\nn=1\np = [0 for i in range(17)]\np[0]=206027926847308612719677572554991142909\np[1]=206027926847308612719677572554991142911\np[2]=206027926847308612719677572554991142977\np[3]=206027926847308612719677572554991143071\np[4]=206027926847308612719677572554991143103\np[5]=206027926847308612719677572554991143121\np[6]=206027926847308612719677572554991143133\np[7]=206027926847308612719677572554991143317\np[8]=206027926847308612719677572554991143401\np[9]=206027926847308612719677572554991143421\nfor i in range(10,17):\n    p[i]=sympy.nextprime(p[i-1])\n\nfor i in range(17):\n        x= n*p[i]\n        n=x\n\nphi=1\nfor i in range(0,17):\n    phi *=p[i]-1\n\nd1=gmpy2.invert(base,phi)\n_p=pow(factor,d1,n)\n_p=sympy.nextprime(_p)\n\nQ_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521\nQ_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743\nsub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651\ndef fastExpMod(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        # b, b^2, b^4, b^8, ... , b^(2^n)\n        b = (b*b) % m\n    return result\n_q=fastExpMod(sub_Q,Q_2 , Q_1)\n_q=sympy.nextprime(_q)\n\n\nc=  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832\nd=gmpy2.invert(base,(_p-1)*(_q-1))\nm=pow(c,d,_p*_q)\nprint long_to_bytes(m)\n```\n\n# Easy_RSA\n* 与上一题类似，这里我们依旧先从P开始\n![](https://img-blog.csdnimg.cn/20200329225948126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 可以看到最终的P需要从Ｐ_n以及P_F_n得到，类似解二元一次方程组，这里我们使用sage来快速解方程\n![](https://img-blog.csdnimg.cn/20200329230437741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 接下来解决Q的问题\n![](https://img-blog.csdnimg.cn/20200329230512279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 这里我们拿到了N和e*d，这个问题转变为已知N和e*d，分解N,直接上脚本\n\n```\n#coding=utf-8\nfrom random import randint\nimport gmpy2\ndef oddR(r):\n    while r%2==0:\n        r=r//2\n    return r\n    \ndef bits(b):\n    k=[]\n    while b:\n        if b%2!=0:\n            k.append(1)\n        else:\n            k.append(0)\n        b>>=1\n    k.reverse()      \n    return k\n    \ndef quickmod(a,b,n):      #a^b mod n 快速幂模n运算\n    f=1\n    k=bits(b)\n    for i in range(len(k)):\n        f=(f*f)%n\n        if k[i]:\n            f=(f*a)%n\n    return f\n\ndef gcd(m,n):\n    while(n!=0):\n        m,n=n,m%n\n    return m\n\ndef func(e_d,N):\n    k=e_d-1            \n    r=oddR(k)           #求出k=2^t*r中的r\n    \n    while True:\n        b=randint(2,N-1)    #获取区间(2,N-1)的一个随机数\n        a=quickmod(b,r,N)   \n        if a==1:            \n            continue    \n        y=gcd(a-1,N)\n        if a>1 and y>1:    \n            q=N//y\n            return q\n        else:\n            r=r*2         \n    \ndef deciphering(e_d,n):    、\n    p=func(e_d,n)\n    q=n//p\n    phi=n-(p+q)+1\n    if p*q==n:\n        print p\n        print q\n    else:\n        print\"error\"\n\n\n\nn =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947\ne_d=  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201\ndeciphering(e_d,n)\n```\n\n* 得到Q，最后依旧是RSA的常规解密\n","source":"_posts/MRctf2020密码.md","raw":"title: MRctf2020密码\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - ctf\ndate: 2020-05-29 11:35:00\n---\n# babyrsa\n* 根据主函数可知，首要目的是找到_P和_Q，首先来看_P\n* 可以发现\n![](https://img-blog.csdnimg.cn/20200329224856124.png)\n* 题目已给出P[9],所以直接目的可以手动测试周围素数，直到找到全部（这里是一部分）\n![](https://img-blog.csdnimg.cn/20200329225022887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 这里我们可以得到N\n* \n```\nfactor = pow(p, base, n)\n```\n\n* 这一句说明我们应该将这个简单RSA解出来，此时按照一般RSA的步骤求得d\n![](https://img-blog.csdnimg.cn/20200329225008750.png)\n* 这里已经得到N的所有因数，所以此时N的欧拉函数为所有因数减1相乘，即(p1-1)*(p2-1)*(...)*(p17-1)， 到此得到P的值\n* 接下来是Q\n![](https://img-blog.csdnimg.cn/20200329225330826.png)\n* 可以看到的是所有的参数已经给出，但是如果我们按照这个去算会很慢，因为数值是比较大的，所以这里我们用到了快速幂模\n\n```\nQ_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521\nQ_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743\nsub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651\ndef fastExpMod(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        # b, b^2, b^4, b^8, ... , b^(2^n)\n        b = (b*b) % m\n    return result\n_q=fastExpMod(sub_Q,Q_2 , Q_1)\n_q=sympy.nextprime(_q)\n```\n\n* 通过这个得到最终的Q的值\n* 最后按照常规RSA的解密，完成此题（完整代码）\n\n```\nimport sympy\nimport gmpy2 \nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytes\n\nbase=65537\n\nfactor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839\nn=1\np = [0 for i in range(17)]\np[0]=206027926847308612719677572554991142909\np[1]=206027926847308612719677572554991142911\np[2]=206027926847308612719677572554991142977\np[3]=206027926847308612719677572554991143071\np[4]=206027926847308612719677572554991143103\np[5]=206027926847308612719677572554991143121\np[6]=206027926847308612719677572554991143133\np[7]=206027926847308612719677572554991143317\np[8]=206027926847308612719677572554991143401\np[9]=206027926847308612719677572554991143421\nfor i in range(10,17):\n    p[i]=sympy.nextprime(p[i-1])\n\nfor i in range(17):\n        x= n*p[i]\n        n=x\n\nphi=1\nfor i in range(0,17):\n    phi *=p[i]-1\n\nd1=gmpy2.invert(base,phi)\n_p=pow(factor,d1,n)\n_p=sympy.nextprime(_p)\n\nQ_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521\nQ_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743\nsub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651\ndef fastExpMod(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        # b, b^2, b^4, b^8, ... , b^(2^n)\n        b = (b*b) % m\n    return result\n_q=fastExpMod(sub_Q,Q_2 , Q_1)\n_q=sympy.nextprime(_q)\n\n\nc=  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832\nd=gmpy2.invert(base,(_p-1)*(_q-1))\nm=pow(c,d,_p*_q)\nprint long_to_bytes(m)\n```\n\n# Easy_RSA\n* 与上一题类似，这里我们依旧先从P开始\n![](https://img-blog.csdnimg.cn/20200329225948126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 可以看到最终的P需要从Ｐ_n以及P_F_n得到，类似解二元一次方程组，这里我们使用sage来快速解方程\n![](https://img-blog.csdnimg.cn/20200329230437741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 接下来解决Q的问题\n![](https://img-blog.csdnimg.cn/20200329230512279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70)\n* 这里我们拿到了N和e*d，这个问题转变为已知N和e*d，分解N,直接上脚本\n\n```\n#coding=utf-8\nfrom random import randint\nimport gmpy2\ndef oddR(r):\n    while r%2==0:\n        r=r//2\n    return r\n    \ndef bits(b):\n    k=[]\n    while b:\n        if b%2!=0:\n            k.append(1)\n        else:\n            k.append(0)\n        b>>=1\n    k.reverse()      \n    return k\n    \ndef quickmod(a,b,n):      #a^b mod n 快速幂模n运算\n    f=1\n    k=bits(b)\n    for i in range(len(k)):\n        f=(f*f)%n\n        if k[i]:\n            f=(f*a)%n\n    return f\n\ndef gcd(m,n):\n    while(n!=0):\n        m,n=n,m%n\n    return m\n\ndef func(e_d,N):\n    k=e_d-1            \n    r=oddR(k)           #求出k=2^t*r中的r\n    \n    while True:\n        b=randint(2,N-1)    #获取区间(2,N-1)的一个随机数\n        a=quickmod(b,r,N)   \n        if a==1:            \n            continue    \n        y=gcd(a-1,N)\n        if a>1 and y>1:    \n            q=N//y\n            return q\n        else:\n            r=r*2         \n    \ndef deciphering(e_d,n):    、\n    p=func(e_d,n)\n    q=n//p\n    phi=n-(p+q)+1\n    if p*q==n:\n        print p\n        print q\n    else:\n        print\"error\"\n\n\n\nn =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947\ne_d=  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201\ndeciphering(e_d,n)\n```\n\n* 得到Q，最后依旧是RSA的常规解密\n","slug":"MRctf2020密码","published":1,"updated":"2020-05-29T03:36:12.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18f001uvcu99lhghgpv","content":"<h1 id=\"babyrsa\"><a href=\"#babyrsa\" class=\"headerlink\" title=\"babyrsa\"></a>babyrsa</h1><ul>\n<li><p>根据主函数可知，首要目的是找到_P和_Q，首先来看_P</p>\n</li>\n<li><p>可以发现<br><img src=\"https://img-blog.csdnimg.cn/20200329224856124.png\" alt=\"\"></p>\n</li>\n<li><p>题目已给出P[9],所以直接目的可以手动测试周围素数，直到找到全部（这里是一部分）<br><img src=\"https://img-blog.csdnimg.cn/20200329225022887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n</li>\n<li><p>这里我们可以得到N</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factor &#x3D; pow(p, base, n)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这一句说明我们应该将这个简单RSA解出来，此时按照一般RSA的步骤求得d<br><img src=\"https://img-blog.csdnimg.cn/20200329225008750.png\" alt=\"\"></p>\n</li>\n<li><p>这里已经得到N的所有因数，所以此时N的欧拉函数为所有因数减1相乘，即(p1-1)<em>(p2-1)</em>(…)*(p17-1)， 到此得到P的值</p>\n</li>\n<li><p>接下来是Q<br><img src=\"https://img-blog.csdnimg.cn/20200329225330826.png\" alt=\"\"></p>\n</li>\n<li><p>可以看到的是所有的参数已经给出，但是如果我们按照这个去算会很慢，因为数值是比较大的，所以这里我们用到了快速幂模</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q_1&#x3D;  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span><br><span class=\"line\">Q_2&#x3D;  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span><br><span class=\"line\">sub_Q&#x3D; 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span><br><span class=\"line\">def fastExpMod(b, e, m):</span><br><span class=\"line\">    result &#x3D; 1</span><br><span class=\"line\">    while e !&#x3D; 0:</span><br><span class=\"line\">        if (e&amp;1) &#x3D;&#x3D; 1:</span><br><span class=\"line\">            # ei &#x3D; 1, then mul</span><br><span class=\"line\">            result &#x3D; (result * b) % m</span><br><span class=\"line\">        e &gt;&gt;&#x3D; 1</span><br><span class=\"line\">        # b, b^2, b^4, b^8, ... , b^(2^n)</span><br><span class=\"line\">        b &#x3D; (b*b) % m</span><br><span class=\"line\">    return result</span><br><span class=\"line\">_q&#x3D;fastExpMod(sub_Q,Q_2 , Q_1)</span><br><span class=\"line\">_q&#x3D;sympy.nextprime(_q)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过这个得到最终的Q的值</li>\n<li>最后按照常规RSA的解密，完成此题（完整代码）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\">import gmpy2 </span><br><span class=\"line\">from Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytes</span><br><span class=\"line\"></span><br><span class=\"line\">base&#x3D;65537</span><br><span class=\"line\"></span><br><span class=\"line\">factor &#x3D; 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839</span><br><span class=\"line\">n&#x3D;1</span><br><span class=\"line\">p &#x3D; [0 for i in range(17)]</span><br><span class=\"line\">p[0]&#x3D;206027926847308612719677572554991142909</span><br><span class=\"line\">p[1]&#x3D;206027926847308612719677572554991142911</span><br><span class=\"line\">p[2]&#x3D;206027926847308612719677572554991142977</span><br><span class=\"line\">p[3]&#x3D;206027926847308612719677572554991143071</span><br><span class=\"line\">p[4]&#x3D;206027926847308612719677572554991143103</span><br><span class=\"line\">p[5]&#x3D;206027926847308612719677572554991143121</span><br><span class=\"line\">p[6]&#x3D;206027926847308612719677572554991143133</span><br><span class=\"line\">p[7]&#x3D;206027926847308612719677572554991143317</span><br><span class=\"line\">p[8]&#x3D;206027926847308612719677572554991143401</span><br><span class=\"line\">p[9]&#x3D;206027926847308612719677572554991143421</span><br><span class=\"line\">for i in range(10,17):</span><br><span class=\"line\">    p[i]&#x3D;sympy.nextprime(p[i-1])</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(17):</span><br><span class=\"line\">        x&#x3D; n*p[i]</span><br><span class=\"line\">        n&#x3D;x</span><br><span class=\"line\"></span><br><span class=\"line\">phi&#x3D;1</span><br><span class=\"line\">for i in range(0,17):</span><br><span class=\"line\">    phi *&#x3D;p[i]-1</span><br><span class=\"line\"></span><br><span class=\"line\">d1&#x3D;gmpy2.invert(base,phi)</span><br><span class=\"line\">_p&#x3D;pow(factor,d1,n)</span><br><span class=\"line\">_p&#x3D;sympy.nextprime(_p)</span><br><span class=\"line\"></span><br><span class=\"line\">Q_1&#x3D;  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span><br><span class=\"line\">Q_2&#x3D;  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span><br><span class=\"line\">sub_Q&#x3D; 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span><br><span class=\"line\">def fastExpMod(b, e, m):</span><br><span class=\"line\">    result &#x3D; 1</span><br><span class=\"line\">    while e !&#x3D; 0:</span><br><span class=\"line\">        if (e&amp;1) &#x3D;&#x3D; 1:</span><br><span class=\"line\">            # ei &#x3D; 1, then mul</span><br><span class=\"line\">            result &#x3D; (result * b) % m</span><br><span class=\"line\">        e &gt;&gt;&#x3D; 1</span><br><span class=\"line\">        # b, b^2, b^4, b^8, ... , b^(2^n)</span><br><span class=\"line\">        b &#x3D; (b*b) % m</span><br><span class=\"line\">    return result</span><br><span class=\"line\">_q&#x3D;fastExpMod(sub_Q,Q_2 , Q_1)</span><br><span class=\"line\">_q&#x3D;sympy.nextprime(_q)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">c&#x3D;  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832</span><br><span class=\"line\">d&#x3D;gmpy2.invert(base,(_p-1)*(_q-1))</span><br><span class=\"line\">m&#x3D;pow(c,d,_p*_q)</span><br><span class=\"line\">print long_to_bytes(m)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Easy-RSA\"><a href=\"#Easy-RSA\" class=\"headerlink\" title=\"Easy_RSA\"></a>Easy_RSA</h1><ul>\n<li>与上一题类似，这里我们依旧先从P开始<br><img src=\"https://img-blog.csdnimg.cn/20200329225948126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>可以看到最终的P需要从Ｐ_n以及P_F_n得到，类似解二元一次方程组，这里我们使用sage来快速解方程<br><img src=\"https://img-blog.csdnimg.cn/20200329230437741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>接下来解决Q的问题<br><img src=\"https://img-blog.csdnimg.cn/20200329230512279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>这里我们拿到了N和e<em>d，这个问题转变为已知N和e</em>d，分解N,直接上脚本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding&#x3D;utf-8</span><br><span class=\"line\">from random import randint</span><br><span class=\"line\">import gmpy2</span><br><span class=\"line\">def oddR(r):</span><br><span class=\"line\">    while r%2&#x3D;&#x3D;0:</span><br><span class=\"line\">        r&#x3D;r&#x2F;&#x2F;2</span><br><span class=\"line\">    return r</span><br><span class=\"line\">    </span><br><span class=\"line\">def bits(b):</span><br><span class=\"line\">    k&#x3D;[]</span><br><span class=\"line\">    while b:</span><br><span class=\"line\">        if b%2!&#x3D;0:</span><br><span class=\"line\">            k.append(1)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            k.append(0)</span><br><span class=\"line\">        b&gt;&gt;&#x3D;1</span><br><span class=\"line\">    k.reverse()      </span><br><span class=\"line\">    return k</span><br><span class=\"line\">    </span><br><span class=\"line\">def quickmod(a,b,n):      #a^b mod n 快速幂模n运算</span><br><span class=\"line\">    f&#x3D;1</span><br><span class=\"line\">    k&#x3D;bits(b)</span><br><span class=\"line\">    for i in range(len(k)):</span><br><span class=\"line\">        f&#x3D;(f*f)%n</span><br><span class=\"line\">        if k[i]:</span><br><span class=\"line\">            f&#x3D;(f*a)%n</span><br><span class=\"line\">    return f</span><br><span class=\"line\"></span><br><span class=\"line\">def gcd(m,n):</span><br><span class=\"line\">    while(n!&#x3D;0):</span><br><span class=\"line\">        m,n&#x3D;n,m%n</span><br><span class=\"line\">    return m</span><br><span class=\"line\"></span><br><span class=\"line\">def func(e_d,N):</span><br><span class=\"line\">    k&#x3D;e_d-1            </span><br><span class=\"line\">    r&#x3D;oddR(k)           #求出k&#x3D;2^t*r中的r</span><br><span class=\"line\">    </span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        b&#x3D;randint(2,N-1)    #获取区间(2,N-1)的一个随机数</span><br><span class=\"line\">        a&#x3D;quickmod(b,r,N)   </span><br><span class=\"line\">        if a&#x3D;&#x3D;1:            </span><br><span class=\"line\">            continue    </span><br><span class=\"line\">        y&#x3D;gcd(a-1,N)</span><br><span class=\"line\">        if a&gt;1 and y&gt;1:    </span><br><span class=\"line\">            q&#x3D;N&#x2F;&#x2F;y</span><br><span class=\"line\">            return q</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            r&#x3D;r*2         </span><br><span class=\"line\">    </span><br><span class=\"line\">def deciphering(e_d,n):    、</span><br><span class=\"line\">    p&#x3D;func(e_d,n)</span><br><span class=\"line\">    q&#x3D;n&#x2F;&#x2F;p</span><br><span class=\"line\">    phi&#x3D;n-(p+q)+1</span><br><span class=\"line\">    if p*q&#x3D;&#x3D;n:</span><br><span class=\"line\">        print p</span><br><span class=\"line\">        print q</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print&quot;error&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">n &#x3D;  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947</span><br><span class=\"line\">e_d&#x3D;  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201</span><br><span class=\"line\">deciphering(e_d,n)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>得到Q，最后依旧是RSA的常规解密</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"babyrsa\"><a href=\"#babyrsa\" class=\"headerlink\" title=\"babyrsa\"></a>babyrsa</h1><ul>\n<li><p>根据主函数可知，首要目的是找到_P和_Q，首先来看_P</p>\n</li>\n<li><p>可以发现<br><img src=\"https://img-blog.csdnimg.cn/20200329224856124.png\" alt=\"\"></p>\n</li>\n<li><p>题目已给出P[9],所以直接目的可以手动测试周围素数，直到找到全部（这里是一部分）<br><img src=\"https://img-blog.csdnimg.cn/20200329225022887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n</li>\n<li><p>这里我们可以得到N</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factor &#x3D; pow(p, base, n)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这一句说明我们应该将这个简单RSA解出来，此时按照一般RSA的步骤求得d<br><img src=\"https://img-blog.csdnimg.cn/20200329225008750.png\" alt=\"\"></p>\n</li>\n<li><p>这里已经得到N的所有因数，所以此时N的欧拉函数为所有因数减1相乘，即(p1-1)<em>(p2-1)</em>(…)*(p17-1)， 到此得到P的值</p>\n</li>\n<li><p>接下来是Q<br><img src=\"https://img-blog.csdnimg.cn/20200329225330826.png\" alt=\"\"></p>\n</li>\n<li><p>可以看到的是所有的参数已经给出，但是如果我们按照这个去算会很慢，因为数值是比较大的，所以这里我们用到了快速幂模</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q_1&#x3D;  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span><br><span class=\"line\">Q_2&#x3D;  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span><br><span class=\"line\">sub_Q&#x3D; 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span><br><span class=\"line\">def fastExpMod(b, e, m):</span><br><span class=\"line\">    result &#x3D; 1</span><br><span class=\"line\">    while e !&#x3D; 0:</span><br><span class=\"line\">        if (e&amp;1) &#x3D;&#x3D; 1:</span><br><span class=\"line\">            # ei &#x3D; 1, then mul</span><br><span class=\"line\">            result &#x3D; (result * b) % m</span><br><span class=\"line\">        e &gt;&gt;&#x3D; 1</span><br><span class=\"line\">        # b, b^2, b^4, b^8, ... , b^(2^n)</span><br><span class=\"line\">        b &#x3D; (b*b) % m</span><br><span class=\"line\">    return result</span><br><span class=\"line\">_q&#x3D;fastExpMod(sub_Q,Q_2 , Q_1)</span><br><span class=\"line\">_q&#x3D;sympy.nextprime(_q)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过这个得到最终的Q的值</li>\n<li>最后按照常规RSA的解密，完成此题（完整代码）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\">import gmpy2 </span><br><span class=\"line\">from Crypto.Util.number import getPrime, isPrime, bytes_to_long, long_to_bytes</span><br><span class=\"line\"></span><br><span class=\"line\">base&#x3D;65537</span><br><span class=\"line\"></span><br><span class=\"line\">factor &#x3D; 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839</span><br><span class=\"line\">n&#x3D;1</span><br><span class=\"line\">p &#x3D; [0 for i in range(17)]</span><br><span class=\"line\">p[0]&#x3D;206027926847308612719677572554991142909</span><br><span class=\"line\">p[1]&#x3D;206027926847308612719677572554991142911</span><br><span class=\"line\">p[2]&#x3D;206027926847308612719677572554991142977</span><br><span class=\"line\">p[3]&#x3D;206027926847308612719677572554991143071</span><br><span class=\"line\">p[4]&#x3D;206027926847308612719677572554991143103</span><br><span class=\"line\">p[5]&#x3D;206027926847308612719677572554991143121</span><br><span class=\"line\">p[6]&#x3D;206027926847308612719677572554991143133</span><br><span class=\"line\">p[7]&#x3D;206027926847308612719677572554991143317</span><br><span class=\"line\">p[8]&#x3D;206027926847308612719677572554991143401</span><br><span class=\"line\">p[9]&#x3D;206027926847308612719677572554991143421</span><br><span class=\"line\">for i in range(10,17):</span><br><span class=\"line\">    p[i]&#x3D;sympy.nextprime(p[i-1])</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(17):</span><br><span class=\"line\">        x&#x3D; n*p[i]</span><br><span class=\"line\">        n&#x3D;x</span><br><span class=\"line\"></span><br><span class=\"line\">phi&#x3D;1</span><br><span class=\"line\">for i in range(0,17):</span><br><span class=\"line\">    phi *&#x3D;p[i]-1</span><br><span class=\"line\"></span><br><span class=\"line\">d1&#x3D;gmpy2.invert(base,phi)</span><br><span class=\"line\">_p&#x3D;pow(factor,d1,n)</span><br><span class=\"line\">_p&#x3D;sympy.nextprime(_p)</span><br><span class=\"line\"></span><br><span class=\"line\">Q_1&#x3D;  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span><br><span class=\"line\">Q_2&#x3D;  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span><br><span class=\"line\">sub_Q&#x3D; 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span><br><span class=\"line\">def fastExpMod(b, e, m):</span><br><span class=\"line\">    result &#x3D; 1</span><br><span class=\"line\">    while e !&#x3D; 0:</span><br><span class=\"line\">        if (e&amp;1) &#x3D;&#x3D; 1:</span><br><span class=\"line\">            # ei &#x3D; 1, then mul</span><br><span class=\"line\">            result &#x3D; (result * b) % m</span><br><span class=\"line\">        e &gt;&gt;&#x3D; 1</span><br><span class=\"line\">        # b, b^2, b^4, b^8, ... , b^(2^n)</span><br><span class=\"line\">        b &#x3D; (b*b) % m</span><br><span class=\"line\">    return result</span><br><span class=\"line\">_q&#x3D;fastExpMod(sub_Q,Q_2 , Q_1)</span><br><span class=\"line\">_q&#x3D;sympy.nextprime(_q)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">c&#x3D;  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832</span><br><span class=\"line\">d&#x3D;gmpy2.invert(base,(_p-1)*(_q-1))</span><br><span class=\"line\">m&#x3D;pow(c,d,_p*_q)</span><br><span class=\"line\">print long_to_bytes(m)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Easy-RSA\"><a href=\"#Easy-RSA\" class=\"headerlink\" title=\"Easy_RSA\"></a>Easy_RSA</h1><ul>\n<li>与上一题类似，这里我们依旧先从P开始<br><img src=\"https://img-blog.csdnimg.cn/20200329225948126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>可以看到最终的P需要从Ｐ_n以及P_F_n得到，类似解二元一次方程组，这里我们使用sage来快速解方程<br><img src=\"https://img-blog.csdnimg.cn/20200329230437741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>接下来解决Q的问题<br><img src=\"https://img-blog.csdnimg.cn/20200329230512279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE1OTU5OA==,size_16,color_FFFFFF,t_70\" alt=\"\"></li>\n<li>这里我们拿到了N和e<em>d，这个问题转变为已知N和e</em>d，分解N,直接上脚本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding&#x3D;utf-8</span><br><span class=\"line\">from random import randint</span><br><span class=\"line\">import gmpy2</span><br><span class=\"line\">def oddR(r):</span><br><span class=\"line\">    while r%2&#x3D;&#x3D;0:</span><br><span class=\"line\">        r&#x3D;r&#x2F;&#x2F;2</span><br><span class=\"line\">    return r</span><br><span class=\"line\">    </span><br><span class=\"line\">def bits(b):</span><br><span class=\"line\">    k&#x3D;[]</span><br><span class=\"line\">    while b:</span><br><span class=\"line\">        if b%2!&#x3D;0:</span><br><span class=\"line\">            k.append(1)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            k.append(0)</span><br><span class=\"line\">        b&gt;&gt;&#x3D;1</span><br><span class=\"line\">    k.reverse()      </span><br><span class=\"line\">    return k</span><br><span class=\"line\">    </span><br><span class=\"line\">def quickmod(a,b,n):      #a^b mod n 快速幂模n运算</span><br><span class=\"line\">    f&#x3D;1</span><br><span class=\"line\">    k&#x3D;bits(b)</span><br><span class=\"line\">    for i in range(len(k)):</span><br><span class=\"line\">        f&#x3D;(f*f)%n</span><br><span class=\"line\">        if k[i]:</span><br><span class=\"line\">            f&#x3D;(f*a)%n</span><br><span class=\"line\">    return f</span><br><span class=\"line\"></span><br><span class=\"line\">def gcd(m,n):</span><br><span class=\"line\">    while(n!&#x3D;0):</span><br><span class=\"line\">        m,n&#x3D;n,m%n</span><br><span class=\"line\">    return m</span><br><span class=\"line\"></span><br><span class=\"line\">def func(e_d,N):</span><br><span class=\"line\">    k&#x3D;e_d-1            </span><br><span class=\"line\">    r&#x3D;oddR(k)           #求出k&#x3D;2^t*r中的r</span><br><span class=\"line\">    </span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        b&#x3D;randint(2,N-1)    #获取区间(2,N-1)的一个随机数</span><br><span class=\"line\">        a&#x3D;quickmod(b,r,N)   </span><br><span class=\"line\">        if a&#x3D;&#x3D;1:            </span><br><span class=\"line\">            continue    </span><br><span class=\"line\">        y&#x3D;gcd(a-1,N)</span><br><span class=\"line\">        if a&gt;1 and y&gt;1:    </span><br><span class=\"line\">            q&#x3D;N&#x2F;&#x2F;y</span><br><span class=\"line\">            return q</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            r&#x3D;r*2         </span><br><span class=\"line\">    </span><br><span class=\"line\">def deciphering(e_d,n):    、</span><br><span class=\"line\">    p&#x3D;func(e_d,n)</span><br><span class=\"line\">    q&#x3D;n&#x2F;&#x2F;p</span><br><span class=\"line\">    phi&#x3D;n-(p+q)+1</span><br><span class=\"line\">    if p*q&#x3D;&#x3D;n:</span><br><span class=\"line\">        print p</span><br><span class=\"line\">        print q</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print&quot;error&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">n &#x3D;  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947</span><br><span class=\"line\">e_d&#x3D;  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201</span><br><span class=\"line\">deciphering(e_d,n)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>得到Q，最后依旧是RSA的常规解密</li>\n</ul>\n"},{"title":"lcg线性同余随机数生成器","author":"人生若只如初见","date":"2020-05-28T01:49:00.000Z","_content":"# 随机数\n* 计算机产生随机数在概率算法设计中，随机数分为真随机数和伪随机数，计算机只能产生伪随机数。\n* 真随机数：类似放射性元素的衰变等无法控制的且无法复制数据\n* 伪随机数：通过较为容量大的数学公式产生的数字，具有可猜测性。在得到生成器的随机数种子之后，可以通过计算得到伪随机数序列。\n* 通用性伪随机数生成器：s0=seed,s[i+1]=f(s[i])，推广形式：s[i+1]=f(s[i],s[i-1],……,s[i-t])，其中t是固定整数。\n* 满足通用性伪随机数的推广的例子，线性同余生成器：s0=seed,s[i+1]=a*s[i]+b mod m,(i=0,1,2……)\n# 线性同余生成器\n## 线性同余序列的周期\n* 在线性同余序列中存在自封闭特性，具有以下性质\n\n```\n1、存在递推关系：x[i+1]=f(x[i])\n2、其中的任意元素x[i]都在[0,m-1]范围内\n3、f(x)的值也在[0,m-1]范围内\n```\n\n* 性质证明及周期计算\n\n```\n1、假设两个集合s={0,1,2,3,……,m-2,m-1} size(s)=m\n    T={} size(T)=0\n    将产生的伪随机数挪到集合T中\n2、先生成第一个伪随机数x1\n    s={0,1,2,3,……,m-2,m-1} size(s)=m\n    T={x1} size(T)=1\n3、根据第一个伪随机数x1生成第二个伪随机数x2，判断x2的归属，若x2属于集合s则一个周期还未结束，若x2属于集合T此处正好等于x1则一个周期产生，周期p=1\n\n推论到x[i]即生成的每个x都属于s，都转移到T\n此时：s={0,1,2,3,……,m-2,m-1} size(s)=m\n      T={x1,x2,x3,……,x[i-2],x[i-1]} size(T)=i-1\n若x[i]=f(x[i-1])∈s，则未能完成一周期\n若x[i]=f(x[i-1])∈T，则已完成一个周期，周期p≤i-1\n\n周期p也可能等于m，也就是最终s为空集，T中包含0到m-1的所有元素，且f(X[m])=x1\n因此一定存在一个周期p≤m\n推论：\n    1) 当周期p＜m时，选取不同的随机数种子也就是x0(初始值)产生的周期可能会不同。\n    2) 当周期p=m时，序列的周期与初始值x0无关，周期必定为p。\n```\n\n\n## 参数选择\n### m的选择\n* 一般来说，模数应该尽可能大，这样可以产生较长的周期，常见的模数挑选一般为2**w（常用的为2^32或者2^64，产生结果直接截断最右边的32bit或者64bit）\n* 当模数为2**w的时候，最后产生未模之前的数字与最后的结果相比，是该数字的比特位向右边减w位的结果，这种形式在低位上的随机性并不是很好。可以在产生随机数后截取高位比特，将随机性不好的低位比特直接舍弃。\n### a的选择（0≤a<m）\n* a的取值会很大程度上影响整个生成器的安全性，应该使周期尽量长（最长为m），但是周期长的序列随机性比较差。\n* 当a=1时，生成器的公式为s[i+1]=s[i]+b mod m\n* 当a=0时，生成器的公式为s[i+1]=b mod m，安全性为0.\n* 当a取值其他数字时，影响随机数生成器生成数字的周期。\n### 选取参数的总结\n* 模数m尽可能大，一般大于2**30\n* 当m选取为2的幂次方时，应该满足a mod 8=5\n* 当m和a选取都合理时，b需要在与m互质的条件下选取。\n### 最大周期符合的条件：\n* m和b互质\n* m的所有质因子的积能整除a-1\n* 如果m是4的倍数，a-1也是\n* a,b,seed都比m小\n* a,b是正整数\n\n\n# 例题\n\n![](/images/pasted-20.png)\n* 根据线性同余生成器lcg可得：lcg=(a*x+c)%m\n* 根据题目，当输入数字时，可以得到多个连续随机数，根据伪随机数生成的机制，可以了解到，随机数的生成只要知道随机数种子就可以破解\n* 类推到线性同余方程组，也就是说当知道a,c,m时即可知道随机数的整个序列\n* 例如：假设我们知道lcg0,那么lcg1=(a*lcg0+c)%m,同理lcg2=(a*lcg1+c)%m\n* 此时我们随意提交多次，可以从中得到连续的随机数，类比于lcg0,lcg1,lcg2的关系\n* lcg0=32081     lcg1=23815     lcg2=1237   lcg3=2387\n* 爆破模数module，每次moudle值改变时，都进行下面的操作：\n\n```\nlcg1=(a*lcg0+c)%m       lcg2=(a*lcg1+c)%m\n\n两式相减   左边为:lcg2-lcg1   右边为:(a*lcg1+c)-(a*lcg0+c)\n\n化简为: [lcg2-lcg1=a*(lcg1-lcg0) ] %m\n\n根据求余运算规则可知  \n[a=(lcg2-lcg1)*gmpy2.invert(lcg1-lcg0,m)]%m\n\n此时代入lcg0,lcg1,lcg2之后可求得a\n\n代入lcg1=(a*lcg0+c)%m,把c当作未知数放到等式左边后，式子为：\nc=[lcg1*gmpy2.invert(a*lcg0,m)]%m\n\n类推lcg3_guess=(a*lcg2+c)%m\n将求得地lcg3_guess与lcg3比较，如果相等，证明求得的a,c,m为正确值\n否则，m=m+1，继续验证\n\n注意：\n1、这个式子成立条件是两边同时对m求余\n2、gmpy2.invert(x1,x2)是求与x1%x2同余的最小数，二者在求余操作后等价，因为余数相等，该式表示余数，类似7%5=2%5\n```\n\n\n* 求得正确的a,c,m之后，线性同余方程为 lcg[i]=(a*lcg[i-1]+c)%m\n* 多次提交成功之后，获得flag","source":"_posts/lcg线性同余随机数生成器.md","raw":"title: lcg线性同余随机数生成器\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 随机数\ndate: 2020-05-28 09:49:00\n---\n# 随机数\n* 计算机产生随机数在概率算法设计中，随机数分为真随机数和伪随机数，计算机只能产生伪随机数。\n* 真随机数：类似放射性元素的衰变等无法控制的且无法复制数据\n* 伪随机数：通过较为容量大的数学公式产生的数字，具有可猜测性。在得到生成器的随机数种子之后，可以通过计算得到伪随机数序列。\n* 通用性伪随机数生成器：s0=seed,s[i+1]=f(s[i])，推广形式：s[i+1]=f(s[i],s[i-1],……,s[i-t])，其中t是固定整数。\n* 满足通用性伪随机数的推广的例子，线性同余生成器：s0=seed,s[i+1]=a*s[i]+b mod m,(i=0,1,2……)\n# 线性同余生成器\n## 线性同余序列的周期\n* 在线性同余序列中存在自封闭特性，具有以下性质\n\n```\n1、存在递推关系：x[i+1]=f(x[i])\n2、其中的任意元素x[i]都在[0,m-1]范围内\n3、f(x)的值也在[0,m-1]范围内\n```\n\n* 性质证明及周期计算\n\n```\n1、假设两个集合s={0,1,2,3,……,m-2,m-1} size(s)=m\n    T={} size(T)=0\n    将产生的伪随机数挪到集合T中\n2、先生成第一个伪随机数x1\n    s={0,1,2,3,……,m-2,m-1} size(s)=m\n    T={x1} size(T)=1\n3、根据第一个伪随机数x1生成第二个伪随机数x2，判断x2的归属，若x2属于集合s则一个周期还未结束，若x2属于集合T此处正好等于x1则一个周期产生，周期p=1\n\n推论到x[i]即生成的每个x都属于s，都转移到T\n此时：s={0,1,2,3,……,m-2,m-1} size(s)=m\n      T={x1,x2,x3,……,x[i-2],x[i-1]} size(T)=i-1\n若x[i]=f(x[i-1])∈s，则未能完成一周期\n若x[i]=f(x[i-1])∈T，则已完成一个周期，周期p≤i-1\n\n周期p也可能等于m，也就是最终s为空集，T中包含0到m-1的所有元素，且f(X[m])=x1\n因此一定存在一个周期p≤m\n推论：\n    1) 当周期p＜m时，选取不同的随机数种子也就是x0(初始值)产生的周期可能会不同。\n    2) 当周期p=m时，序列的周期与初始值x0无关，周期必定为p。\n```\n\n\n## 参数选择\n### m的选择\n* 一般来说，模数应该尽可能大，这样可以产生较长的周期，常见的模数挑选一般为2**w（常用的为2^32或者2^64，产生结果直接截断最右边的32bit或者64bit）\n* 当模数为2**w的时候，最后产生未模之前的数字与最后的结果相比，是该数字的比特位向右边减w位的结果，这种形式在低位上的随机性并不是很好。可以在产生随机数后截取高位比特，将随机性不好的低位比特直接舍弃。\n### a的选择（0≤a<m）\n* a的取值会很大程度上影响整个生成器的安全性，应该使周期尽量长（最长为m），但是周期长的序列随机性比较差。\n* 当a=1时，生成器的公式为s[i+1]=s[i]+b mod m\n* 当a=0时，生成器的公式为s[i+1]=b mod m，安全性为0.\n* 当a取值其他数字时，影响随机数生成器生成数字的周期。\n### 选取参数的总结\n* 模数m尽可能大，一般大于2**30\n* 当m选取为2的幂次方时，应该满足a mod 8=5\n* 当m和a选取都合理时，b需要在与m互质的条件下选取。\n### 最大周期符合的条件：\n* m和b互质\n* m的所有质因子的积能整除a-1\n* 如果m是4的倍数，a-1也是\n* a,b,seed都比m小\n* a,b是正整数\n\n\n# 例题\n\n![](/images/pasted-20.png)\n* 根据线性同余生成器lcg可得：lcg=(a*x+c)%m\n* 根据题目，当输入数字时，可以得到多个连续随机数，根据伪随机数生成的机制，可以了解到，随机数的生成只要知道随机数种子就可以破解\n* 类推到线性同余方程组，也就是说当知道a,c,m时即可知道随机数的整个序列\n* 例如：假设我们知道lcg0,那么lcg1=(a*lcg0+c)%m,同理lcg2=(a*lcg1+c)%m\n* 此时我们随意提交多次，可以从中得到连续的随机数，类比于lcg0,lcg1,lcg2的关系\n* lcg0=32081     lcg1=23815     lcg2=1237   lcg3=2387\n* 爆破模数module，每次moudle值改变时，都进行下面的操作：\n\n```\nlcg1=(a*lcg0+c)%m       lcg2=(a*lcg1+c)%m\n\n两式相减   左边为:lcg2-lcg1   右边为:(a*lcg1+c)-(a*lcg0+c)\n\n化简为: [lcg2-lcg1=a*(lcg1-lcg0) ] %m\n\n根据求余运算规则可知  \n[a=(lcg2-lcg1)*gmpy2.invert(lcg1-lcg0,m)]%m\n\n此时代入lcg0,lcg1,lcg2之后可求得a\n\n代入lcg1=(a*lcg0+c)%m,把c当作未知数放到等式左边后，式子为：\nc=[lcg1*gmpy2.invert(a*lcg0,m)]%m\n\n类推lcg3_guess=(a*lcg2+c)%m\n将求得地lcg3_guess与lcg3比较，如果相等，证明求得的a,c,m为正确值\n否则，m=m+1，继续验证\n\n注意：\n1、这个式子成立条件是两边同时对m求余\n2、gmpy2.invert(x1,x2)是求与x1%x2同余的最小数，二者在求余操作后等价，因为余数相等，该式表示余数，类似7%5=2%5\n```\n\n\n* 求得正确的a,c,m之后，线性同余方程为 lcg[i]=(a*lcg[i-1]+c)%m\n* 多次提交成功之后，获得flag","slug":"lcg线性同余随机数生成器","published":1,"updated":"2020-05-28T01:51:13.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18g001vvcu917pjcyhd","content":"<h1 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h1><ul>\n<li>计算机产生随机数在概率算法设计中，随机数分为真随机数和伪随机数，计算机只能产生伪随机数。</li>\n<li>真随机数：类似放射性元素的衰变等无法控制的且无法复制数据</li>\n<li>伪随机数：通过较为容量大的数学公式产生的数字，具有可猜测性。在得到生成器的随机数种子之后，可以通过计算得到伪随机数序列。</li>\n<li>通用性伪随机数生成器：s0=seed,s[i+1]=f(s[i])，推广形式：s[i+1]=f(s[i],s[i-1],……,s[i-t])，其中t是固定整数。</li>\n<li>满足通用性伪随机数的推广的例子，线性同余生成器：s0=seed,s[i+1]=a*s[i]+b mod m,(i=0,1,2……)<h1 id=\"线性同余生成器\"><a href=\"#线性同余生成器\" class=\"headerlink\" title=\"线性同余生成器\"></a>线性同余生成器</h1><h2 id=\"线性同余序列的周期\"><a href=\"#线性同余序列的周期\" class=\"headerlink\" title=\"线性同余序列的周期\"></a>线性同余序列的周期</h2></li>\n<li>在线性同余序列中存在自封闭特性，具有以下性质</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、存在递推关系：x[i+1]&#x3D;f(x[i])</span><br><span class=\"line\">2、其中的任意元素x[i]都在[0,m-1]范围内</span><br><span class=\"line\">3、f(x)的值也在[0,m-1]范围内</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>性质证明及周期计算</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、假设两个集合s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">    T&#x3D;&#123;&#125; size(T)&#x3D;0</span><br><span class=\"line\">    将产生的伪随机数挪到集合T中</span><br><span class=\"line\">2、先生成第一个伪随机数x1</span><br><span class=\"line\">    s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">    T&#x3D;&#123;x1&#125; size(T)&#x3D;1</span><br><span class=\"line\">3、根据第一个伪随机数x1生成第二个伪随机数x2，判断x2的归属，若x2属于集合s则一个周期还未结束，若x2属于集合T此处正好等于x1则一个周期产生，周期p&#x3D;1</span><br><span class=\"line\"></span><br><span class=\"line\">推论到x[i]即生成的每个x都属于s，都转移到T</span><br><span class=\"line\">此时：s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">      T&#x3D;&#123;x1,x2,x3,……,x[i-2],x[i-1]&#125; size(T)&#x3D;i-1</span><br><span class=\"line\">若x[i]&#x3D;f(x[i-1])∈s，则未能完成一周期</span><br><span class=\"line\">若x[i]&#x3D;f(x[i-1])∈T，则已完成一个周期，周期p≤i-1</span><br><span class=\"line\"></span><br><span class=\"line\">周期p也可能等于m，也就是最终s为空集，T中包含0到m-1的所有元素，且f(X[m])&#x3D;x1</span><br><span class=\"line\">因此一定存在一个周期p≤m</span><br><span class=\"line\">推论：</span><br><span class=\"line\">    1) 当周期p＜m时，选取不同的随机数种子也就是x0(初始值)产生的周期可能会不同。</span><br><span class=\"line\">    2) 当周期p&#x3D;m时，序列的周期与初始值x0无关，周期必定为p。</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"参数选择\"><a href=\"#参数选择\" class=\"headerlink\" title=\"参数选择\"></a>参数选择</h2><h3 id=\"m的选择\"><a href=\"#m的选择\" class=\"headerlink\" title=\"m的选择\"></a>m的选择</h3><ul>\n<li>一般来说，模数应该尽可能大，这样可以产生较长的周期，常见的模数挑选一般为2**w（常用的为2^32或者2^64，产生结果直接截断最右边的32bit或者64bit）</li>\n<li>当模数为2**w的时候，最后产生未模之前的数字与最后的结果相比，是该数字的比特位向右边减w位的结果，这种形式在低位上的随机性并不是很好。可以在产生随机数后截取高位比特，将随机性不好的低位比特直接舍弃。<h3 id=\"a的选择（0≤a-lt-m）\"><a href=\"#a的选择（0≤a-lt-m）\" class=\"headerlink\" title=\"a的选择（0≤a&lt;m）\"></a>a的选择（0≤a&lt;m）</h3></li>\n<li>a的取值会很大程度上影响整个生成器的安全性，应该使周期尽量长（最长为m），但是周期长的序列随机性比较差。</li>\n<li>当a=1时，生成器的公式为s[i+1]=s[i]+b mod m</li>\n<li>当a=0时，生成器的公式为s[i+1]=b mod m，安全性为0.</li>\n<li>当a取值其他数字时，影响随机数生成器生成数字的周期。<h3 id=\"选取参数的总结\"><a href=\"#选取参数的总结\" class=\"headerlink\" title=\"选取参数的总结\"></a>选取参数的总结</h3></li>\n<li>模数m尽可能大，一般大于2**30</li>\n<li>当m选取为2的幂次方时，应该满足a mod 8=5</li>\n<li>当m和a选取都合理时，b需要在与m互质的条件下选取。<h3 id=\"最大周期符合的条件：\"><a href=\"#最大周期符合的条件：\" class=\"headerlink\" title=\"最大周期符合的条件：\"></a>最大周期符合的条件：</h3></li>\n<li>m和b互质</li>\n<li>m的所有质因子的积能整除a-1</li>\n<li>如果m是4的倍数，a-1也是</li>\n<li>a,b,seed都比m小</li>\n<li>a,b是正整数</li>\n</ul>\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><p><img src=\"/images/pasted-20.png\" alt=\"\"></p>\n<ul>\n<li>根据线性同余生成器lcg可得：lcg=(a*x+c)%m</li>\n<li>根据题目，当输入数字时，可以得到多个连续随机数，根据伪随机数生成的机制，可以了解到，随机数的生成只要知道随机数种子就可以破解</li>\n<li>类推到线性同余方程组，也就是说当知道a,c,m时即可知道随机数的整个序列</li>\n<li>例如：假设我们知道lcg0,那么lcg1=(a<em>lcg0+c)%m,同理lcg2=(a</em>lcg1+c)%m</li>\n<li>此时我们随意提交多次，可以从中得到连续的随机数，类比于lcg0,lcg1,lcg2的关系</li>\n<li>lcg0=32081     lcg1=23815     lcg2=1237   lcg3=2387</li>\n<li>爆破模数module，每次moudle值改变时，都进行下面的操作：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lcg1&#x3D;(a*lcg0+c)%m       lcg2&#x3D;(a*lcg1+c)%m</span><br><span class=\"line\"></span><br><span class=\"line\">两式相减   左边为:lcg2-lcg1   右边为:(a*lcg1+c)-(a*lcg0+c)</span><br><span class=\"line\"></span><br><span class=\"line\">化简为: [lcg2-lcg1&#x3D;a*(lcg1-lcg0) ] %m</span><br><span class=\"line\"></span><br><span class=\"line\">根据求余运算规则可知  </span><br><span class=\"line\">[a&#x3D;(lcg2-lcg1)*gmpy2.invert(lcg1-lcg0,m)]%m</span><br><span class=\"line\"></span><br><span class=\"line\">此时代入lcg0,lcg1,lcg2之后可求得a</span><br><span class=\"line\"></span><br><span class=\"line\">代入lcg1&#x3D;(a*lcg0+c)%m,把c当作未知数放到等式左边后，式子为：</span><br><span class=\"line\">c&#x3D;[lcg1*gmpy2.invert(a*lcg0,m)]%m</span><br><span class=\"line\"></span><br><span class=\"line\">类推lcg3_guess&#x3D;(a*lcg2+c)%m</span><br><span class=\"line\">将求得地lcg3_guess与lcg3比较，如果相等，证明求得的a,c,m为正确值</span><br><span class=\"line\">否则，m&#x3D;m+1，继续验证</span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\">1、这个式子成立条件是两边同时对m求余</span><br><span class=\"line\">2、gmpy2.invert(x1,x2)是求与x1%x2同余的最小数，二者在求余操作后等价，因为余数相等，该式表示余数，类似7%5&#x3D;2%5</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>求得正确的a,c,m之后，线性同余方程为 lcg[i]=(a*lcg[i-1]+c)%m</li>\n<li>多次提交成功之后，获得flag</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h1><ul>\n<li>计算机产生随机数在概率算法设计中，随机数分为真随机数和伪随机数，计算机只能产生伪随机数。</li>\n<li>真随机数：类似放射性元素的衰变等无法控制的且无法复制数据</li>\n<li>伪随机数：通过较为容量大的数学公式产生的数字，具有可猜测性。在得到生成器的随机数种子之后，可以通过计算得到伪随机数序列。</li>\n<li>通用性伪随机数生成器：s0=seed,s[i+1]=f(s[i])，推广形式：s[i+1]=f(s[i],s[i-1],……,s[i-t])，其中t是固定整数。</li>\n<li>满足通用性伪随机数的推广的例子，线性同余生成器：s0=seed,s[i+1]=a*s[i]+b mod m,(i=0,1,2……)<h1 id=\"线性同余生成器\"><a href=\"#线性同余生成器\" class=\"headerlink\" title=\"线性同余生成器\"></a>线性同余生成器</h1><h2 id=\"线性同余序列的周期\"><a href=\"#线性同余序列的周期\" class=\"headerlink\" title=\"线性同余序列的周期\"></a>线性同余序列的周期</h2></li>\n<li>在线性同余序列中存在自封闭特性，具有以下性质</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、存在递推关系：x[i+1]&#x3D;f(x[i])</span><br><span class=\"line\">2、其中的任意元素x[i]都在[0,m-1]范围内</span><br><span class=\"line\">3、f(x)的值也在[0,m-1]范围内</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>性质证明及周期计算</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、假设两个集合s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">    T&#x3D;&#123;&#125; size(T)&#x3D;0</span><br><span class=\"line\">    将产生的伪随机数挪到集合T中</span><br><span class=\"line\">2、先生成第一个伪随机数x1</span><br><span class=\"line\">    s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">    T&#x3D;&#123;x1&#125; size(T)&#x3D;1</span><br><span class=\"line\">3、根据第一个伪随机数x1生成第二个伪随机数x2，判断x2的归属，若x2属于集合s则一个周期还未结束，若x2属于集合T此处正好等于x1则一个周期产生，周期p&#x3D;1</span><br><span class=\"line\"></span><br><span class=\"line\">推论到x[i]即生成的每个x都属于s，都转移到T</span><br><span class=\"line\">此时：s&#x3D;&#123;0,1,2,3,……,m-2,m-1&#125; size(s)&#x3D;m</span><br><span class=\"line\">      T&#x3D;&#123;x1,x2,x3,……,x[i-2],x[i-1]&#125; size(T)&#x3D;i-1</span><br><span class=\"line\">若x[i]&#x3D;f(x[i-1])∈s，则未能完成一周期</span><br><span class=\"line\">若x[i]&#x3D;f(x[i-1])∈T，则已完成一个周期，周期p≤i-1</span><br><span class=\"line\"></span><br><span class=\"line\">周期p也可能等于m，也就是最终s为空集，T中包含0到m-1的所有元素，且f(X[m])&#x3D;x1</span><br><span class=\"line\">因此一定存在一个周期p≤m</span><br><span class=\"line\">推论：</span><br><span class=\"line\">    1) 当周期p＜m时，选取不同的随机数种子也就是x0(初始值)产生的周期可能会不同。</span><br><span class=\"line\">    2) 当周期p&#x3D;m时，序列的周期与初始值x0无关，周期必定为p。</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"参数选择\"><a href=\"#参数选择\" class=\"headerlink\" title=\"参数选择\"></a>参数选择</h2><h3 id=\"m的选择\"><a href=\"#m的选择\" class=\"headerlink\" title=\"m的选择\"></a>m的选择</h3><ul>\n<li>一般来说，模数应该尽可能大，这样可以产生较长的周期，常见的模数挑选一般为2**w（常用的为2^32或者2^64，产生结果直接截断最右边的32bit或者64bit）</li>\n<li>当模数为2**w的时候，最后产生未模之前的数字与最后的结果相比，是该数字的比特位向右边减w位的结果，这种形式在低位上的随机性并不是很好。可以在产生随机数后截取高位比特，将随机性不好的低位比特直接舍弃。<h3 id=\"a的选择（0≤a-lt-m）\"><a href=\"#a的选择（0≤a-lt-m）\" class=\"headerlink\" title=\"a的选择（0≤a&lt;m）\"></a>a的选择（0≤a&lt;m）</h3></li>\n<li>a的取值会很大程度上影响整个生成器的安全性，应该使周期尽量长（最长为m），但是周期长的序列随机性比较差。</li>\n<li>当a=1时，生成器的公式为s[i+1]=s[i]+b mod m</li>\n<li>当a=0时，生成器的公式为s[i+1]=b mod m，安全性为0.</li>\n<li>当a取值其他数字时，影响随机数生成器生成数字的周期。<h3 id=\"选取参数的总结\"><a href=\"#选取参数的总结\" class=\"headerlink\" title=\"选取参数的总结\"></a>选取参数的总结</h3></li>\n<li>模数m尽可能大，一般大于2**30</li>\n<li>当m选取为2的幂次方时，应该满足a mod 8=5</li>\n<li>当m和a选取都合理时，b需要在与m互质的条件下选取。<h3 id=\"最大周期符合的条件：\"><a href=\"#最大周期符合的条件：\" class=\"headerlink\" title=\"最大周期符合的条件：\"></a>最大周期符合的条件：</h3></li>\n<li>m和b互质</li>\n<li>m的所有质因子的积能整除a-1</li>\n<li>如果m是4的倍数，a-1也是</li>\n<li>a,b,seed都比m小</li>\n<li>a,b是正整数</li>\n</ul>\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><p><img src=\"/images/pasted-20.png\" alt=\"\"></p>\n<ul>\n<li>根据线性同余生成器lcg可得：lcg=(a*x+c)%m</li>\n<li>根据题目，当输入数字时，可以得到多个连续随机数，根据伪随机数生成的机制，可以了解到，随机数的生成只要知道随机数种子就可以破解</li>\n<li>类推到线性同余方程组，也就是说当知道a,c,m时即可知道随机数的整个序列</li>\n<li>例如：假设我们知道lcg0,那么lcg1=(a<em>lcg0+c)%m,同理lcg2=(a</em>lcg1+c)%m</li>\n<li>此时我们随意提交多次，可以从中得到连续的随机数，类比于lcg0,lcg1,lcg2的关系</li>\n<li>lcg0=32081     lcg1=23815     lcg2=1237   lcg3=2387</li>\n<li>爆破模数module，每次moudle值改变时，都进行下面的操作：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lcg1&#x3D;(a*lcg0+c)%m       lcg2&#x3D;(a*lcg1+c)%m</span><br><span class=\"line\"></span><br><span class=\"line\">两式相减   左边为:lcg2-lcg1   右边为:(a*lcg1+c)-(a*lcg0+c)</span><br><span class=\"line\"></span><br><span class=\"line\">化简为: [lcg2-lcg1&#x3D;a*(lcg1-lcg0) ] %m</span><br><span class=\"line\"></span><br><span class=\"line\">根据求余运算规则可知  </span><br><span class=\"line\">[a&#x3D;(lcg2-lcg1)*gmpy2.invert(lcg1-lcg0,m)]%m</span><br><span class=\"line\"></span><br><span class=\"line\">此时代入lcg0,lcg1,lcg2之后可求得a</span><br><span class=\"line\"></span><br><span class=\"line\">代入lcg1&#x3D;(a*lcg0+c)%m,把c当作未知数放到等式左边后，式子为：</span><br><span class=\"line\">c&#x3D;[lcg1*gmpy2.invert(a*lcg0,m)]%m</span><br><span class=\"line\"></span><br><span class=\"line\">类推lcg3_guess&#x3D;(a*lcg2+c)%m</span><br><span class=\"line\">将求得地lcg3_guess与lcg3比较，如果相等，证明求得的a,c,m为正确值</span><br><span class=\"line\">否则，m&#x3D;m+1，继续验证</span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\">1、这个式子成立条件是两边同时对m求余</span><br><span class=\"line\">2、gmpy2.invert(x1,x2)是求与x1%x2同余的最小数，二者在求余操作后等价，因为余数相等，该式表示余数，类似7%5&#x3D;2%5</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>求得正确的a,c,m之后，线性同余方程为 lcg[i]=(a*lcg[i-1]+c)%m</li>\n<li>多次提交成功之后，获得flag</li>\n</ul>\n"},{"title":"RsaLsbOrcalePadding","author":"人生若只如初见","date":"2020-09-06T01:23:00.000Z","_content":"[参考1](https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack)\n[参考2](https://zhuanlan.zhihu.com/p/140726869)\n[参考3](https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/)\n\n## 原理公式\n\n```\n攻击者得到密文C=Pe(mod n) ，将其乘以2e(mod N), 并作为密文发送出去，若返回f(2P)\n如果f(2P) 返回的最后一位是0，那么2P<N，即P<N/2\n如果f(2P) 返回的最后一位是1，那么2P>N，即 P>N/2\n接着我们来看看2P 和 4P\n如果返回的是（偶，偶），那么有 P<N/4\n如果返回的是（偶，奇），那么有N/4<P<N/2\n如果返回的是（偶，奇），那么有N/2<P<3N/4\n如果返回的是（奇，奇），那么有3N/4<P<N\n\n```\n* 数论中有个定理，c = 偶数 a mod 奇数 b，若 c 为奇数，则 a>b，若 c 为偶数，则 a<b\n\n## 推导过程\n\n\n![](/images/pasted-33.png)\n\n\n\n## 脚本：\n\n```\nL = 0\nH = n\nt = pow(2, e, n)\nfor _ in range(n.bit_length()):\n    c = (t * c) % n\n    if oracle(c) == 0:\n        H = (L + H) // 2\n    else:\n        L = (L + H) // 2\nm = L # plain text\n```\n\n\n* 可忽略\n## service.py\n\n```\n#!/usr/bin/python -u\nfrom Crypto.Util.number import *\nfrom Crypto.PublicKey import RSA\nimport random\n#from SECRET import flag\nflag = \"CTF{this_is_my_test_flag}\"\nm = bytes_to_long(flag)\nkey = RSA.generate(1024)\nc = pow(m, key.e, key.n)\nprint(\"Welcome to BACKDOORCTF17\\n\")\nprint(\"PublicKey:\\n\")\nprint(\"N = \" + str(key.n) + \"\\n\")\nprint(\"e = \" + str(key.e) + \"\\n\")\nprint(\"c = \" + str(c) + \"\\n\")\nwhile True:\n    try:\n        temp_c = int(raw_input(\"temp_c = \"))\n        temp_m = pow(temp_c, key.d, key.n)\n    except:\n        break\n    l = str(((temp_m&5) * random.randint(1,10000))%(2*(random.randint(1,10000))))\n    print \"l = \"+l\n```\n\n## solve.py\n\n```\n# -*- coding: utf-8 -*-\n#/usr/bin/env python\nfrom pwn import *\nimport libnum\nimport Crypto\nimport re\nfrom binascii import hexlify,unhexlify\nif len(sys.argv)>1:\n    p=remote(\"127.0.0.1\",2334)\nelse:\n    p=remote('127.0.0.1',2333)\n#context.log_level = 'debug'\ndef oracle(c):\n    l = []\n    for i in range(20):\n        p.sendline(str(c))\n        s = p.recvuntil(\"temp_c\")\n        l.append(int(re.findall(\"l\\s*=\\s*([0-9]*)\",s)[0]))\n    flag0 = 0\n    flag2 = 0\n    for i in range(20):\n        if l[i]%2 != 0:\n            flag0 = 1\n        if l[i] > 10000:\n            flag2 = 1\n    return [flag2,flag0]\ndef main():\n    ss = p.recvuntil(\"temp_c\")\n    N = int(re.findall(\"N\\s*=\\s*(\\d+)\",ss)[0])\n    e = int(re.findall(\"e\\s*=\\s*(\\d+)\",ss)[0])\n    c = int(re.findall(\"c\\s*=\\s*(\\d+)\",ss)[0])\n    size = libnum.len_in_bits(N)\n    print \"N=\",N\n    print \"e=\",e\n    print \"c=\",c\n    c = (pow(2,e,N)*c)%N\n    LB = 0\n    UB = N\n    i = 1\n    while LB!=UB:\n        flag = oracle(c)\n        print i,flag\n        if flag[1]%2==0:\n            UB = (LB+UB)/2\n        else:\n            LB = (LB+UB)/2\n        c = (pow(2,e,N)*c)%N\n        i += 1\n    print LB\n    print UB\n    for i in range(-128,128,0):\n        LB += i\n        if pow(LB,e,N)==C:\n            print unhexlify(hex(LB)[2:-1])\n            exit(0)\nif __name__ == '__main__':\n    main()\n    p.interactive()\n```","source":"_posts/RsaLSBOrcalePadding.md","raw":"title: RsaLsbOrcalePadding\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-09-06 09:23:00\n---\n[参考1](https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack)\n[参考2](https://zhuanlan.zhihu.com/p/140726869)\n[参考3](https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/)\n\n## 原理公式\n\n```\n攻击者得到密文C=Pe(mod n) ，将其乘以2e(mod N), 并作为密文发送出去，若返回f(2P)\n如果f(2P) 返回的最后一位是0，那么2P<N，即P<N/2\n如果f(2P) 返回的最后一位是1，那么2P>N，即 P>N/2\n接着我们来看看2P 和 4P\n如果返回的是（偶，偶），那么有 P<N/4\n如果返回的是（偶，奇），那么有N/4<P<N/2\n如果返回的是（偶，奇），那么有N/2<P<3N/4\n如果返回的是（奇，奇），那么有3N/4<P<N\n\n```\n* 数论中有个定理，c = 偶数 a mod 奇数 b，若 c 为奇数，则 a>b，若 c 为偶数，则 a<b\n\n## 推导过程\n\n\n![](/images/pasted-33.png)\n\n\n\n## 脚本：\n\n```\nL = 0\nH = n\nt = pow(2, e, n)\nfor _ in range(n.bit_length()):\n    c = (t * c) % n\n    if oracle(c) == 0:\n        H = (L + H) // 2\n    else:\n        L = (L + H) // 2\nm = L # plain text\n```\n\n\n* 可忽略\n## service.py\n\n```\n#!/usr/bin/python -u\nfrom Crypto.Util.number import *\nfrom Crypto.PublicKey import RSA\nimport random\n#from SECRET import flag\nflag = \"CTF{this_is_my_test_flag}\"\nm = bytes_to_long(flag)\nkey = RSA.generate(1024)\nc = pow(m, key.e, key.n)\nprint(\"Welcome to BACKDOORCTF17\\n\")\nprint(\"PublicKey:\\n\")\nprint(\"N = \" + str(key.n) + \"\\n\")\nprint(\"e = \" + str(key.e) + \"\\n\")\nprint(\"c = \" + str(c) + \"\\n\")\nwhile True:\n    try:\n        temp_c = int(raw_input(\"temp_c = \"))\n        temp_m = pow(temp_c, key.d, key.n)\n    except:\n        break\n    l = str(((temp_m&5) * random.randint(1,10000))%(2*(random.randint(1,10000))))\n    print \"l = \"+l\n```\n\n## solve.py\n\n```\n# -*- coding: utf-8 -*-\n#/usr/bin/env python\nfrom pwn import *\nimport libnum\nimport Crypto\nimport re\nfrom binascii import hexlify,unhexlify\nif len(sys.argv)>1:\n    p=remote(\"127.0.0.1\",2334)\nelse:\n    p=remote('127.0.0.1',2333)\n#context.log_level = 'debug'\ndef oracle(c):\n    l = []\n    for i in range(20):\n        p.sendline(str(c))\n        s = p.recvuntil(\"temp_c\")\n        l.append(int(re.findall(\"l\\s*=\\s*([0-9]*)\",s)[0]))\n    flag0 = 0\n    flag2 = 0\n    for i in range(20):\n        if l[i]%2 != 0:\n            flag0 = 1\n        if l[i] > 10000:\n            flag2 = 1\n    return [flag2,flag0]\ndef main():\n    ss = p.recvuntil(\"temp_c\")\n    N = int(re.findall(\"N\\s*=\\s*(\\d+)\",ss)[0])\n    e = int(re.findall(\"e\\s*=\\s*(\\d+)\",ss)[0])\n    c = int(re.findall(\"c\\s*=\\s*(\\d+)\",ss)[0])\n    size = libnum.len_in_bits(N)\n    print \"N=\",N\n    print \"e=\",e\n    print \"c=\",c\n    c = (pow(2,e,N)*c)%N\n    LB = 0\n    UB = N\n    i = 1\n    while LB!=UB:\n        flag = oracle(c)\n        print i,flag\n        if flag[1]%2==0:\n            UB = (LB+UB)/2\n        else:\n            LB = (LB+UB)/2\n        c = (pow(2,e,N)*c)%N\n        i += 1\n    print LB\n    print UB\n    for i in range(-128,128,0):\n        LB += i\n        if pow(LB,e,N)==C:\n            print unhexlify(hex(LB)[2:-1])\n            exit(0)\nif __name__ == '__main__':\n    main()\n    p.interactive()\n```","slug":"RsaLSBOrcalePadding","published":1,"updated":"2020-09-25T11:27:55.508Z","_id":"ckfi5r18h001wvcu95mp2b3lj","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack\" target=\"_blank\" rel=\"noopener\">参考1</a><br><a href=\"https://zhuanlan.zhihu.com/p/140726869\" target=\"_blank\" rel=\"noopener\">参考2</a><br><a href=\"https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/\" target=\"_blank\" rel=\"noopener\">参考3</a></p>\n<h2 id=\"原理公式\"><a href=\"#原理公式\" class=\"headerlink\" title=\"原理公式\"></a>原理公式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">攻击者得到密文C&#x3D;Pe(mod n) ，将其乘以2e(mod N), 并作为密文发送出去，若返回f(2P)</span><br><span class=\"line\">如果f(2P) 返回的最后一位是0，那么2P&lt;N，即P&lt;N&#x2F;2</span><br><span class=\"line\">如果f(2P) 返回的最后一位是1，那么2P&gt;N，即 P&gt;N&#x2F;2</span><br><span class=\"line\">接着我们来看看2P 和 4P</span><br><span class=\"line\">如果返回的是（偶，偶），那么有 P&lt;N&#x2F;4</span><br><span class=\"line\">如果返回的是（偶，奇），那么有N&#x2F;4&lt;P&lt;N&#x2F;2</span><br><span class=\"line\">如果返回的是（偶，奇），那么有N&#x2F;2&lt;P&lt;3N&#x2F;4</span><br><span class=\"line\">如果返回的是（奇，奇），那么有3N&#x2F;4&lt;P&lt;N</span><br></pre></td></tr></table></figure>\n<ul>\n<li>数论中有个定理，c = 偶数 a mod 奇数 b，若 c 为奇数，则 a&gt;b，若 c 为偶数，则 a&lt;b</li>\n</ul>\n<h2 id=\"推导过程\"><a href=\"#推导过程\" class=\"headerlink\" title=\"推导过程\"></a>推导过程</h2><p><img src=\"/images/pasted-33.png\" alt=\"\"></p>\n<h2 id=\"脚本：\"><a href=\"#脚本：\" class=\"headerlink\" title=\"脚本：\"></a>脚本：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L &#x3D; 0</span><br><span class=\"line\">H &#x3D; n</span><br><span class=\"line\">t &#x3D; pow(2, e, n)</span><br><span class=\"line\">for _ in range(n.bit_length()):</span><br><span class=\"line\">    c &#x3D; (t * c) % n</span><br><span class=\"line\">    if oracle(c) &#x3D;&#x3D; 0:</span><br><span class=\"line\">        H &#x3D; (L + H) &#x2F;&#x2F; 2</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        L &#x3D; (L + H) &#x2F;&#x2F; 2</span><br><span class=\"line\">m &#x3D; L # plain text</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>可忽略<h2 id=\"service-py\"><a href=\"#service-py\" class=\"headerlink\" title=\"service.py\"></a>service.py</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;python -u</span><br><span class=\"line\">from Crypto.Util.number import *</span><br><span class=\"line\">from Crypto.PublicKey import RSA</span><br><span class=\"line\">import random</span><br><span class=\"line\">#from SECRET import flag</span><br><span class=\"line\">flag &#x3D; &quot;CTF&#123;this_is_my_test_flag&#125;&quot;</span><br><span class=\"line\">m &#x3D; bytes_to_long(flag)</span><br><span class=\"line\">key &#x3D; RSA.generate(1024)</span><br><span class=\"line\">c &#x3D; pow(m, key.e, key.n)</span><br><span class=\"line\">print(&quot;Welcome to BACKDOORCTF17\\n&quot;)</span><br><span class=\"line\">print(&quot;PublicKey:\\n&quot;)</span><br><span class=\"line\">print(&quot;N &#x3D; &quot; + str(key.n) + &quot;\\n&quot;)</span><br><span class=\"line\">print(&quot;e &#x3D; &quot; + str(key.e) + &quot;\\n&quot;)</span><br><span class=\"line\">print(&quot;c &#x3D; &quot; + str(c) + &quot;\\n&quot;)</span><br><span class=\"line\">while True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        temp_c &#x3D; int(raw_input(&quot;temp_c &#x3D; &quot;))</span><br><span class=\"line\">        temp_m &#x3D; pow(temp_c, key.d, key.n)</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        break</span><br><span class=\"line\">    l &#x3D; str(((temp_m&amp;5) * random.randint(1,10000))%(2*(random.randint(1,10000))))</span><br><span class=\"line\">    print &quot;l &#x3D; &quot;+l</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"solve-py\"><a href=\"#solve-py\" class=\"headerlink\" title=\"solve.py\"></a>solve.py</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">#&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\">import libnum</span><br><span class=\"line\">import Crypto</span><br><span class=\"line\">import re</span><br><span class=\"line\">from binascii import hexlify,unhexlify</span><br><span class=\"line\">if len(sys.argv)&gt;1:</span><br><span class=\"line\">    p&#x3D;remote(&quot;127.0.0.1&quot;,2334)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    p&#x3D;remote(&#39;127.0.0.1&#39;,2333)</span><br><span class=\"line\">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class=\"line\">def oracle(c):</span><br><span class=\"line\">    l &#x3D; []</span><br><span class=\"line\">    for i in range(20):</span><br><span class=\"line\">        p.sendline(str(c))</span><br><span class=\"line\">        s &#x3D; p.recvuntil(&quot;temp_c&quot;)</span><br><span class=\"line\">        l.append(int(re.findall(&quot;l\\s*&#x3D;\\s*([0-9]*)&quot;,s)[0]))</span><br><span class=\"line\">    flag0 &#x3D; 0</span><br><span class=\"line\">    flag2 &#x3D; 0</span><br><span class=\"line\">    for i in range(20):</span><br><span class=\"line\">        if l[i]%2 !&#x3D; 0:</span><br><span class=\"line\">            flag0 &#x3D; 1</span><br><span class=\"line\">        if l[i] &gt; 10000:</span><br><span class=\"line\">            flag2 &#x3D; 1</span><br><span class=\"line\">    return [flag2,flag0]</span><br><span class=\"line\">def main():</span><br><span class=\"line\">    ss &#x3D; p.recvuntil(&quot;temp_c&quot;)</span><br><span class=\"line\">    N &#x3D; int(re.findall(&quot;N\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    e &#x3D; int(re.findall(&quot;e\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    c &#x3D; int(re.findall(&quot;c\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    size &#x3D; libnum.len_in_bits(N)</span><br><span class=\"line\">    print &quot;N&#x3D;&quot;,N</span><br><span class=\"line\">    print &quot;e&#x3D;&quot;,e</span><br><span class=\"line\">    print &quot;c&#x3D;&quot;,c</span><br><span class=\"line\">    c &#x3D; (pow(2,e,N)*c)%N</span><br><span class=\"line\">    LB &#x3D; 0</span><br><span class=\"line\">    UB &#x3D; N</span><br><span class=\"line\">    i &#x3D; 1</span><br><span class=\"line\">    while LB!&#x3D;UB:</span><br><span class=\"line\">        flag &#x3D; oracle(c)</span><br><span class=\"line\">        print i,flag</span><br><span class=\"line\">        if flag[1]%2&#x3D;&#x3D;0:</span><br><span class=\"line\">            UB &#x3D; (LB+UB)&#x2F;2</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            LB &#x3D; (LB+UB)&#x2F;2</span><br><span class=\"line\">        c &#x3D; (pow(2,e,N)*c)%N</span><br><span class=\"line\">        i +&#x3D; 1</span><br><span class=\"line\">    print LB</span><br><span class=\"line\">    print UB</span><br><span class=\"line\">    for i in range(-128,128,0):</span><br><span class=\"line\">        LB +&#x3D; i</span><br><span class=\"line\">        if pow(LB,e,N)&#x3D;&#x3D;C:</span><br><span class=\"line\">            print unhexlify(hex(LB)[2:-1])</span><br><span class=\"line\">            exit(0)</span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">    main()</span><br><span class=\"line\">    p.interactive()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack\" target=\"_blank\" rel=\"noopener\">参考1</a><br><a href=\"https://zhuanlan.zhihu.com/p/140726869\" target=\"_blank\" rel=\"noopener\">参考2</a><br><a href=\"https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/\" target=\"_blank\" rel=\"noopener\">参考3</a></p>\n<h2 id=\"原理公式\"><a href=\"#原理公式\" class=\"headerlink\" title=\"原理公式\"></a>原理公式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">攻击者得到密文C&#x3D;Pe(mod n) ，将其乘以2e(mod N), 并作为密文发送出去，若返回f(2P)</span><br><span class=\"line\">如果f(2P) 返回的最后一位是0，那么2P&lt;N，即P&lt;N&#x2F;2</span><br><span class=\"line\">如果f(2P) 返回的最后一位是1，那么2P&gt;N，即 P&gt;N&#x2F;2</span><br><span class=\"line\">接着我们来看看2P 和 4P</span><br><span class=\"line\">如果返回的是（偶，偶），那么有 P&lt;N&#x2F;4</span><br><span class=\"line\">如果返回的是（偶，奇），那么有N&#x2F;4&lt;P&lt;N&#x2F;2</span><br><span class=\"line\">如果返回的是（偶，奇），那么有N&#x2F;2&lt;P&lt;3N&#x2F;4</span><br><span class=\"line\">如果返回的是（奇，奇），那么有3N&#x2F;4&lt;P&lt;N</span><br></pre></td></tr></table></figure>\n<ul>\n<li>数论中有个定理，c = 偶数 a mod 奇数 b，若 c 为奇数，则 a&gt;b，若 c 为偶数，则 a&lt;b</li>\n</ul>\n<h2 id=\"推导过程\"><a href=\"#推导过程\" class=\"headerlink\" title=\"推导过程\"></a>推导过程</h2><p><img src=\"/images/pasted-33.png\" alt=\"\"></p>\n<h2 id=\"脚本：\"><a href=\"#脚本：\" class=\"headerlink\" title=\"脚本：\"></a>脚本：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L &#x3D; 0</span><br><span class=\"line\">H &#x3D; n</span><br><span class=\"line\">t &#x3D; pow(2, e, n)</span><br><span class=\"line\">for _ in range(n.bit_length()):</span><br><span class=\"line\">    c &#x3D; (t * c) % n</span><br><span class=\"line\">    if oracle(c) &#x3D;&#x3D; 0:</span><br><span class=\"line\">        H &#x3D; (L + H) &#x2F;&#x2F; 2</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        L &#x3D; (L + H) &#x2F;&#x2F; 2</span><br><span class=\"line\">m &#x3D; L # plain text</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>可忽略<h2 id=\"service-py\"><a href=\"#service-py\" class=\"headerlink\" title=\"service.py\"></a>service.py</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;python -u</span><br><span class=\"line\">from Crypto.Util.number import *</span><br><span class=\"line\">from Crypto.PublicKey import RSA</span><br><span class=\"line\">import random</span><br><span class=\"line\">#from SECRET import flag</span><br><span class=\"line\">flag &#x3D; &quot;CTF&#123;this_is_my_test_flag&#125;&quot;</span><br><span class=\"line\">m &#x3D; bytes_to_long(flag)</span><br><span class=\"line\">key &#x3D; RSA.generate(1024)</span><br><span class=\"line\">c &#x3D; pow(m, key.e, key.n)</span><br><span class=\"line\">print(&quot;Welcome to BACKDOORCTF17\\n&quot;)</span><br><span class=\"line\">print(&quot;PublicKey:\\n&quot;)</span><br><span class=\"line\">print(&quot;N &#x3D; &quot; + str(key.n) + &quot;\\n&quot;)</span><br><span class=\"line\">print(&quot;e &#x3D; &quot; + str(key.e) + &quot;\\n&quot;)</span><br><span class=\"line\">print(&quot;c &#x3D; &quot; + str(c) + &quot;\\n&quot;)</span><br><span class=\"line\">while True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        temp_c &#x3D; int(raw_input(&quot;temp_c &#x3D; &quot;))</span><br><span class=\"line\">        temp_m &#x3D; pow(temp_c, key.d, key.n)</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        break</span><br><span class=\"line\">    l &#x3D; str(((temp_m&amp;5) * random.randint(1,10000))%(2*(random.randint(1,10000))))</span><br><span class=\"line\">    print &quot;l &#x3D; &quot;+l</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"solve-py\"><a href=\"#solve-py\" class=\"headerlink\" title=\"solve.py\"></a>solve.py</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">#&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\">import libnum</span><br><span class=\"line\">import Crypto</span><br><span class=\"line\">import re</span><br><span class=\"line\">from binascii import hexlify,unhexlify</span><br><span class=\"line\">if len(sys.argv)&gt;1:</span><br><span class=\"line\">    p&#x3D;remote(&quot;127.0.0.1&quot;,2334)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    p&#x3D;remote(&#39;127.0.0.1&#39;,2333)</span><br><span class=\"line\">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class=\"line\">def oracle(c):</span><br><span class=\"line\">    l &#x3D; []</span><br><span class=\"line\">    for i in range(20):</span><br><span class=\"line\">        p.sendline(str(c))</span><br><span class=\"line\">        s &#x3D; p.recvuntil(&quot;temp_c&quot;)</span><br><span class=\"line\">        l.append(int(re.findall(&quot;l\\s*&#x3D;\\s*([0-9]*)&quot;,s)[0]))</span><br><span class=\"line\">    flag0 &#x3D; 0</span><br><span class=\"line\">    flag2 &#x3D; 0</span><br><span class=\"line\">    for i in range(20):</span><br><span class=\"line\">        if l[i]%2 !&#x3D; 0:</span><br><span class=\"line\">            flag0 &#x3D; 1</span><br><span class=\"line\">        if l[i] &gt; 10000:</span><br><span class=\"line\">            flag2 &#x3D; 1</span><br><span class=\"line\">    return [flag2,flag0]</span><br><span class=\"line\">def main():</span><br><span class=\"line\">    ss &#x3D; p.recvuntil(&quot;temp_c&quot;)</span><br><span class=\"line\">    N &#x3D; int(re.findall(&quot;N\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    e &#x3D; int(re.findall(&quot;e\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    c &#x3D; int(re.findall(&quot;c\\s*&#x3D;\\s*(\\d+)&quot;,ss)[0])</span><br><span class=\"line\">    size &#x3D; libnum.len_in_bits(N)</span><br><span class=\"line\">    print &quot;N&#x3D;&quot;,N</span><br><span class=\"line\">    print &quot;e&#x3D;&quot;,e</span><br><span class=\"line\">    print &quot;c&#x3D;&quot;,c</span><br><span class=\"line\">    c &#x3D; (pow(2,e,N)*c)%N</span><br><span class=\"line\">    LB &#x3D; 0</span><br><span class=\"line\">    UB &#x3D; N</span><br><span class=\"line\">    i &#x3D; 1</span><br><span class=\"line\">    while LB!&#x3D;UB:</span><br><span class=\"line\">        flag &#x3D; oracle(c)</span><br><span class=\"line\">        print i,flag</span><br><span class=\"line\">        if flag[1]%2&#x3D;&#x3D;0:</span><br><span class=\"line\">            UB &#x3D; (LB+UB)&#x2F;2</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            LB &#x3D; (LB+UB)&#x2F;2</span><br><span class=\"line\">        c &#x3D; (pow(2,e,N)*c)%N</span><br><span class=\"line\">        i +&#x3D; 1</span><br><span class=\"line\">    print LB</span><br><span class=\"line\">    print UB</span><br><span class=\"line\">    for i in range(-128,128,0):</span><br><span class=\"line\">        LB +&#x3D; i</span><br><span class=\"line\">        if pow(LB,e,N)&#x3D;&#x3D;C:</span><br><span class=\"line\">            print unhexlify(hex(LB)[2:-1])</span><br><span class=\"line\">            exit(0)</span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">    main()</span><br><span class=\"line\">    p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"Unicode编码衍生出的编码方案","author":"人生若只如初见","date":"2020-05-27T10:11:00.000Z","_content":"* 字符集和字符编码不是一个概念，字符集定义了文字和二进制的对应关系，为字符分配了唯一的编号，而字符编码规定了如何将文字的编号存储到内存中。有的字符集在制定时就考虑到了编码的问题，是和编码结合在一起的；有的字符集只管制定字符的编号，至于怎么编码，是其他人的事情。\n\n## 方案1：为每个字符分配固定长度的内存\n\n* 一种方案是为每个字符分配固定长度的内存，并且这块内存要足够大，可以容纳下所有的字符编号。这种方案最简单，直接将字符编号放入内存中即可，不需要任何转换，并且以后在字符串中定位字符、修改字符都非常容易。\n\n```\n字符串就是一串连续的字符序列，它们在内存中按次序挨着存放。在C语言中，字符串由双引号\" \"包围起来。\n```\n* 目前的 Unicode 已经收录了上百万的字符，至少需要三个字节才能容纳下所有的字符编号。假设字符串”A3中￥”的 Unicode 编码值（十六进制形式）分别是 2A、31、DA49、BB672C，那么它们在内存中的存储形式为：\n\n![](/images/pasted-13.png)\n* 在几乎所有的字符集中，常用字符的编号往往比较小，罕见字符的编号往往比较大，包括 Unicode 在内。\n* A和3是 ASCII 编码中的字符，Unicode 为了兼容 ASCII，在设计时刻意保留了原来 ASCII 中字符的编号，所以英文字母和阿拉伯数字在 Unicode 中的编号都非常小，用一个字节足以容纳。中是一个汉字，编号比较大，一般要用两个字节才能容纳。￥可以看做是一个极其少见，或者只有极少数地区才会使用到的字符，这样的字符编号往往比较大，有时候需要三个字节才能容纳。\n\n```\n￥是人民币符号，是汉字文化的一部分，它和其它汉字一样，实际上是用两个字节存储的，不过这里我们为了演示，故意犯错地说它需要三个字节。\n```\n* 上图中带灰色背景的字节是没有用到的字节，它们就是被浪费掉的一部分内存空间，这就是用固定长度的内存来存储字符编号的缺点：常用字符的编号都比较小，这种方案会浪费很多内存空间，对于以英文为主的国家，比如美国、加拿大、英国等，内存利用率甚至会低于 50%。\n## 方案2：为每个字符分配尽量少的内存\n\n* 既然上面的方案有缺点，那我们就来改进一下。改进的思路也很明确，就是把空闲的内存压缩掉，为每个字符分配尽量少的字节，例如，A和3分配一个字节足以，中分配两个字节足以，如下图所示：\n\n* 这样虽然没有了空闲字节，不浪费任何内存空间了，但是又出现新的问题了：如果我不告诉你，你怎么知道2A表示一个字符，而不是2A31或者2A31DA才表示一个字符呢？后面的字符也有类似的问题。\n\n* 对于第一种方案，每个字符占用的字节数是固定的，很容易区分各个字符；而这种方案，不同的字符占用的字节数不同，字符之间也没有特殊的标记，计算机是无法定位字符的。\n\n* 这种方案还需要改进，必须让不同的字符编码有不同的特征，并且字符处理程序也需要调整，要根据这些特征去识别不同的字符。\n\n## 要想让不同的字符编码有不同的特征，可以从两个方面下手：\n\n### 1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\n\n* 例如，对于编号较小的、用一个字节足以容纳的字符，我们就可以规定这个字符编号的最高位（Bit）必须是 0；对于编号较大的、要用两个字节存储的字符，我们就可以规定这个字符编号的高字节的最高位必须是 1，低字节的最高位必须是 0；对于编号更大的、需要三个字节存储的字符，我们就可以规定这个字符编号的所有字节的最高位都必须是 1。\n\n* 程序在定位字符时，从前往后依次扫描，如果发现当前字节的最高位是 0，那么就把这一个字节作为一个字符编号。如果发现当前字节的最高位是 1，那么就继续往后扫描，如果后续字节的最高位是 0，那么就把这两个字节作为一个字符编号；如果后续字节的最高位是 1，那么就把挨着的三个字节作为一个字符编号。\n\n* 这种方案的缺点很明显，它会导致字符集不连续，中间留出大量空白区域，这些空白区域不能定义任何字符。\n\n### 2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\n\n* 那么，转换后的编号要具备什么样的特征呢？其实也可以像上面一样，根据字节的最高位是 0 还是 1 来判断字符到底占用了几个字节。\n\n* 相比第一种方案，这种方案有缺点也有优点：\n\n```\n缺点就是多了转换过程，字符在存储和读取时要经过转换，效率低；\n优点就是在制定字符集时不用考虑存储的问题，可以任意排布字符。\n```","source":"_posts/Unicode编码衍生出的编码方案.md","raw":"title: Unicode编码衍生出的编码方案\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 编码\ndate: 2020-05-27 18:11:00\n---\n* 字符集和字符编码不是一个概念，字符集定义了文字和二进制的对应关系，为字符分配了唯一的编号，而字符编码规定了如何将文字的编号存储到内存中。有的字符集在制定时就考虑到了编码的问题，是和编码结合在一起的；有的字符集只管制定字符的编号，至于怎么编码，是其他人的事情。\n\n## 方案1：为每个字符分配固定长度的内存\n\n* 一种方案是为每个字符分配固定长度的内存，并且这块内存要足够大，可以容纳下所有的字符编号。这种方案最简单，直接将字符编号放入内存中即可，不需要任何转换，并且以后在字符串中定位字符、修改字符都非常容易。\n\n```\n字符串就是一串连续的字符序列，它们在内存中按次序挨着存放。在C语言中，字符串由双引号\" \"包围起来。\n```\n* 目前的 Unicode 已经收录了上百万的字符，至少需要三个字节才能容纳下所有的字符编号。假设字符串”A3中￥”的 Unicode 编码值（十六进制形式）分别是 2A、31、DA49、BB672C，那么它们在内存中的存储形式为：\n\n![](/images/pasted-13.png)\n* 在几乎所有的字符集中，常用字符的编号往往比较小，罕见字符的编号往往比较大，包括 Unicode 在内。\n* A和3是 ASCII 编码中的字符，Unicode 为了兼容 ASCII，在设计时刻意保留了原来 ASCII 中字符的编号，所以英文字母和阿拉伯数字在 Unicode 中的编号都非常小，用一个字节足以容纳。中是一个汉字，编号比较大，一般要用两个字节才能容纳。￥可以看做是一个极其少见，或者只有极少数地区才会使用到的字符，这样的字符编号往往比较大，有时候需要三个字节才能容纳。\n\n```\n￥是人民币符号，是汉字文化的一部分，它和其它汉字一样，实际上是用两个字节存储的，不过这里我们为了演示，故意犯错地说它需要三个字节。\n```\n* 上图中带灰色背景的字节是没有用到的字节，它们就是被浪费掉的一部分内存空间，这就是用固定长度的内存来存储字符编号的缺点：常用字符的编号都比较小，这种方案会浪费很多内存空间，对于以英文为主的国家，比如美国、加拿大、英国等，内存利用率甚至会低于 50%。\n## 方案2：为每个字符分配尽量少的内存\n\n* 既然上面的方案有缺点，那我们就来改进一下。改进的思路也很明确，就是把空闲的内存压缩掉，为每个字符分配尽量少的字节，例如，A和3分配一个字节足以，中分配两个字节足以，如下图所示：\n\n* 这样虽然没有了空闲字节，不浪费任何内存空间了，但是又出现新的问题了：如果我不告诉你，你怎么知道2A表示一个字符，而不是2A31或者2A31DA才表示一个字符呢？后面的字符也有类似的问题。\n\n* 对于第一种方案，每个字符占用的字节数是固定的，很容易区分各个字符；而这种方案，不同的字符占用的字节数不同，字符之间也没有特殊的标记，计算机是无法定位字符的。\n\n* 这种方案还需要改进，必须让不同的字符编码有不同的特征，并且字符处理程序也需要调整，要根据这些特征去识别不同的字符。\n\n## 要想让不同的字符编码有不同的特征，可以从两个方面下手：\n\n### 1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\n\n* 例如，对于编号较小的、用一个字节足以容纳的字符，我们就可以规定这个字符编号的最高位（Bit）必须是 0；对于编号较大的、要用两个字节存储的字符，我们就可以规定这个字符编号的高字节的最高位必须是 1，低字节的最高位必须是 0；对于编号更大的、需要三个字节存储的字符，我们就可以规定这个字符编号的所有字节的最高位都必须是 1。\n\n* 程序在定位字符时，从前往后依次扫描，如果发现当前字节的最高位是 0，那么就把这一个字节作为一个字符编号。如果发现当前字节的最高位是 1，那么就继续往后扫描，如果后续字节的最高位是 0，那么就把这两个字节作为一个字符编号；如果后续字节的最高位是 1，那么就把挨着的三个字节作为一个字符编号。\n\n* 这种方案的缺点很明显，它会导致字符集不连续，中间留出大量空白区域，这些空白区域不能定义任何字符。\n\n### 2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\n\n* 那么，转换后的编号要具备什么样的特征呢？其实也可以像上面一样，根据字节的最高位是 0 还是 1 来判断字符到底占用了几个字节。\n\n* 相比第一种方案，这种方案有缺点也有优点：\n\n```\n缺点就是多了转换过程，字符在存储和读取时要经过转换，效率低；\n优点就是在制定字符集时不用考虑存储的问题，可以任意排布字符。\n```","slug":"Unicode编码衍生出的编码方案","published":1,"updated":"2020-05-27T10:15:18.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18i001yvcu9guxy5ej0","content":"<ul>\n<li>字符集和字符编码不是一个概念，字符集定义了文字和二进制的对应关系，为字符分配了唯一的编号，而字符编码规定了如何将文字的编号存储到内存中。有的字符集在制定时就考虑到了编码的问题，是和编码结合在一起的；有的字符集只管制定字符的编号，至于怎么编码，是其他人的事情。</li>\n</ul>\n<h2 id=\"方案1：为每个字符分配固定长度的内存\"><a href=\"#方案1：为每个字符分配固定长度的内存\" class=\"headerlink\" title=\"方案1：为每个字符分配固定长度的内存\"></a>方案1：为每个字符分配固定长度的内存</h2><ul>\n<li>一种方案是为每个字符分配固定长度的内存，并且这块内存要足够大，可以容纳下所有的字符编号。这种方案最简单，直接将字符编号放入内存中即可，不需要任何转换，并且以后在字符串中定位字符、修改字符都非常容易。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符串就是一串连续的字符序列，它们在内存中按次序挨着存放。在C语言中，字符串由双引号&quot; &quot;包围起来。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>目前的 Unicode 已经收录了上百万的字符，至少需要三个字节才能容纳下所有的字符编号。假设字符串”A3中￥”的 Unicode 编码值（十六进制形式）分别是 2A、31、DA49、BB672C，那么它们在内存中的存储形式为：</li>\n</ul>\n<p><img src=\"/images/pasted-13.png\" alt=\"\"></p>\n<ul>\n<li>在几乎所有的字符集中，常用字符的编号往往比较小，罕见字符的编号往往比较大，包括 Unicode 在内。</li>\n<li>A和3是 ASCII 编码中的字符，Unicode 为了兼容 ASCII，在设计时刻意保留了原来 ASCII 中字符的编号，所以英文字母和阿拉伯数字在 Unicode 中的编号都非常小，用一个字节足以容纳。中是一个汉字，编号比较大，一般要用两个字节才能容纳。￥可以看做是一个极其少见，或者只有极少数地区才会使用到的字符，这样的字符编号往往比较大，有时候需要三个字节才能容纳。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">￥是人民币符号，是汉字文化的一部分，它和其它汉字一样，实际上是用两个字节存储的，不过这里我们为了演示，故意犯错地说它需要三个字节。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>上图中带灰色背景的字节是没有用到的字节，它们就是被浪费掉的一部分内存空间，这就是用固定长度的内存来存储字符编号的缺点：常用字符的编号都比较小，这种方案会浪费很多内存空间，对于以英文为主的国家，比如美国、加拿大、英国等，内存利用率甚至会低于 50%。</p>\n<h2 id=\"方案2：为每个字符分配尽量少的内存\"><a href=\"#方案2：为每个字符分配尽量少的内存\" class=\"headerlink\" title=\"方案2：为每个字符分配尽量少的内存\"></a>方案2：为每个字符分配尽量少的内存</h2></li>\n<li><p>既然上面的方案有缺点，那我们就来改进一下。改进的思路也很明确，就是把空闲的内存压缩掉，为每个字符分配尽量少的字节，例如，A和3分配一个字节足以，中分配两个字节足以，如下图所示：</p>\n</li>\n<li><p>这样虽然没有了空闲字节，不浪费任何内存空间了，但是又出现新的问题了：如果我不告诉你，你怎么知道2A表示一个字符，而不是2A31或者2A31DA才表示一个字符呢？后面的字符也有类似的问题。</p>\n</li>\n<li><p>对于第一种方案，每个字符占用的字节数是固定的，很容易区分各个字符；而这种方案，不同的字符占用的字节数不同，字符之间也没有特殊的标记，计算机是无法定位字符的。</p>\n</li>\n<li><p>这种方案还需要改进，必须让不同的字符编码有不同的特征，并且字符处理程序也需要调整，要根据这些特征去识别不同的字符。</p>\n</li>\n</ul>\n<h2 id=\"要想让不同的字符编码有不同的特征，可以从两个方面下手：\"><a href=\"#要想让不同的字符编码有不同的特征，可以从两个方面下手：\" class=\"headerlink\" title=\"要想让不同的字符编码有不同的特征，可以从两个方面下手：\"></a>要想让不同的字符编码有不同的特征，可以从两个方面下手：</h2><h3 id=\"1-一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\"><a href=\"#1-一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\" class=\"headerlink\" title=\"1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\"></a>1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。</h3><ul>\n<li><p>例如，对于编号较小的、用一个字节足以容纳的字符，我们就可以规定这个字符编号的最高位（Bit）必须是 0；对于编号较大的、要用两个字节存储的字符，我们就可以规定这个字符编号的高字节的最高位必须是 1，低字节的最高位必须是 0；对于编号更大的、需要三个字节存储的字符，我们就可以规定这个字符编号的所有字节的最高位都必须是 1。</p>\n</li>\n<li><p>程序在定位字符时，从前往后依次扫描，如果发现当前字节的最高位是 0，那么就把这一个字节作为一个字符编号。如果发现当前字节的最高位是 1，那么就继续往后扫描，如果后续字节的最高位是 0，那么就把这两个字节作为一个字符编号；如果后续字节的最高位是 1，那么就把挨着的三个字节作为一个字符编号。</p>\n</li>\n<li><p>这种方案的缺点很明显，它会导致字符集不连续，中间留出大量空白区域，这些空白区域不能定义任何字符。</p>\n</li>\n</ul>\n<h3 id=\"2-二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\"><a href=\"#2-二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\" class=\"headerlink\" title=\"2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\"></a>2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。</h3><ul>\n<li><p>那么，转换后的编号要具备什么样的特征呢？其实也可以像上面一样，根据字节的最高位是 0 还是 1 来判断字符到底占用了几个字节。</p>\n</li>\n<li><p>相比第一种方案，这种方案有缺点也有优点：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缺点就是多了转换过程，字符在存储和读取时要经过转换，效率低；</span><br><span class=\"line\">优点就是在制定字符集时不用考虑存储的问题，可以任意排布字符。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>字符集和字符编码不是一个概念，字符集定义了文字和二进制的对应关系，为字符分配了唯一的编号，而字符编码规定了如何将文字的编号存储到内存中。有的字符集在制定时就考虑到了编码的问题，是和编码结合在一起的；有的字符集只管制定字符的编号，至于怎么编码，是其他人的事情。</li>\n</ul>\n<h2 id=\"方案1：为每个字符分配固定长度的内存\"><a href=\"#方案1：为每个字符分配固定长度的内存\" class=\"headerlink\" title=\"方案1：为每个字符分配固定长度的内存\"></a>方案1：为每个字符分配固定长度的内存</h2><ul>\n<li>一种方案是为每个字符分配固定长度的内存，并且这块内存要足够大，可以容纳下所有的字符编号。这种方案最简单，直接将字符编号放入内存中即可，不需要任何转换，并且以后在字符串中定位字符、修改字符都非常容易。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符串就是一串连续的字符序列，它们在内存中按次序挨着存放。在C语言中，字符串由双引号&quot; &quot;包围起来。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>目前的 Unicode 已经收录了上百万的字符，至少需要三个字节才能容纳下所有的字符编号。假设字符串”A3中￥”的 Unicode 编码值（十六进制形式）分别是 2A、31、DA49、BB672C，那么它们在内存中的存储形式为：</li>\n</ul>\n<p><img src=\"/images/pasted-13.png\" alt=\"\"></p>\n<ul>\n<li>在几乎所有的字符集中，常用字符的编号往往比较小，罕见字符的编号往往比较大，包括 Unicode 在内。</li>\n<li>A和3是 ASCII 编码中的字符，Unicode 为了兼容 ASCII，在设计时刻意保留了原来 ASCII 中字符的编号，所以英文字母和阿拉伯数字在 Unicode 中的编号都非常小，用一个字节足以容纳。中是一个汉字，编号比较大，一般要用两个字节才能容纳。￥可以看做是一个极其少见，或者只有极少数地区才会使用到的字符，这样的字符编号往往比较大，有时候需要三个字节才能容纳。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">￥是人民币符号，是汉字文化的一部分，它和其它汉字一样，实际上是用两个字节存储的，不过这里我们为了演示，故意犯错地说它需要三个字节。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>上图中带灰色背景的字节是没有用到的字节，它们就是被浪费掉的一部分内存空间，这就是用固定长度的内存来存储字符编号的缺点：常用字符的编号都比较小，这种方案会浪费很多内存空间，对于以英文为主的国家，比如美国、加拿大、英国等，内存利用率甚至会低于 50%。</p>\n<h2 id=\"方案2：为每个字符分配尽量少的内存\"><a href=\"#方案2：为每个字符分配尽量少的内存\" class=\"headerlink\" title=\"方案2：为每个字符分配尽量少的内存\"></a>方案2：为每个字符分配尽量少的内存</h2></li>\n<li><p>既然上面的方案有缺点，那我们就来改进一下。改进的思路也很明确，就是把空闲的内存压缩掉，为每个字符分配尽量少的字节，例如，A和3分配一个字节足以，中分配两个字节足以，如下图所示：</p>\n</li>\n<li><p>这样虽然没有了空闲字节，不浪费任何内存空间了，但是又出现新的问题了：如果我不告诉你，你怎么知道2A表示一个字符，而不是2A31或者2A31DA才表示一个字符呢？后面的字符也有类似的问题。</p>\n</li>\n<li><p>对于第一种方案，每个字符占用的字节数是固定的，很容易区分各个字符；而这种方案，不同的字符占用的字节数不同，字符之间也没有特殊的标记，计算机是无法定位字符的。</p>\n</li>\n<li><p>这种方案还需要改进，必须让不同的字符编码有不同的特征，并且字符处理程序也需要调整，要根据这些特征去识别不同的字符。</p>\n</li>\n</ul>\n<h2 id=\"要想让不同的字符编码有不同的特征，可以从两个方面下手：\"><a href=\"#要想让不同的字符编码有不同的特征，可以从两个方面下手：\" class=\"headerlink\" title=\"要想让不同的字符编码有不同的特征，可以从两个方面下手：\"></a>要想让不同的字符编码有不同的特征，可以从两个方面下手：</h2><h3 id=\"1-一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\"><a href=\"#1-一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\" class=\"headerlink\" title=\"1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。\"></a>1) 一是从字符集本身下手，在设计字符集时，刻意让不同的字符编号有不同的特征。</h3><ul>\n<li><p>例如，对于编号较小的、用一个字节足以容纳的字符，我们就可以规定这个字符编号的最高位（Bit）必须是 0；对于编号较大的、要用两个字节存储的字符，我们就可以规定这个字符编号的高字节的最高位必须是 1，低字节的最高位必须是 0；对于编号更大的、需要三个字节存储的字符，我们就可以规定这个字符编号的所有字节的最高位都必须是 1。</p>\n</li>\n<li><p>程序在定位字符时，从前往后依次扫描，如果发现当前字节的最高位是 0，那么就把这一个字节作为一个字符编号。如果发现当前字节的最高位是 1，那么就继续往后扫描，如果后续字节的最高位是 0，那么就把这两个字节作为一个字符编号；如果后续字节的最高位是 1，那么就把挨着的三个字节作为一个字符编号。</p>\n</li>\n<li><p>这种方案的缺点很明显，它会导致字符集不连续，中间留出大量空白区域，这些空白区域不能定义任何字符。</p>\n</li>\n</ul>\n<h3 id=\"2-二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\"><a href=\"#2-二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\" class=\"headerlink\" title=\"2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。\"></a>2) 二是从字符编号下手，可以设计一种转换方案，字符编号在存储之前先转换为有特征的、容易定位的编号，读取时再按照相反的过程转换成字符本来的编号。</h3><ul>\n<li><p>那么，转换后的编号要具备什么样的特征呢？其实也可以像上面一样，根据字节的最高位是 0 还是 1 来判断字符到底占用了几个字节。</p>\n</li>\n<li><p>相比第一种方案，这种方案有缺点也有优点：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缺点就是多了转换过程，字符在存储和读取时要经过转换，效率低；</span><br><span class=\"line\">优点就是在制定字符集时不用考虑存储的问题，可以任意排布字符。</span><br></pre></td></tr></table></figure>"},{"title":"rsa基础学习","author":"人生若只如初见","date":"2020-05-27T03:46:00.000Z","_content":"# rsa基础\n* 在rsa中常用的参数为：N,E,d,p,q,C,m,dp,dq\n* 各参数所代表的含义：\n```\n<1> 参数N代表模数，在RSA中进行模运算\n<2> 参数E，d分别代表公钥指数和私钥指数\n<3> p,q分别为模数N分解后得到的值\n<4> C，m分别代表密文和明文\n<5> dp≡d mod (p−1)      dq≡d mod (q−1)这两个参数是在d的基础上的延申\n```\n* 各参数之间的关系：\n```\n<1> c≡m^e (mod N)    m≡c^d (mod N)\n<2> phi=(p-1)*(q-1)  e*d≡1 (mod phi)\n这里很重要的一点是e,d的取值范围,1<e<phi,1<d<phi,同时gcd(phi,e)=gcd(phi,d)=1\n```\n* 这也是RSA解密的基础运算，就是拿到公钥指数E和模数N，将模数N分解为两个质因数，求得私钥指数d，从而利用加密过程或解密过程将最终的内容拿到。\n### 这里需要讲一下公钥加密解密体系\n* 以对称加密为例，加密所使用的密钥与解密所使用的密钥是同一个，这样破译的难点集中于加密函数复杂度的设计以及密钥的长度，更多的是一种线性的处理方式；而公钥加密体系将这种问题避开，转而将加密解密的数据进行基于离散数学的运算，这里就提到了我们公私钥指数的关系\n```\ne*d≡1 (mod phi)\n```\n* 在数值小的时候运算是极为简单的，不过当数值增加到指数次方时，求离散数学的逆的难度也会相对应地指数次增长。\n* 但并不是说，公钥破解难度只在这里。好多教材和论文，将rsa这种基于大素数的公钥加密的破解，都解释为只要能够将大素数分解，这个加密体系就不复存在。其实，并没有直接证据能够证明，大素数分解与公钥破解的直接联系。\n* 就比如在RSA的解密过程中，当e=3，此时N为分解难度特别大的2048bit级别时，仍旧可以利用低指数攻击，在不分解N的情况下，将整个密文完整解密出来，所以众多的rsa的攻击方式来源不止是针对N的分解，更多的是从RSA的其他参数下手，使得解密过程更为简单便捷。\n\n* 接下来我们用几道例题来说明\n\n## 例题1\n```\n在RSA中，已知C=34 ，N=123，e=11,那么m为多少？\n```\n* 开始分析，这里知道N，我们使用YAFU分解，可以知道N的两个素因数是3和41\n求得phi=240=80,(11d)%phi=1,所以d=51\nm≡c^d (mod(N))=34^51(mod 123)=19\n\n* 这里用到的YAFU是一个在分解N常用的一个离线工具，它适用于素因数相差特别大或者特别小的情况，能够很快的分解出来，所以一些很小的数可能分解时间比大的数要长，原因在这里。\n\n* 除了这个以外，当面对特别大的素数时，我们可以使用在线网站 http://www.factordb.com/ ,这是一个在线网站，相当于是一个数据库，管理员将以往有分解出来的素数放在网站上，供查询。\n\n* 除此之外，利用算法进行脚本分解，不过成功率很低。\n## 例题2\n```\n题目所给一个加密enc文件和一个public.key文件，打开enc显示乱码\n```\n* public.key文件内容：\n![](https://note.youdao.com/yws/api/personal/file/E96950F29A6D49B883155E66A2FCAA4E?method=download&shareKey=fe3dd78b6638f345e7ba7ffd94c1fbc9)\n* 此时，用到了最常用的密钥工具——openssl，使用opsnssl可以方便的解读出公私钥文件的内容。\n* 使用命令，进行解析\n```\nopenssl rsa -pubin -text -modulus -in warmup -in public.key(这里的public.key可为public.pem,pubkey.pem等)\n```\n* 此命令下，解析内容如图所示\n\n* 之后按照例题1的步骤，进行解密\n* 不过这里的密文利用文件读取的指令，下面附上解题脚本\n![](https://note.youdao.com/yws/api/personal/file/3BB42A51A24E480D982E384770F8A445?method=download&shareKey=43c1fd4976fba9d4b1f14080ea0e32e9)\n* 最终的得到flag:flag{2o!9_CTF_ECUN}","source":"_posts/rsa基础学习-1.md","raw":"title: rsa基础学习\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-05-27 11:46:00\n---\n# rsa基础\n* 在rsa中常用的参数为：N,E,d,p,q,C,m,dp,dq\n* 各参数所代表的含义：\n```\n<1> 参数N代表模数，在RSA中进行模运算\n<2> 参数E，d分别代表公钥指数和私钥指数\n<3> p,q分别为模数N分解后得到的值\n<4> C，m分别代表密文和明文\n<5> dp≡d mod (p−1)      dq≡d mod (q−1)这两个参数是在d的基础上的延申\n```\n* 各参数之间的关系：\n```\n<1> c≡m^e (mod N)    m≡c^d (mod N)\n<2> phi=(p-1)*(q-1)  e*d≡1 (mod phi)\n这里很重要的一点是e,d的取值范围,1<e<phi,1<d<phi,同时gcd(phi,e)=gcd(phi,d)=1\n```\n* 这也是RSA解密的基础运算，就是拿到公钥指数E和模数N，将模数N分解为两个质因数，求得私钥指数d，从而利用加密过程或解密过程将最终的内容拿到。\n### 这里需要讲一下公钥加密解密体系\n* 以对称加密为例，加密所使用的密钥与解密所使用的密钥是同一个，这样破译的难点集中于加密函数复杂度的设计以及密钥的长度，更多的是一种线性的处理方式；而公钥加密体系将这种问题避开，转而将加密解密的数据进行基于离散数学的运算，这里就提到了我们公私钥指数的关系\n```\ne*d≡1 (mod phi)\n```\n* 在数值小的时候运算是极为简单的，不过当数值增加到指数次方时，求离散数学的逆的难度也会相对应地指数次增长。\n* 但并不是说，公钥破解难度只在这里。好多教材和论文，将rsa这种基于大素数的公钥加密的破解，都解释为只要能够将大素数分解，这个加密体系就不复存在。其实，并没有直接证据能够证明，大素数分解与公钥破解的直接联系。\n* 就比如在RSA的解密过程中，当e=3，此时N为分解难度特别大的2048bit级别时，仍旧可以利用低指数攻击，在不分解N的情况下，将整个密文完整解密出来，所以众多的rsa的攻击方式来源不止是针对N的分解，更多的是从RSA的其他参数下手，使得解密过程更为简单便捷。\n\n* 接下来我们用几道例题来说明\n\n## 例题1\n```\n在RSA中，已知C=34 ，N=123，e=11,那么m为多少？\n```\n* 开始分析，这里知道N，我们使用YAFU分解，可以知道N的两个素因数是3和41\n求得phi=240=80,(11d)%phi=1,所以d=51\nm≡c^d (mod(N))=34^51(mod 123)=19\n\n* 这里用到的YAFU是一个在分解N常用的一个离线工具，它适用于素因数相差特别大或者特别小的情况，能够很快的分解出来，所以一些很小的数可能分解时间比大的数要长，原因在这里。\n\n* 除了这个以外，当面对特别大的素数时，我们可以使用在线网站 http://www.factordb.com/ ,这是一个在线网站，相当于是一个数据库，管理员将以往有分解出来的素数放在网站上，供查询。\n\n* 除此之外，利用算法进行脚本分解，不过成功率很低。\n## 例题2\n```\n题目所给一个加密enc文件和一个public.key文件，打开enc显示乱码\n```\n* public.key文件内容：\n![](https://note.youdao.com/yws/api/personal/file/E96950F29A6D49B883155E66A2FCAA4E?method=download&shareKey=fe3dd78b6638f345e7ba7ffd94c1fbc9)\n* 此时，用到了最常用的密钥工具——openssl，使用opsnssl可以方便的解读出公私钥文件的内容。\n* 使用命令，进行解析\n```\nopenssl rsa -pubin -text -modulus -in warmup -in public.key(这里的public.key可为public.pem,pubkey.pem等)\n```\n* 此命令下，解析内容如图所示\n\n* 之后按照例题1的步骤，进行解密\n* 不过这里的密文利用文件读取的指令，下面附上解题脚本\n![](https://note.youdao.com/yws/api/personal/file/3BB42A51A24E480D982E384770F8A445?method=download&shareKey=43c1fd4976fba9d4b1f14080ea0e32e9)\n* 最终的得到flag:flag{2o!9_CTF_ECUN}","slug":"rsa基础学习-1","published":1,"updated":"2020-05-28T10:47:32.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18j0020vcu94wd7ah15","content":"<h1 id=\"rsa基础\"><a href=\"#rsa基础\" class=\"headerlink\" title=\"rsa基础\"></a>rsa基础</h1><ul>\n<li><p>在rsa中常用的参数为：N,E,d,p,q,C,m,dp,dq</p>\n</li>\n<li><p>各参数所代表的含义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 参数N代表模数，在RSA中进行模运算</span><br><span class=\"line\">&lt;2&gt; 参数E，d分别代表公钥指数和私钥指数</span><br><span class=\"line\">&lt;3&gt; p,q分别为模数N分解后得到的值</span><br><span class=\"line\">&lt;4&gt; C，m分别代表密文和明文</span><br><span class=\"line\">&lt;5&gt; dp≡d mod (p−1)      dq≡d mod (q−1)这两个参数是在d的基础上的延申</span><br></pre></td></tr></table></figure></li>\n<li><p>各参数之间的关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; c≡m^e (mod N)    m≡c^d (mod N)</span><br><span class=\"line\">&lt;2&gt; phi&#x3D;(p-1)*(q-1)  e*d≡1 (mod phi)</span><br><span class=\"line\">这里很重要的一点是e,d的取值范围,1&lt;e&lt;phi,1&lt;d&lt;phi,同时gcd(phi,e)&#x3D;gcd(phi,d)&#x3D;1</span><br></pre></td></tr></table></figure></li>\n<li><p>这也是RSA解密的基础运算，就是拿到公钥指数E和模数N，将模数N分解为两个质因数，求得私钥指数d，从而利用加密过程或解密过程将最终的内容拿到。</p>\n<h3 id=\"这里需要讲一下公钥加密解密体系\"><a href=\"#这里需要讲一下公钥加密解密体系\" class=\"headerlink\" title=\"这里需要讲一下公钥加密解密体系\"></a>这里需要讲一下公钥加密解密体系</h3></li>\n<li><p>以对称加密为例，加密所使用的密钥与解密所使用的密钥是同一个，这样破译的难点集中于加密函数复杂度的设计以及密钥的长度，更多的是一种线性的处理方式；而公钥加密体系将这种问题避开，转而将加密解密的数据进行基于离散数学的运算，这里就提到了我们公私钥指数的关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e*d≡1 (mod phi)</span><br></pre></td></tr></table></figure></li>\n<li><p>在数值小的时候运算是极为简单的，不过当数值增加到指数次方时，求离散数学的逆的难度也会相对应地指数次增长。</p>\n</li>\n<li><p>但并不是说，公钥破解难度只在这里。好多教材和论文，将rsa这种基于大素数的公钥加密的破解，都解释为只要能够将大素数分解，这个加密体系就不复存在。其实，并没有直接证据能够证明，大素数分解与公钥破解的直接联系。</p>\n</li>\n<li><p>就比如在RSA的解密过程中，当e=3，此时N为分解难度特别大的2048bit级别时，仍旧可以利用低指数攻击，在不分解N的情况下，将整个密文完整解密出来，所以众多的rsa的攻击方式来源不止是针对N的分解，更多的是从RSA的其他参数下手，使得解密过程更为简单便捷。</p>\n</li>\n<li><p>接下来我们用几道例题来说明</p>\n</li>\n</ul>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在RSA中，已知C&#x3D;34 ，N&#x3D;123，e&#x3D;11,那么m为多少？</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>开始分析，这里知道N，我们使用YAFU分解，可以知道N的两个素因数是3和41<br>求得phi=240=80,(11d)%phi=1,所以d=51<br>m≡c^d (mod(N))=34^51(mod 123)=19</p>\n</li>\n<li><p>这里用到的YAFU是一个在分解N常用的一个离线工具，它适用于素因数相差特别大或者特别小的情况，能够很快的分解出来，所以一些很小的数可能分解时间比大的数要长，原因在这里。</p>\n</li>\n<li><p>除了这个以外，当面对特别大的素数时，我们可以使用在线网站 <a href=\"http://www.factordb.com/\" target=\"_blank\" rel=\"noopener\">http://www.factordb.com/</a> ,这是一个在线网站，相当于是一个数据库，管理员将以往有分解出来的素数放在网站上，供查询。</p>\n</li>\n<li><p>除此之外，利用算法进行脚本分解，不过成功率很低。</p>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">题目所给一个加密enc文件和一个public.key文件，打开enc显示乱码</span><br></pre></td></tr></table></figure></li>\n<li><p>public.key文件内容：<br><img src=\"https://note.youdao.com/yws/api/personal/file/E96950F29A6D49B883155E66A2FCAA4E?method=download&shareKey=fe3dd78b6638f345e7ba7ffd94c1fbc9\" alt=\"\"></p>\n</li>\n<li><p>此时，用到了最常用的密钥工具——openssl，使用opsnssl可以方便的解读出公私钥文件的内容。</p>\n</li>\n<li><p>使用命令，进行解析</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -pubin -text -modulus -in warmup -in public.key(这里的public.key可为public.pem,pubkey.pem等)</span><br></pre></td></tr></table></figure></li>\n<li><p>此命令下，解析内容如图所示</p>\n</li>\n<li><p>之后按照例题1的步骤，进行解密</p>\n</li>\n<li><p>不过这里的密文利用文件读取的指令，下面附上解题脚本<br><img src=\"https://note.youdao.com/yws/api/personal/file/3BB42A51A24E480D982E384770F8A445?method=download&shareKey=43c1fd4976fba9d4b1f14080ea0e32e9\" alt=\"\"></p>\n</li>\n<li><p>最终的得到flag:flag{2o!9_CTF_ECUN}</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"rsa基础\"><a href=\"#rsa基础\" class=\"headerlink\" title=\"rsa基础\"></a>rsa基础</h1><ul>\n<li><p>在rsa中常用的参数为：N,E,d,p,q,C,m,dp,dq</p>\n</li>\n<li><p>各参数所代表的含义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 参数N代表模数，在RSA中进行模运算</span><br><span class=\"line\">&lt;2&gt; 参数E，d分别代表公钥指数和私钥指数</span><br><span class=\"line\">&lt;3&gt; p,q分别为模数N分解后得到的值</span><br><span class=\"line\">&lt;4&gt; C，m分别代表密文和明文</span><br><span class=\"line\">&lt;5&gt; dp≡d mod (p−1)      dq≡d mod (q−1)这两个参数是在d的基础上的延申</span><br></pre></td></tr></table></figure></li>\n<li><p>各参数之间的关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; c≡m^e (mod N)    m≡c^d (mod N)</span><br><span class=\"line\">&lt;2&gt; phi&#x3D;(p-1)*(q-1)  e*d≡1 (mod phi)</span><br><span class=\"line\">这里很重要的一点是e,d的取值范围,1&lt;e&lt;phi,1&lt;d&lt;phi,同时gcd(phi,e)&#x3D;gcd(phi,d)&#x3D;1</span><br></pre></td></tr></table></figure></li>\n<li><p>这也是RSA解密的基础运算，就是拿到公钥指数E和模数N，将模数N分解为两个质因数，求得私钥指数d，从而利用加密过程或解密过程将最终的内容拿到。</p>\n<h3 id=\"这里需要讲一下公钥加密解密体系\"><a href=\"#这里需要讲一下公钥加密解密体系\" class=\"headerlink\" title=\"这里需要讲一下公钥加密解密体系\"></a>这里需要讲一下公钥加密解密体系</h3></li>\n<li><p>以对称加密为例，加密所使用的密钥与解密所使用的密钥是同一个，这样破译的难点集中于加密函数复杂度的设计以及密钥的长度，更多的是一种线性的处理方式；而公钥加密体系将这种问题避开，转而将加密解密的数据进行基于离散数学的运算，这里就提到了我们公私钥指数的关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e*d≡1 (mod phi)</span><br></pre></td></tr></table></figure></li>\n<li><p>在数值小的时候运算是极为简单的，不过当数值增加到指数次方时，求离散数学的逆的难度也会相对应地指数次增长。</p>\n</li>\n<li><p>但并不是说，公钥破解难度只在这里。好多教材和论文，将rsa这种基于大素数的公钥加密的破解，都解释为只要能够将大素数分解，这个加密体系就不复存在。其实，并没有直接证据能够证明，大素数分解与公钥破解的直接联系。</p>\n</li>\n<li><p>就比如在RSA的解密过程中，当e=3，此时N为分解难度特别大的2048bit级别时，仍旧可以利用低指数攻击，在不分解N的情况下，将整个密文完整解密出来，所以众多的rsa的攻击方式来源不止是针对N的分解，更多的是从RSA的其他参数下手，使得解密过程更为简单便捷。</p>\n</li>\n<li><p>接下来我们用几道例题来说明</p>\n</li>\n</ul>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在RSA中，已知C&#x3D;34 ，N&#x3D;123，e&#x3D;11,那么m为多少？</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>开始分析，这里知道N，我们使用YAFU分解，可以知道N的两个素因数是3和41<br>求得phi=240=80,(11d)%phi=1,所以d=51<br>m≡c^d (mod(N))=34^51(mod 123)=19</p>\n</li>\n<li><p>这里用到的YAFU是一个在分解N常用的一个离线工具，它适用于素因数相差特别大或者特别小的情况，能够很快的分解出来，所以一些很小的数可能分解时间比大的数要长，原因在这里。</p>\n</li>\n<li><p>除了这个以外，当面对特别大的素数时，我们可以使用在线网站 <a href=\"http://www.factordb.com/\" target=\"_blank\" rel=\"noopener\">http://www.factordb.com/</a> ,这是一个在线网站，相当于是一个数据库，管理员将以往有分解出来的素数放在网站上，供查询。</p>\n</li>\n<li><p>除此之外，利用算法进行脚本分解，不过成功率很低。</p>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">题目所给一个加密enc文件和一个public.key文件，打开enc显示乱码</span><br></pre></td></tr></table></figure></li>\n<li><p>public.key文件内容：<br><img src=\"https://note.youdao.com/yws/api/personal/file/E96950F29A6D49B883155E66A2FCAA4E?method=download&shareKey=fe3dd78b6638f345e7ba7ffd94c1fbc9\" alt=\"\"></p>\n</li>\n<li><p>此时，用到了最常用的密钥工具——openssl，使用opsnssl可以方便的解读出公私钥文件的内容。</p>\n</li>\n<li><p>使用命令，进行解析</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -pubin -text -modulus -in warmup -in public.key(这里的public.key可为public.pem,pubkey.pem等)</span><br></pre></td></tr></table></figure></li>\n<li><p>此命令下，解析内容如图所示</p>\n</li>\n<li><p>之后按照例题1的步骤，进行解密</p>\n</li>\n<li><p>不过这里的密文利用文件读取的指令，下面附上解题脚本<br><img src=\"https://note.youdao.com/yws/api/personal/file/3BB42A51A24E480D982E384770F8A445?method=download&shareKey=43c1fd4976fba9d4b1f14080ea0e32e9\" alt=\"\"></p>\n</li>\n<li><p>最终的得到flag:flag{2o!9_CTF_ECUN}</p>\n</li>\n</ul>\n"},{"title":"rsa已知e*d分解N","author":"人生若只如初见","date":"2020-05-28T10:30:00.000Z","_content":"# 基本特征\n\n* 前面说过RSA的基本参数，我们知道e*d≡1 mod (p-1)*(q-1).\n* 这个题型是说，当我们从题目中得到e*d和N的值时，如何通过分解N来解密ｒｓａ\n# 简述\n\n* 输入e,d\n\n* e,d都是奇数，因为它们相对于(p-1)*(q-1)都是素数\n\n* 通过建立e*d=1 mod Φ(N)\n\n* 让e*d-1=2^k * r(r 是奇数)\n\n* 让(1<b<N)，从中随机挑选b\n\n* 如果gcd(b,N)>1,我们就停止\n\n* 否则 b∈ZN*, 那么b^(e*d-1)=1 mod N\n\n* 让e*d-1=2^k  *r  当r是奇数，b^(e*d-1)=1 mod N ,求mod N\\\n\n* a0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.\n\n```\n1.我们知道ak=1  让j是aj =1mod  N 的最小指数\n2. 如果0<j并且a(j-1) 不等于N-1那么a(j-1)是关于1mod  N 的一个非平凡根\n```\n\n## 定理\n\n```\n至少有一半的b，1<b<N，满足是1 mod N 的一个非平凡根\n\n\n证明过程：\n如果x^2=1 mod N 并且 x不等于1，N-1 那么gcd(x+1,N)>0\n\n证明过程：x^2 -1 =(x+1)*(x-1) .      N除以乘积，但是x不等于N-1,1.\n\t    因此N不能除以(x-1)或者(x+1)\n\t    所以p必须除以其中一个,q除以另外一个\n```\n\n## 范围\n\n```\n输入d,e,N,随机选择b\n让e*d-1=2^k *r (r是奇数)，b^(e*d-1)=1 mod N\n求mod N\na0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.\n由定理可知，对于概率大于 0.5，aj中的一个是1模N的非平凡平方根，这样的根产生N的因式分解\n\n\n所有的操作都是在log N内\n```\n\n# 例题\n\n```\nN=2773   e=17   d=157\n\n计算过程:\ne*d-1=2668=2^2  *667\n随机挑选b，进行mod 2773的操作\nb=7   7^667=1 mod N        不好\n b=8   8^667=471 mod N, 并且 471^2=1 mod N,所以471是1 mod 2773的非平凡平方根\n\nGcd(472,N)=59          gcd(470,N)=47\n2773//59=47\n```\n\n# 总结：\n\n```\n1、设定k=e*d-1\n2、从2到N-1的范围内随机选择一个数字g\n3、将k写成2^t  *r 的形式\n4、如果t能被2整除，那么t=t/2,并且x=g^t mod N ,直到x>1\n5、在满足x>1的情况下，如果y=gcd(x-1,N)>1,那么其中一个因数p=y， 另一个因数为N/y,如果不满足条件，返回步骤2，重新选择数字g\n```","source":"_posts/rsa已知e-d分解N.md","raw":"title: rsa已知e*d分解N\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-05-28 18:30:00\n---\n# 基本特征\n\n* 前面说过RSA的基本参数，我们知道e*d≡1 mod (p-1)*(q-1).\n* 这个题型是说，当我们从题目中得到e*d和N的值时，如何通过分解N来解密ｒｓａ\n# 简述\n\n* 输入e,d\n\n* e,d都是奇数，因为它们相对于(p-1)*(q-1)都是素数\n\n* 通过建立e*d=1 mod Φ(N)\n\n* 让e*d-1=2^k * r(r 是奇数)\n\n* 让(1<b<N)，从中随机挑选b\n\n* 如果gcd(b,N)>1,我们就停止\n\n* 否则 b∈ZN*, 那么b^(e*d-1)=1 mod N\n\n* 让e*d-1=2^k  *r  当r是奇数，b^(e*d-1)=1 mod N ,求mod N\\\n\n* a0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.\n\n```\n1.我们知道ak=1  让j是aj =1mod  N 的最小指数\n2. 如果0<j并且a(j-1) 不等于N-1那么a(j-1)是关于1mod  N 的一个非平凡根\n```\n\n## 定理\n\n```\n至少有一半的b，1<b<N，满足是1 mod N 的一个非平凡根\n\n\n证明过程：\n如果x^2=1 mod N 并且 x不等于1，N-1 那么gcd(x+1,N)>0\n\n证明过程：x^2 -1 =(x+1)*(x-1) .      N除以乘积，但是x不等于N-1,1.\n\t    因此N不能除以(x-1)或者(x+1)\n\t    所以p必须除以其中一个,q除以另外一个\n```\n\n## 范围\n\n```\n输入d,e,N,随机选择b\n让e*d-1=2^k *r (r是奇数)，b^(e*d-1)=1 mod N\n求mod N\na0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.\n由定理可知，对于概率大于 0.5，aj中的一个是1模N的非平凡平方根，这样的根产生N的因式分解\n\n\n所有的操作都是在log N内\n```\n\n# 例题\n\n```\nN=2773   e=17   d=157\n\n计算过程:\ne*d-1=2668=2^2  *667\n随机挑选b，进行mod 2773的操作\nb=7   7^667=1 mod N        不好\n b=8   8^667=471 mod N, 并且 471^2=1 mod N,所以471是1 mod 2773的非平凡平方根\n\nGcd(472,N)=59          gcd(470,N)=47\n2773//59=47\n```\n\n# 总结：\n\n```\n1、设定k=e*d-1\n2、从2到N-1的范围内随机选择一个数字g\n3、将k写成2^t  *r 的形式\n4、如果t能被2整除，那么t=t/2,并且x=g^t mod N ,直到x>1\n5、在满足x>1的情况下，如果y=gcd(x-1,N)>1,那么其中一个因数p=y， 另一个因数为N/y,如果不满足条件，返回步骤2，重新选择数字g\n```","slug":"rsa已知e-d分解N","published":1,"updated":"2020-05-28T10:44:58.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18j0022vcu911dw6r4s","content":"<h1 id=\"基本特征\"><a href=\"#基本特征\" class=\"headerlink\" title=\"基本特征\"></a>基本特征</h1><ul>\n<li><p>前面说过RSA的基本参数，我们知道e<em>d≡1 mod (p-1)</em>(q-1).</p>\n</li>\n<li><p>这个题型是说，当我们从题目中得到e*d和N的值时，如何通过分解N来解密ｒｓａ</p>\n<h1 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h1></li>\n<li><p>输入e,d</p>\n</li>\n<li><p>e,d都是奇数，因为它们相对于(p-1)*(q-1)都是素数</p>\n</li>\n<li><p>通过建立e*d=1 mod Φ(N)</p>\n</li>\n<li><p>让e*d-1=2^k * r(r 是奇数)</p>\n</li>\n<li><p>让(1&lt;b&lt;N)，从中随机挑选b</p>\n</li>\n<li><p>如果gcd(b,N)&gt;1,我们就停止</p>\n</li>\n<li><p>否则 b∈ZN<em>, 那么b^(e</em>d-1)=1 mod N</p>\n</li>\n<li><p>让e<em>d-1=2^k  *r  当r是奇数，b^(e</em>d-1)=1 mod N ,求mod N\\</p>\n</li>\n<li><p>a0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.我们知道ak&#x3D;1  让j是aj &#x3D;1mod  N 的最小指数</span><br><span class=\"line\">2. 如果0&lt;j并且a(j-1) 不等于N-1那么a(j-1)是关于1mod  N 的一个非平凡根</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定理\"><a href=\"#定理\" class=\"headerlink\" title=\"定理\"></a>定理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">至少有一半的b，1&lt;b&lt;N，满足是1 mod N 的一个非平凡根</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">证明过程：</span><br><span class=\"line\">如果x^2&#x3D;1 mod N 并且 x不等于1，N-1 那么gcd(x+1,N)&gt;0</span><br><span class=\"line\"></span><br><span class=\"line\">证明过程：x^2 -1 &#x3D;(x+1)*(x-1) .      N除以乘积，但是x不等于N-1,1.</span><br><span class=\"line\">\t    因此N不能除以(x-1)或者(x+1)</span><br><span class=\"line\">\t    所以p必须除以其中一个,q除以另外一个</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a>范围</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入d,e,N,随机选择b</span><br><span class=\"line\">让e*d-1&#x3D;2^k *r (r是奇数)，b^(e*d-1)&#x3D;1 mod N</span><br><span class=\"line\">求mod N</span><br><span class=\"line\">a0 &#x3D; b^r, a1 &#x3D; (a0)^2, a2 &#x3D; (a1)^2,…, ak &#x3D; (ak-1)^2.</span><br><span class=\"line\">由定理可知，对于概率大于 0.5，aj中的一个是1模N的非平凡平方根，这样的根产生N的因式分解</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">所有的操作都是在log N内</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">N&#x3D;2773   e&#x3D;17   d&#x3D;157</span><br><span class=\"line\"></span><br><span class=\"line\">计算过程:</span><br><span class=\"line\">e*d-1&#x3D;2668&#x3D;2^2  *667</span><br><span class=\"line\">随机挑选b，进行mod 2773的操作</span><br><span class=\"line\">b&#x3D;7   7^667&#x3D;1 mod N        不好</span><br><span class=\"line\"> b&#x3D;8   8^667&#x3D;471 mod N, 并且 471^2&#x3D;1 mod N,所以471是1 mod 2773的非平凡平方根</span><br><span class=\"line\"></span><br><span class=\"line\">Gcd(472,N)&#x3D;59          gcd(470,N)&#x3D;47</span><br><span class=\"line\">2773&#x2F;&#x2F;59&#x3D;47</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、设定k&#x3D;e*d-1</span><br><span class=\"line\">2、从2到N-1的范围内随机选择一个数字g</span><br><span class=\"line\">3、将k写成2^t  *r 的形式</span><br><span class=\"line\">4、如果t能被2整除，那么t&#x3D;t&#x2F;2,并且x&#x3D;g^t mod N ,直到x&gt;1</span><br><span class=\"line\">5、在满足x&gt;1的情况下，如果y&#x3D;gcd(x-1,N)&gt;1,那么其中一个因数p&#x3D;y， 另一个因数为N&#x2F;y,如果不满足条件，返回步骤2，重新选择数字g</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本特征\"><a href=\"#基本特征\" class=\"headerlink\" title=\"基本特征\"></a>基本特征</h1><ul>\n<li><p>前面说过RSA的基本参数，我们知道e<em>d≡1 mod (p-1)</em>(q-1).</p>\n</li>\n<li><p>这个题型是说，当我们从题目中得到e*d和N的值时，如何通过分解N来解密ｒｓａ</p>\n<h1 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h1></li>\n<li><p>输入e,d</p>\n</li>\n<li><p>e,d都是奇数，因为它们相对于(p-1)*(q-1)都是素数</p>\n</li>\n<li><p>通过建立e*d=1 mod Φ(N)</p>\n</li>\n<li><p>让e*d-1=2^k * r(r 是奇数)</p>\n</li>\n<li><p>让(1&lt;b&lt;N)，从中随机挑选b</p>\n</li>\n<li><p>如果gcd(b,N)&gt;1,我们就停止</p>\n</li>\n<li><p>否则 b∈ZN<em>, 那么b^(e</em>d-1)=1 mod N</p>\n</li>\n<li><p>让e<em>d-1=2^k  *r  当r是奇数，b^(e</em>d-1)=1 mod N ,求mod N\\</p>\n</li>\n<li><p>a0 = b^r, a1 = (a0)^2, a2 = (a1)^2,…, ak = (ak-1)^2.</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.我们知道ak&#x3D;1  让j是aj &#x3D;1mod  N 的最小指数</span><br><span class=\"line\">2. 如果0&lt;j并且a(j-1) 不等于N-1那么a(j-1)是关于1mod  N 的一个非平凡根</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定理\"><a href=\"#定理\" class=\"headerlink\" title=\"定理\"></a>定理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">至少有一半的b，1&lt;b&lt;N，满足是1 mod N 的一个非平凡根</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">证明过程：</span><br><span class=\"line\">如果x^2&#x3D;1 mod N 并且 x不等于1，N-1 那么gcd(x+1,N)&gt;0</span><br><span class=\"line\"></span><br><span class=\"line\">证明过程：x^2 -1 &#x3D;(x+1)*(x-1) .      N除以乘积，但是x不等于N-1,1.</span><br><span class=\"line\">\t    因此N不能除以(x-1)或者(x+1)</span><br><span class=\"line\">\t    所以p必须除以其中一个,q除以另外一个</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a>范围</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入d,e,N,随机选择b</span><br><span class=\"line\">让e*d-1&#x3D;2^k *r (r是奇数)，b^(e*d-1)&#x3D;1 mod N</span><br><span class=\"line\">求mod N</span><br><span class=\"line\">a0 &#x3D; b^r, a1 &#x3D; (a0)^2, a2 &#x3D; (a1)^2,…, ak &#x3D; (ak-1)^2.</span><br><span class=\"line\">由定理可知，对于概率大于 0.5，aj中的一个是1模N的非平凡平方根，这样的根产生N的因式分解</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">所有的操作都是在log N内</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">N&#x3D;2773   e&#x3D;17   d&#x3D;157</span><br><span class=\"line\"></span><br><span class=\"line\">计算过程:</span><br><span class=\"line\">e*d-1&#x3D;2668&#x3D;2^2  *667</span><br><span class=\"line\">随机挑选b，进行mod 2773的操作</span><br><span class=\"line\">b&#x3D;7   7^667&#x3D;1 mod N        不好</span><br><span class=\"line\"> b&#x3D;8   8^667&#x3D;471 mod N, 并且 471^2&#x3D;1 mod N,所以471是1 mod 2773的非平凡平方根</span><br><span class=\"line\"></span><br><span class=\"line\">Gcd(472,N)&#x3D;59          gcd(470,N)&#x3D;47</span><br><span class=\"line\">2773&#x2F;&#x2F;59&#x3D;47</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、设定k&#x3D;e*d-1</span><br><span class=\"line\">2、从2到N-1的范围内随机选择一个数字g</span><br><span class=\"line\">3、将k写成2^t  *r 的形式</span><br><span class=\"line\">4、如果t能被2整除，那么t&#x3D;t&#x2F;2,并且x&#x3D;g^t mod N ,直到x&gt;1</span><br><span class=\"line\">5、在满足x&gt;1的情况下，如果y&#x3D;gcd(x-1,N)&gt;1,那么其中一个因数p&#x3D;y， 另一个因数为N&#x2F;y,如果不满足条件，返回步骤2，重新选择数字g</span><br></pre></td></tr></table></figure>"},{"title":"rsa已知高位攻击","author":"人生若只如初见","date":"2020-05-27T03:54:00.000Z","_content":"# 已知高位攻击利用\n* 基础讲解：\n# 1. 格的基础\n* 格的基础概念：设v1,v2,….,vm线性无关，m维格L（v1,v2,….,vm）是指由向量v1,v2,….,vm生成的一个向量集，它的形式为——L（v1,v2,….,vm）=Σ ai * vi, (i=1,2,….,m ai∈Z)\n称{v1,v2,….,vm}为格L的一组基，且记Dim(L)=m; m、n分别为格L的维数和秩，当m=n时，称格L是满维的。\n# 2. 格基规约\n* 同一个格可以使用不同的基来表示，解决格上的问题时，即使使用同一种算法，如果选用不同的基，最后的运行时间和运行结果差别也是十分明显的。选择最优的一组基的过程就是格基规约，并称这样的一组基为格的一组规约基。常见的两种规约方法是Gauss规约和LLL规约。\n![](https://note.youdao.com/yws/api/personal/file/3E79235F98824E54871C18C516CCC71D?method=download&shareKey=719882fdcdade620567084447f055b72)\n* 其实综上所述，已知高位攻击就是将问题转换到格的数学问题中，转向求格的最短非零向量\n\n* 格基规约算法应用于密码分析的另一个重要方面就是线性同余结尾序列的重构。\n\n# 重点（伪随机序列的还原重构）\n## LLL-算法在密码分析中的应用(攻克线性同余结尾序列)\n* 众所周知, 线性同余是产生伪随机序列的一个极其简便流行的手段.但是, 若将原序列原样输出,而不做\n* 处理的话 ,即使是在不知道模数与乘子的情况下, 序列也能被轻易地重构(即还原出模数与乘子).于是, 为了增强抗攻击力,Knuth 提出了截尾序列生成器\n* 该生成器模型如下 :\n```\n输入初值 x 0 ,递归生成序列{x i }:x i+1 =ax i +b mod m , a , b , m ∈ Z ,输出序列{y i }:y i =[ x i /2 βv ] \n```\n* 其中v 为m 的比特数 , β =1 -α而α为输出y i 的比特数占原x i 的比特数之比例.\n* 由于对{x i }做了截尾处理, 使重构困难了.早期的计算机上曾广泛使用了类似的方法产生伪随机整数序列 .其方法是将 n 比特数平方后, 丢弃头尾各n/2 比特\n\n# J.S算法\n* 功能 　设得到 n +t 长的序列 ,记为 y 1 , y 2 , …, y t , y t+1 , …, y t+n ,其中 n ≈(2 αt log m)1/2,且原序列{xi}中(x 1 -x 0 , m)=1.J.S.算法能求出模数 m 和乘子a , 从而重构了原模型\n\n* 描述：\n```\n<1> 做Vi=[y(i+1) - yi ,  y(i+2)-y(i+1)....,y(i+t)-y(i+t)-1],  i=1,2,...,n.\n<2> 适当选取 k , 考虑 kV 1 , kV 2 , …, kV n 作输入 , 执行 KILL- 算法 , 得到 λ=(λ 1 , λ 2 , …, λ n ), 且∑λ i V i =0   (i=1，2,...,n), λ 较小.\n<3> 做多项式 P(x)=Σλi * X^i  (i=1,2,...,n)\n<4> 重复(1)～ (3)多次 ,得到多项式序列 p 1 , p 2 , …, p r .将p i 自然映射到Z^(n+1) 上.应用LLL-算法于p 1 , p 2 ,…, p r 上, 得到生成的格 L 的一组 LLL-约基 ,计算 d(L),令m =d(L),输出 m \n<5> 将 L 的基中次数 ≥2的向量乘以大整数 K (K ≥m 2^(n/2) ),再构成子格 L′, 执行 LLL-算法 ,找到 L′的一组 LLL-约基 .运用线性代数的知识,利用 LLL-约基, 找到首一多项式 A(x).令a =A(0), 输出 a .算法结束 .\n```\n* 注意：在（4）中多项式个数r≤（6α-1）㏒ m ㏒ ㏒ m,就可以满足要求了，算法中执行的LLL-算法其实是LLL-算法在输入任意r个向量(有可能线性相关)情况时的改进算法\n\n# coppersmith的一些定理:\n```\n<1>定理3.3 对任意的a > 0 ， 给定N = PQR及PQ的高位(1/5)(logN,2)比特，我们可以在多项式时间logN内得到N的分解式。这是三个因式的分解。也就是说我们现在是由理论依据的，已知高位是可以在一定时间内分解N。\n<2>已知p高位u多少位菜可以进行攻击呢？定理是在《Mathematics_of_Public_Key_Cryptography》这本数里面提到的，我们将我们上面得到的N的值带入上图的式子中。计算(1/根号2)*N\n```\n* 由上式得出：\n\n```\nif p.bit_length == 1024 ,p的高位需已知约576位\n\nif p.bit_length == 1024 ,p的高位需已知约288位\n```\n* 1.sage里面的small_roots能实现上述的给出已知的p高位进行分解N的函数方法，利用了LLL算法求解非线性低维度多项式方程小根的方法。\n\n* 2.Coppersmith证明了在已知p和q部分比特的情况下，若q和p的未知部分的上界X和Y满足XY <= N ^ (0.5)则Ｎ的多项式可以被分解。\n这里的0.5可以替换成其他的数，具体原因不详。\n\n* 链接：\n  [sage里small_roots的具体用法](https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots)\n\n# 已知高位攻击分为三种情况\n```\n<1>已知P的高位\n<2>已知d的高位\n<3>已知m的高位\n```\n## 已知P的高位\n\n* 知道p的高位为p的位数的约1/2时即可\n\n* 已知e,n爆破 1024的P，至少需要知道前576位二进制，即前144位16进制(特殊情况下，可能所得到的已知位数稍小于144位，需要爆破两三位，然后使用sage脚本)\n* 正好已知144位16进制的情况\n```\nn=\np4=            #已知P的高位\ne=\npbits=          #P原本的位数\n\nkbits=pbits - p4.nbits()\nprint p4.nbits()\np4 = p4 << kbits\nPR.<x> = PolynomialRing(Zmod(n))\nf = x + p4\nroots = f.small_roots(X=2^kbits,beta=0.4)\n# 经过以上一些函数处理后，n和p已经被转化为10进制\nif roots:\n    p= p4 + int(roots([0]))\n    print \"n\",n\n    print \"p\",p\n    print \"q\",n/p\n```\n* 已知142位16进制的情况\n```\nn=\np4=            #已知P的高位,最后面8位二进制，也就是两位十六进制要参与爆破，所以要用00补充\ne=\npbits=          #P原本的位数\n\n\nfor i in range(0,256):        # 要爆破的8位二进制数，为2**8==256，表示0~255\n    p4 =\n    p4 = p4 + int(hex(i),16)\n#print hex(p4)\n\n\nkbits=pbits - p4.nbits()\nprint p4.nbits()\np4 = p4 << kbits\nPR.<x> = PolynomialRing(Zmod(n))\nf = x + p4\nroots = f.small_roots(X=2^kbits,beta=0.4)\n# 经过以上一些函数处理后，n和p已经被转化为10进制\nif roots:\n    p= p4 + int(roots([0]))\n    print \"n\",n\n    print \"p\",p\n    print \"q\",n/p\n```\n## 已知d的高位\n\n* 如果知道d的低位，低位约为n的位数的1/4就可以恢复d。已知私钥的512位的低位 Partial Key Exposure Attack(部分私钥暴露攻击)\n```\ndef partial_p(p0, kbits, n):\n \n    PR.<x> = PolynomialRing(Zmod(n))\n \n    nbits = n.nbits()\n \n \n \n    f = 2^kbits*x + p0\n \n    f = f.monic()\n \n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root < 2^(nbits//2-kbits) with factor >= n^0.3\n \n    if roots:\n \n        x0 = roots[0]\n \n        p = gcd(2^kbits*x0 + p0, n)\n \n        return ZZ(p)\n \n \n \ndef find_p(d0, kbits, e, n):\n \n    X = var('X')\n \n \n \n    for k in xrange(1, e+1):\n \n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n \n        for x in results:\n \n            p0 = ZZ(x[0])\n \n            p = partial_p(p0, kbits, n)\n \n            if p:\n \n                return p\n \n \n \n \n \nif __name__ == '__main__':\n \n    n = 0xd463feb999c9292e25acd7f98d49a13413df2c4e74820136e739281bb394a73f2d1e6b53066932f50a73310360e5a5c622507d8662dadaef860b3266222129fd645eb74a0207af9bd79a9794f4bd21f32841ce9e1700b0b049cfadb760993fcfc7c65eca63904aa197df306cad8720b1b228484629cf967d808c13f6caef94a9\n \n    e = 3\n \n    d = 0x603d033f2ef6c759aec839f132a45215fc8a635b757f3951a731fe60bc6729b3bcf819b57abfcaba3a93e9edef766c0d499cad3f7adb306bcf1645cfb63400e3\n \n \n \n    beta = 0.5\n \n    epsilon = beta^2/7\n \n \n \n    nbits = n.nbits()\n \n    print \"nbits:%d:\"%(nbits)\n \n    #kbits = floor(nbits*(beta^2+epsilon))\n \n    kbits = nbits - d.nbits()-1\n \n    print \"kbits:%d\"%(kbits)\n \n    d0 = d & (2^kbits-1)\n \n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n \n \n \n    p = find_p(d0, kbits, e, n)\n \n    print \"found p: %d\" % p\n \n    q = n//p\n \n    print d\n \nprint inverse_mod(e, (p-1)*(q-1))\n```\n## 已知明文m的高位\n\n* 已知明文的高位，是Stereotyped messages攻击 或 Lattice based attacks \n```\nn = 0x2519834a6cc3bf25d078caefc5358e41c726a7a56270e425e21515d1b195b248b82f4189a0b621694586bb254e27010ee4376a849bb373e5e3f2eb622e3e7804d18ddb897463f3516b431e7fc65ec41c42edf736d5940c3139d1e374aed1fc3b70737125e1f540b541a9c671f4bf0ded798d727211116eb8b86cdd6a29aefcc7\n\ne = 3\nm = randrange(n)\nc = pow(m, e, n)\n\nbeta = 1\n \nepsilon = beta^2/7\n \nnbits = n.nbits()\n \nkbits = floor(nbits*(beta^2/e-epsilon))\n \n#mbar = m & (2^nbits-2^kbits)\n \nmbar = 0xb11ffc4ce423c77035280f1c575696327901daac8a83c057c453973ee5f4e508455648886441c0f3393fe4c922ef1c3a6249c12d21a000000000000000000\n \nc = 0x1f6f6a8e61f7b5ad8bef738f4376a96724192d8da1e3689dec7ce5d1df615e0910803317f9bafb6671ffe722e0292ce76cca399f2af1952dd31a61b37019da9cf27f82c3ecd4befc03c557efe1a5a29f9bb73c0239f62ed951955718ac0eaa3f60a4c415ef064ea33bbd61abe127c6fc808c0edb034c52c45bd20a219317fb75\n \nprint \"upper %d bits (of %d bits) is given\" % (nbits-kbits, nbits)\n \nPR.<x> = PolynomialRing(Zmod(n))\n \nf = (mbar + x)^e - c\n\nprint m\nx0 = f.small_roots(X=2^kbits, beta=1)[0]  # find root < 2^kbits with factor = n1\nprint mbar + x0\n```","source":"_posts/rsa已知高位攻击1.md","raw":"title: rsa已知高位攻击\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-05-27 11:54:00\n---\n# 已知高位攻击利用\n* 基础讲解：\n# 1. 格的基础\n* 格的基础概念：设v1,v2,….,vm线性无关，m维格L（v1,v2,….,vm）是指由向量v1,v2,….,vm生成的一个向量集，它的形式为——L（v1,v2,….,vm）=Σ ai * vi, (i=1,2,….,m ai∈Z)\n称{v1,v2,….,vm}为格L的一组基，且记Dim(L)=m; m、n分别为格L的维数和秩，当m=n时，称格L是满维的。\n# 2. 格基规约\n* 同一个格可以使用不同的基来表示，解决格上的问题时，即使使用同一种算法，如果选用不同的基，最后的运行时间和运行结果差别也是十分明显的。选择最优的一组基的过程就是格基规约，并称这样的一组基为格的一组规约基。常见的两种规约方法是Gauss规约和LLL规约。\n![](https://note.youdao.com/yws/api/personal/file/3E79235F98824E54871C18C516CCC71D?method=download&shareKey=719882fdcdade620567084447f055b72)\n* 其实综上所述，已知高位攻击就是将问题转换到格的数学问题中，转向求格的最短非零向量\n\n* 格基规约算法应用于密码分析的另一个重要方面就是线性同余结尾序列的重构。\n\n# 重点（伪随机序列的还原重构）\n## LLL-算法在密码分析中的应用(攻克线性同余结尾序列)\n* 众所周知, 线性同余是产生伪随机序列的一个极其简便流行的手段.但是, 若将原序列原样输出,而不做\n* 处理的话 ,即使是在不知道模数与乘子的情况下, 序列也能被轻易地重构(即还原出模数与乘子).于是, 为了增强抗攻击力,Knuth 提出了截尾序列生成器\n* 该生成器模型如下 :\n```\n输入初值 x 0 ,递归生成序列{x i }:x i+1 =ax i +b mod m , a , b , m ∈ Z ,输出序列{y i }:y i =[ x i /2 βv ] \n```\n* 其中v 为m 的比特数 , β =1 -α而α为输出y i 的比特数占原x i 的比特数之比例.\n* 由于对{x i }做了截尾处理, 使重构困难了.早期的计算机上曾广泛使用了类似的方法产生伪随机整数序列 .其方法是将 n 比特数平方后, 丢弃头尾各n/2 比特\n\n# J.S算法\n* 功能 　设得到 n +t 长的序列 ,记为 y 1 , y 2 , …, y t , y t+1 , …, y t+n ,其中 n ≈(2 αt log m)1/2,且原序列{xi}中(x 1 -x 0 , m)=1.J.S.算法能求出模数 m 和乘子a , 从而重构了原模型\n\n* 描述：\n```\n<1> 做Vi=[y(i+1) - yi ,  y(i+2)-y(i+1)....,y(i+t)-y(i+t)-1],  i=1,2,...,n.\n<2> 适当选取 k , 考虑 kV 1 , kV 2 , …, kV n 作输入 , 执行 KILL- 算法 , 得到 λ=(λ 1 , λ 2 , …, λ n ), 且∑λ i V i =0   (i=1，2,...,n), λ 较小.\n<3> 做多项式 P(x)=Σλi * X^i  (i=1,2,...,n)\n<4> 重复(1)～ (3)多次 ,得到多项式序列 p 1 , p 2 , …, p r .将p i 自然映射到Z^(n+1) 上.应用LLL-算法于p 1 , p 2 ,…, p r 上, 得到生成的格 L 的一组 LLL-约基 ,计算 d(L),令m =d(L),输出 m \n<5> 将 L 的基中次数 ≥2的向量乘以大整数 K (K ≥m 2^(n/2) ),再构成子格 L′, 执行 LLL-算法 ,找到 L′的一组 LLL-约基 .运用线性代数的知识,利用 LLL-约基, 找到首一多项式 A(x).令a =A(0), 输出 a .算法结束 .\n```\n* 注意：在（4）中多项式个数r≤（6α-1）㏒ m ㏒ ㏒ m,就可以满足要求了，算法中执行的LLL-算法其实是LLL-算法在输入任意r个向量(有可能线性相关)情况时的改进算法\n\n# coppersmith的一些定理:\n```\n<1>定理3.3 对任意的a > 0 ， 给定N = PQR及PQ的高位(1/5)(logN,2)比特，我们可以在多项式时间logN内得到N的分解式。这是三个因式的分解。也就是说我们现在是由理论依据的，已知高位是可以在一定时间内分解N。\n<2>已知p高位u多少位菜可以进行攻击呢？定理是在《Mathematics_of_Public_Key_Cryptography》这本数里面提到的，我们将我们上面得到的N的值带入上图的式子中。计算(1/根号2)*N\n```\n* 由上式得出：\n\n```\nif p.bit_length == 1024 ,p的高位需已知约576位\n\nif p.bit_length == 1024 ,p的高位需已知约288位\n```\n* 1.sage里面的small_roots能实现上述的给出已知的p高位进行分解N的函数方法，利用了LLL算法求解非线性低维度多项式方程小根的方法。\n\n* 2.Coppersmith证明了在已知p和q部分比特的情况下，若q和p的未知部分的上界X和Y满足XY <= N ^ (0.5)则Ｎ的多项式可以被分解。\n这里的0.5可以替换成其他的数，具体原因不详。\n\n* 链接：\n  [sage里small_roots的具体用法](https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots)\n\n# 已知高位攻击分为三种情况\n```\n<1>已知P的高位\n<2>已知d的高位\n<3>已知m的高位\n```\n## 已知P的高位\n\n* 知道p的高位为p的位数的约1/2时即可\n\n* 已知e,n爆破 1024的P，至少需要知道前576位二进制，即前144位16进制(特殊情况下，可能所得到的已知位数稍小于144位，需要爆破两三位，然后使用sage脚本)\n* 正好已知144位16进制的情况\n```\nn=\np4=            #已知P的高位\ne=\npbits=          #P原本的位数\n\nkbits=pbits - p4.nbits()\nprint p4.nbits()\np4 = p4 << kbits\nPR.<x> = PolynomialRing(Zmod(n))\nf = x + p4\nroots = f.small_roots(X=2^kbits,beta=0.4)\n# 经过以上一些函数处理后，n和p已经被转化为10进制\nif roots:\n    p= p4 + int(roots([0]))\n    print \"n\",n\n    print \"p\",p\n    print \"q\",n/p\n```\n* 已知142位16进制的情况\n```\nn=\np4=            #已知P的高位,最后面8位二进制，也就是两位十六进制要参与爆破，所以要用00补充\ne=\npbits=          #P原本的位数\n\n\nfor i in range(0,256):        # 要爆破的8位二进制数，为2**8==256，表示0~255\n    p4 =\n    p4 = p4 + int(hex(i),16)\n#print hex(p4)\n\n\nkbits=pbits - p4.nbits()\nprint p4.nbits()\np4 = p4 << kbits\nPR.<x> = PolynomialRing(Zmod(n))\nf = x + p4\nroots = f.small_roots(X=2^kbits,beta=0.4)\n# 经过以上一些函数处理后，n和p已经被转化为10进制\nif roots:\n    p= p4 + int(roots([0]))\n    print \"n\",n\n    print \"p\",p\n    print \"q\",n/p\n```\n## 已知d的高位\n\n* 如果知道d的低位，低位约为n的位数的1/4就可以恢复d。已知私钥的512位的低位 Partial Key Exposure Attack(部分私钥暴露攻击)\n```\ndef partial_p(p0, kbits, n):\n \n    PR.<x> = PolynomialRing(Zmod(n))\n \n    nbits = n.nbits()\n \n \n \n    f = 2^kbits*x + p0\n \n    f = f.monic()\n \n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root < 2^(nbits//2-kbits) with factor >= n^0.3\n \n    if roots:\n \n        x0 = roots[0]\n \n        p = gcd(2^kbits*x0 + p0, n)\n \n        return ZZ(p)\n \n \n \ndef find_p(d0, kbits, e, n):\n \n    X = var('X')\n \n \n \n    for k in xrange(1, e+1):\n \n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n \n        for x in results:\n \n            p0 = ZZ(x[0])\n \n            p = partial_p(p0, kbits, n)\n \n            if p:\n \n                return p\n \n \n \n \n \nif __name__ == '__main__':\n \n    n = 0xd463feb999c9292e25acd7f98d49a13413df2c4e74820136e739281bb394a73f2d1e6b53066932f50a73310360e5a5c622507d8662dadaef860b3266222129fd645eb74a0207af9bd79a9794f4bd21f32841ce9e1700b0b049cfadb760993fcfc7c65eca63904aa197df306cad8720b1b228484629cf967d808c13f6caef94a9\n \n    e = 3\n \n    d = 0x603d033f2ef6c759aec839f132a45215fc8a635b757f3951a731fe60bc6729b3bcf819b57abfcaba3a93e9edef766c0d499cad3f7adb306bcf1645cfb63400e3\n \n \n \n    beta = 0.5\n \n    epsilon = beta^2/7\n \n \n \n    nbits = n.nbits()\n \n    print \"nbits:%d:\"%(nbits)\n \n    #kbits = floor(nbits*(beta^2+epsilon))\n \n    kbits = nbits - d.nbits()-1\n \n    print \"kbits:%d\"%(kbits)\n \n    d0 = d & (2^kbits-1)\n \n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n \n \n \n    p = find_p(d0, kbits, e, n)\n \n    print \"found p: %d\" % p\n \n    q = n//p\n \n    print d\n \nprint inverse_mod(e, (p-1)*(q-1))\n```\n## 已知明文m的高位\n\n* 已知明文的高位，是Stereotyped messages攻击 或 Lattice based attacks \n```\nn = 0x2519834a6cc3bf25d078caefc5358e41c726a7a56270e425e21515d1b195b248b82f4189a0b621694586bb254e27010ee4376a849bb373e5e3f2eb622e3e7804d18ddb897463f3516b431e7fc65ec41c42edf736d5940c3139d1e374aed1fc3b70737125e1f540b541a9c671f4bf0ded798d727211116eb8b86cdd6a29aefcc7\n\ne = 3\nm = randrange(n)\nc = pow(m, e, n)\n\nbeta = 1\n \nepsilon = beta^2/7\n \nnbits = n.nbits()\n \nkbits = floor(nbits*(beta^2/e-epsilon))\n \n#mbar = m & (2^nbits-2^kbits)\n \nmbar = 0xb11ffc4ce423c77035280f1c575696327901daac8a83c057c453973ee5f4e508455648886441c0f3393fe4c922ef1c3a6249c12d21a000000000000000000\n \nc = 0x1f6f6a8e61f7b5ad8bef738f4376a96724192d8da1e3689dec7ce5d1df615e0910803317f9bafb6671ffe722e0292ce76cca399f2af1952dd31a61b37019da9cf27f82c3ecd4befc03c557efe1a5a29f9bb73c0239f62ed951955718ac0eaa3f60a4c415ef064ea33bbd61abe127c6fc808c0edb034c52c45bd20a219317fb75\n \nprint \"upper %d bits (of %d bits) is given\" % (nbits-kbits, nbits)\n \nPR.<x> = PolynomialRing(Zmod(n))\n \nf = (mbar + x)^e - c\n\nprint m\nx0 = f.small_roots(X=2^kbits, beta=1)[0]  # find root < 2^kbits with factor = n1\nprint mbar + x0\n```","slug":"rsa已知高位攻击1","published":1,"updated":"2020-05-27T06:38:58.062Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18k0024vcu9dnezfpgg","content":"<h1 id=\"已知高位攻击利用\"><a href=\"#已知高位攻击利用\" class=\"headerlink\" title=\"已知高位攻击利用\"></a>已知高位攻击利用</h1><ul>\n<li><p>基础讲解：</p>\n<h1 id=\"1-格的基础\"><a href=\"#1-格的基础\" class=\"headerlink\" title=\"1. 格的基础\"></a>1. 格的基础</h1></li>\n<li><p>格的基础概念：设v1,v2,….,vm线性无关，m维格L（v1,v2,….,vm）是指由向量v1,v2,….,vm生成的一个向量集，它的形式为——L（v1,v2,….,vm）=Σ ai * vi, (i=1,2,….,m ai∈Z)<br>称{v1,v2,….,vm}为格L的一组基，且记Dim(L)=m; m、n分别为格L的维数和秩，当m=n时，称格L是满维的。</p>\n<h1 id=\"2-格基规约\"><a href=\"#2-格基规约\" class=\"headerlink\" title=\"2. 格基规约\"></a>2. 格基规约</h1></li>\n<li><p>同一个格可以使用不同的基来表示，解决格上的问题时，即使使用同一种算法，如果选用不同的基，最后的运行时间和运行结果差别也是十分明显的。选择最优的一组基的过程就是格基规约，并称这样的一组基为格的一组规约基。常见的两种规约方法是Gauss规约和LLL规约。<br><img src=\"https://note.youdao.com/yws/api/personal/file/3E79235F98824E54871C18C516CCC71D?method=download&shareKey=719882fdcdade620567084447f055b72\" alt=\"\"></p>\n</li>\n<li><p>其实综上所述，已知高位攻击就是将问题转换到格的数学问题中，转向求格的最短非零向量</p>\n</li>\n<li><p>格基规约算法应用于密码分析的另一个重要方面就是线性同余结尾序列的重构。</p>\n</li>\n</ul>\n<h1 id=\"重点（伪随机序列的还原重构）\"><a href=\"#重点（伪随机序列的还原重构）\" class=\"headerlink\" title=\"重点（伪随机序列的还原重构）\"></a>重点（伪随机序列的还原重构）</h1><h2 id=\"LLL-算法在密码分析中的应用-攻克线性同余结尾序列\"><a href=\"#LLL-算法在密码分析中的应用-攻克线性同余结尾序列\" class=\"headerlink\" title=\"LLL-算法在密码分析中的应用(攻克线性同余结尾序列)\"></a>LLL-算法在密码分析中的应用(攻克线性同余结尾序列)</h2><ul>\n<li>众所周知, 线性同余是产生伪随机序列的一个极其简便流行的手段.但是, 若将原序列原样输出,而不做</li>\n<li>处理的话 ,即使是在不知道模数与乘子的情况下, 序列也能被轻易地重构(即还原出模数与乘子).于是, 为了增强抗攻击力,Knuth 提出了截尾序列生成器</li>\n<li>该生成器模型如下 :<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入初值 x 0 ,递归生成序列&#123;x i &#125;:x i+1 &#x3D;ax i +b mod m , a , b , m ∈ Z ,输出序列&#123;y i &#125;:y i &#x3D;[ x i &#x2F;2 βv ]</span><br></pre></td></tr></table></figure></li>\n<li>其中v 为m 的比特数 , β =1 -α而α为输出y i 的比特数占原x i 的比特数之比例.</li>\n<li>由于对{x i }做了截尾处理, 使重构困难了.早期的计算机上曾广泛使用了类似的方法产生伪随机整数序列 .其方法是将 n 比特数平方后, 丢弃头尾各n/2 比特</li>\n</ul>\n<h1 id=\"J-S算法\"><a href=\"#J-S算法\" class=\"headerlink\" title=\"J.S算法\"></a>J.S算法</h1><ul>\n<li><p>功能 　设得到 n +t 长的序列 ,记为 y 1 , y 2 , …, y t , y t+1 , …, y t+n ,其中 n ≈(2 αt log m)1/2,且原序列{xi}中(x 1 -x 0 , m)=1.J.S.算法能求出模数 m 和乘子a , 从而重构了原模型</p>\n</li>\n<li><p>描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 做Vi&#x3D;[y(i+1) - yi ,  y(i+2)-y(i+1)....,y(i+t)-y(i+t)-1],  i&#x3D;1,2,...,n.</span><br><span class=\"line\">&lt;2&gt; 适当选取 k , 考虑 kV 1 , kV 2 , …, kV n 作输入 , 执行 KILL- 算法 , 得到 λ&#x3D;(λ 1 , λ 2 , …, λ n ), 且∑λ i V i &#x3D;0   (i&#x3D;1，2,...,n), λ 较小.</span><br><span class=\"line\">&lt;3&gt; 做多项式 P(x)&#x3D;Σλi * X^i  (i&#x3D;1,2,...,n)</span><br><span class=\"line\">&lt;4&gt; 重复(1)～ (3)多次 ,得到多项式序列 p 1 , p 2 , …, p r .将p i 自然映射到Z^(n+1) 上.应用LLL-算法于p 1 , p 2 ,…, p r 上, 得到生成的格 L 的一组 LLL-约基 ,计算 d(L),令m &#x3D;d(L),输出 m </span><br><span class=\"line\">&lt;5&gt; 将 L 的基中次数 ≥2的向量乘以大整数 K (K ≥m 2^(n&#x2F;2) ),再构成子格 L′, 执行 LLL-算法 ,找到 L′的一组 LLL-约基 .运用线性代数的知识,利用 LLL-约基, 找到首一多项式 A(x).令a &#x3D;A(0), 输出 a .算法结束 .</span><br></pre></td></tr></table></figure></li>\n<li><p>注意：在（4）中多项式个数r≤（6α-1）㏒ m ㏒ ㏒ m,就可以满足要求了，算法中执行的LLL-算法其实是LLL-算法在输入任意r个向量(有可能线性相关)情况时的改进算法</p>\n</li>\n</ul>\n<h1 id=\"coppersmith的一些定理\"><a href=\"#coppersmith的一些定理\" class=\"headerlink\" title=\"coppersmith的一些定理:\"></a>coppersmith的一些定理:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt;定理3.3 对任意的a &gt; 0 ， 给定N &#x3D; PQR及PQ的高位(1&#x2F;5)(logN,2)比特，我们可以在多项式时间logN内得到N的分解式。这是三个因式的分解。也就是说我们现在是由理论依据的，已知高位是可以在一定时间内分解N。</span><br><span class=\"line\">&lt;2&gt;已知p高位u多少位菜可以进行攻击呢？定理是在《Mathematics_of_Public_Key_Cryptography》这本数里面提到的，我们将我们上面得到的N的值带入上图的式子中。计算(1&#x2F;根号2)*N</span><br></pre></td></tr></table></figure>\n<ul>\n<li>由上式得出：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if p.bit_length &#x3D;&#x3D; 1024 ,p的高位需已知约576位</span><br><span class=\"line\"></span><br><span class=\"line\">if p.bit_length &#x3D;&#x3D; 1024 ,p的高位需已知约288位</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>1.sage里面的small_roots能实现上述的给出已知的p高位进行分解N的函数方法，利用了LLL算法求解非线性低维度多项式方程小根的方法。</p>\n</li>\n<li><p>2.Coppersmith证明了在已知p和q部分比特的情况下，若q和p的未知部分的上界X和Y满足XY &lt;= N ^ (0.5)则Ｎ的多项式可以被分解。<br>这里的0.5可以替换成其他的数，具体原因不详。</p>\n</li>\n<li><p>链接：<br><a href=\"https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots\" target=\"_blank\" rel=\"noopener\">sage里small_roots的具体用法</a></p>\n</li>\n</ul>\n<h1 id=\"已知高位攻击分为三种情况\"><a href=\"#已知高位攻击分为三种情况\" class=\"headerlink\" title=\"已知高位攻击分为三种情况\"></a>已知高位攻击分为三种情况</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt;已知P的高位</span><br><span class=\"line\">&lt;2&gt;已知d的高位</span><br><span class=\"line\">&lt;3&gt;已知m的高位</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知P的高位\"><a href=\"#已知P的高位\" class=\"headerlink\" title=\"已知P的高位\"></a>已知P的高位</h2><ul>\n<li><p>知道p的高位为p的位数的约1/2时即可</p>\n</li>\n<li><p>已知e,n爆破 1024的P，至少需要知道前576位二进制，即前144位16进制(特殊情况下，可能所得到的已知位数稍小于144位，需要爆破两三位，然后使用sage脚本)</p>\n</li>\n<li><p>正好已知144位16进制的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;</span><br><span class=\"line\">p4&#x3D;            #已知P的高位</span><br><span class=\"line\">e&#x3D;</span><br><span class=\"line\">pbits&#x3D;          #P原本的位数</span><br><span class=\"line\"></span><br><span class=\"line\">kbits&#x3D;pbits - p4.nbits()</span><br><span class=\"line\">print p4.nbits()</span><br><span class=\"line\">p4 &#x3D; p4 &lt;&lt; kbits</span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\">f &#x3D; x + p4</span><br><span class=\"line\">roots &#x3D; f.small_roots(X&#x3D;2^kbits,beta&#x3D;0.4)</span><br><span class=\"line\"># 经过以上一些函数处理后，n和p已经被转化为10进制</span><br><span class=\"line\">if roots:</span><br><span class=\"line\">    p&#x3D; p4 + int(roots([0]))</span><br><span class=\"line\">    print &quot;n&quot;,n</span><br><span class=\"line\">    print &quot;p&quot;,p</span><br><span class=\"line\">    print &quot;q&quot;,n&#x2F;p</span><br></pre></td></tr></table></figure></li>\n<li><p>已知142位16进制的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;</span><br><span class=\"line\">p4&#x3D;            #已知P的高位,最后面8位二进制，也就是两位十六进制要参与爆破，所以要用00补充</span><br><span class=\"line\">e&#x3D;</span><br><span class=\"line\">pbits&#x3D;          #P原本的位数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(0,256):        # 要爆破的8位二进制数，为2**8&#x3D;&#x3D;256，表示0~255</span><br><span class=\"line\">    p4 &#x3D;</span><br><span class=\"line\">    p4 &#x3D; p4 + int(hex(i),16)</span><br><span class=\"line\">#print hex(p4)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">kbits&#x3D;pbits - p4.nbits()</span><br><span class=\"line\">print p4.nbits()</span><br><span class=\"line\">p4 &#x3D; p4 &lt;&lt; kbits</span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\">f &#x3D; x + p4</span><br><span class=\"line\">roots &#x3D; f.small_roots(X&#x3D;2^kbits,beta&#x3D;0.4)</span><br><span class=\"line\"># 经过以上一些函数处理后，n和p已经被转化为10进制</span><br><span class=\"line\">if roots:</span><br><span class=\"line\">    p&#x3D; p4 + int(roots([0]))</span><br><span class=\"line\">    print &quot;n&quot;,n</span><br><span class=\"line\">    print &quot;p&quot;,p</span><br><span class=\"line\">    print &quot;q&quot;,n&#x2F;p</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知d的高位\"><a href=\"#已知d的高位\" class=\"headerlink\" title=\"已知d的高位\"></a>已知d的高位</h2></li>\n<li><p>如果知道d的低位，低位约为n的位数的1/4就可以恢复d。已知私钥的512位的低位 Partial Key Exposure Attack(部分私钥暴露攻击)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def partial_p(p0, kbits, n):</span><br><span class=\"line\"> </span><br><span class=\"line\">    PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\"> </span><br><span class=\"line\">    nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    f &#x3D; 2^kbits*x + p0</span><br><span class=\"line\"> </span><br><span class=\"line\">    f &#x3D; f.monic()</span><br><span class=\"line\"> </span><br><span class=\"line\">    roots &#x3D; f.small_roots(X&#x3D;2^(nbits&#x2F;&#x2F;2-kbits), beta&#x3D;0.3)  # find root &lt; 2^(nbits&#x2F;&#x2F;2-kbits) with factor &gt;&#x3D; n^0.3</span><br><span class=\"line\"> </span><br><span class=\"line\">    if roots:</span><br><span class=\"line\"> </span><br><span class=\"line\">        x0 &#x3D; roots[0]</span><br><span class=\"line\"> </span><br><span class=\"line\">        p &#x3D; gcd(2^kbits*x0 + p0, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">        return ZZ(p)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">def find_p(d0, kbits, e, n):</span><br><span class=\"line\"> </span><br><span class=\"line\">    X &#x3D; var(&#39;X&#39;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    for k in xrange(1, e+1):</span><br><span class=\"line\"> </span><br><span class=\"line\">        results &#x3D; solve_mod([e*d0*X - k*X*(n-X+1) + k*n &#x3D;&#x3D; X], 2^kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">        for x in results:</span><br><span class=\"line\"> </span><br><span class=\"line\">            p0 &#x3D; ZZ(x[0])</span><br><span class=\"line\"> </span><br><span class=\"line\">            p &#x3D; partial_p(p0, kbits, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">            if p:</span><br><span class=\"line\"> </span><br><span class=\"line\">                return p</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\"> </span><br><span class=\"line\">    n &#x3D; 0xd463feb999c9292e25acd7f98d49a13413df2c4e74820136e739281bb394a73f2d1e6b53066932f50a73310360e5a5c622507d8662dadaef860b3266222129fd645eb74a0207af9bd79a9794f4bd21f32841ce9e1700b0b049cfadb760993fcfc7c65eca63904aa197df306cad8720b1b228484629cf967d808c13f6caef94a9</span><br><span class=\"line\"> </span><br><span class=\"line\">    e &#x3D; 3</span><br><span class=\"line\"> </span><br><span class=\"line\">    d &#x3D; 0x603d033f2ef6c759aec839f132a45215fc8a635b757f3951a731fe60bc6729b3bcf819b57abfcaba3a93e9edef766c0d499cad3f7adb306bcf1645cfb63400e3</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    beta &#x3D; 0.5</span><br><span class=\"line\"> </span><br><span class=\"line\">    epsilon &#x3D; beta^2&#x2F;7</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;nbits:%d:&quot;%(nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">    #kbits &#x3D; floor(nbits*(beta^2+epsilon))</span><br><span class=\"line\"> </span><br><span class=\"line\">    kbits &#x3D; nbits - d.nbits()-1</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;kbits:%d&quot;%(kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">    d0 &#x3D; d &amp; (2^kbits-1)</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;lower %d bits (of %d bits) is given&quot; % (kbits, nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    p &#x3D; find_p(d0, kbits, e, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;found p: %d&quot; % p</span><br><span class=\"line\"> </span><br><span class=\"line\">    q &#x3D; n&#x2F;&#x2F;p</span><br><span class=\"line\"> </span><br><span class=\"line\">    print d</span><br><span class=\"line\"> </span><br><span class=\"line\">print inverse_mod(e, (p-1)*(q-1))</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知明文m的高位\"><a href=\"#已知明文m的高位\" class=\"headerlink\" title=\"已知明文m的高位\"></a>已知明文m的高位</h2></li>\n<li><p>已知明文的高位，是Stereotyped messages攻击 或 Lattice based attacks </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n &#x3D; 0x2519834a6cc3bf25d078caefc5358e41c726a7a56270e425e21515d1b195b248b82f4189a0b621694586bb254e27010ee4376a849bb373e5e3f2eb622e3e7804d18ddb897463f3516b431e7fc65ec41c42edf736d5940c3139d1e374aed1fc3b70737125e1f540b541a9c671f4bf0ded798d727211116eb8b86cdd6a29aefcc7</span><br><span class=\"line\"></span><br><span class=\"line\">e &#x3D; 3</span><br><span class=\"line\">m &#x3D; randrange(n)</span><br><span class=\"line\">c &#x3D; pow(m, e, n)</span><br><span class=\"line\"></span><br><span class=\"line\">beta &#x3D; 1</span><br><span class=\"line\"> </span><br><span class=\"line\">epsilon &#x3D; beta^2&#x2F;7</span><br><span class=\"line\"> </span><br><span class=\"line\">nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\">kbits &#x3D; floor(nbits*(beta^2&#x2F;e-epsilon))</span><br><span class=\"line\"> </span><br><span class=\"line\">#mbar &#x3D; m &amp; (2^nbits-2^kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">mbar &#x3D; 0xb11ffc4ce423c77035280f1c575696327901daac8a83c057c453973ee5f4e508455648886441c0f3393fe4c922ef1c3a6249c12d21a000000000000000000</span><br><span class=\"line\"> </span><br><span class=\"line\">c &#x3D; 0x1f6f6a8e61f7b5ad8bef738f4376a96724192d8da1e3689dec7ce5d1df615e0910803317f9bafb6671ffe722e0292ce76cca399f2af1952dd31a61b37019da9cf27f82c3ecd4befc03c557efe1a5a29f9bb73c0239f62ed951955718ac0eaa3f60a4c415ef064ea33bbd61abe127c6fc808c0edb034c52c45bd20a219317fb75</span><br><span class=\"line\"> </span><br><span class=\"line\">print &quot;upper %d bits (of %d bits) is given&quot; % (nbits-kbits, nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\"> </span><br><span class=\"line\">f &#x3D; (mbar + x)^e - c</span><br><span class=\"line\"></span><br><span class=\"line\">print m</span><br><span class=\"line\">x0 &#x3D; f.small_roots(X&#x3D;2^kbits, beta&#x3D;1)[0]  # find root &lt; 2^kbits with factor &#x3D; n1</span><br><span class=\"line\">print mbar + x0</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"已知高位攻击利用\"><a href=\"#已知高位攻击利用\" class=\"headerlink\" title=\"已知高位攻击利用\"></a>已知高位攻击利用</h1><ul>\n<li><p>基础讲解：</p>\n<h1 id=\"1-格的基础\"><a href=\"#1-格的基础\" class=\"headerlink\" title=\"1. 格的基础\"></a>1. 格的基础</h1></li>\n<li><p>格的基础概念：设v1,v2,….,vm线性无关，m维格L（v1,v2,….,vm）是指由向量v1,v2,….,vm生成的一个向量集，它的形式为——L（v1,v2,….,vm）=Σ ai * vi, (i=1,2,….,m ai∈Z)<br>称{v1,v2,….,vm}为格L的一组基，且记Dim(L)=m; m、n分别为格L的维数和秩，当m=n时，称格L是满维的。</p>\n<h1 id=\"2-格基规约\"><a href=\"#2-格基规约\" class=\"headerlink\" title=\"2. 格基规约\"></a>2. 格基规约</h1></li>\n<li><p>同一个格可以使用不同的基来表示，解决格上的问题时，即使使用同一种算法，如果选用不同的基，最后的运行时间和运行结果差别也是十分明显的。选择最优的一组基的过程就是格基规约，并称这样的一组基为格的一组规约基。常见的两种规约方法是Gauss规约和LLL规约。<br><img src=\"https://note.youdao.com/yws/api/personal/file/3E79235F98824E54871C18C516CCC71D?method=download&shareKey=719882fdcdade620567084447f055b72\" alt=\"\"></p>\n</li>\n<li><p>其实综上所述，已知高位攻击就是将问题转换到格的数学问题中，转向求格的最短非零向量</p>\n</li>\n<li><p>格基规约算法应用于密码分析的另一个重要方面就是线性同余结尾序列的重构。</p>\n</li>\n</ul>\n<h1 id=\"重点（伪随机序列的还原重构）\"><a href=\"#重点（伪随机序列的还原重构）\" class=\"headerlink\" title=\"重点（伪随机序列的还原重构）\"></a>重点（伪随机序列的还原重构）</h1><h2 id=\"LLL-算法在密码分析中的应用-攻克线性同余结尾序列\"><a href=\"#LLL-算法在密码分析中的应用-攻克线性同余结尾序列\" class=\"headerlink\" title=\"LLL-算法在密码分析中的应用(攻克线性同余结尾序列)\"></a>LLL-算法在密码分析中的应用(攻克线性同余结尾序列)</h2><ul>\n<li>众所周知, 线性同余是产生伪随机序列的一个极其简便流行的手段.但是, 若将原序列原样输出,而不做</li>\n<li>处理的话 ,即使是在不知道模数与乘子的情况下, 序列也能被轻易地重构(即还原出模数与乘子).于是, 为了增强抗攻击力,Knuth 提出了截尾序列生成器</li>\n<li>该生成器模型如下 :<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入初值 x 0 ,递归生成序列&#123;x i &#125;:x i+1 &#x3D;ax i +b mod m , a , b , m ∈ Z ,输出序列&#123;y i &#125;:y i &#x3D;[ x i &#x2F;2 βv ]</span><br></pre></td></tr></table></figure></li>\n<li>其中v 为m 的比特数 , β =1 -α而α为输出y i 的比特数占原x i 的比特数之比例.</li>\n<li>由于对{x i }做了截尾处理, 使重构困难了.早期的计算机上曾广泛使用了类似的方法产生伪随机整数序列 .其方法是将 n 比特数平方后, 丢弃头尾各n/2 比特</li>\n</ul>\n<h1 id=\"J-S算法\"><a href=\"#J-S算法\" class=\"headerlink\" title=\"J.S算法\"></a>J.S算法</h1><ul>\n<li><p>功能 　设得到 n +t 长的序列 ,记为 y 1 , y 2 , …, y t , y t+1 , …, y t+n ,其中 n ≈(2 αt log m)1/2,且原序列{xi}中(x 1 -x 0 , m)=1.J.S.算法能求出模数 m 和乘子a , 从而重构了原模型</p>\n</li>\n<li><p>描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 做Vi&#x3D;[y(i+1) - yi ,  y(i+2)-y(i+1)....,y(i+t)-y(i+t)-1],  i&#x3D;1,2,...,n.</span><br><span class=\"line\">&lt;2&gt; 适当选取 k , 考虑 kV 1 , kV 2 , …, kV n 作输入 , 执行 KILL- 算法 , 得到 λ&#x3D;(λ 1 , λ 2 , …, λ n ), 且∑λ i V i &#x3D;0   (i&#x3D;1，2,...,n), λ 较小.</span><br><span class=\"line\">&lt;3&gt; 做多项式 P(x)&#x3D;Σλi * X^i  (i&#x3D;1,2,...,n)</span><br><span class=\"line\">&lt;4&gt; 重复(1)～ (3)多次 ,得到多项式序列 p 1 , p 2 , …, p r .将p i 自然映射到Z^(n+1) 上.应用LLL-算法于p 1 , p 2 ,…, p r 上, 得到生成的格 L 的一组 LLL-约基 ,计算 d(L),令m &#x3D;d(L),输出 m </span><br><span class=\"line\">&lt;5&gt; 将 L 的基中次数 ≥2的向量乘以大整数 K (K ≥m 2^(n&#x2F;2) ),再构成子格 L′, 执行 LLL-算法 ,找到 L′的一组 LLL-约基 .运用线性代数的知识,利用 LLL-约基, 找到首一多项式 A(x).令a &#x3D;A(0), 输出 a .算法结束 .</span><br></pre></td></tr></table></figure></li>\n<li><p>注意：在（4）中多项式个数r≤（6α-1）㏒ m ㏒ ㏒ m,就可以满足要求了，算法中执行的LLL-算法其实是LLL-算法在输入任意r个向量(有可能线性相关)情况时的改进算法</p>\n</li>\n</ul>\n<h1 id=\"coppersmith的一些定理\"><a href=\"#coppersmith的一些定理\" class=\"headerlink\" title=\"coppersmith的一些定理:\"></a>coppersmith的一些定理:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt;定理3.3 对任意的a &gt; 0 ， 给定N &#x3D; PQR及PQ的高位(1&#x2F;5)(logN,2)比特，我们可以在多项式时间logN内得到N的分解式。这是三个因式的分解。也就是说我们现在是由理论依据的，已知高位是可以在一定时间内分解N。</span><br><span class=\"line\">&lt;2&gt;已知p高位u多少位菜可以进行攻击呢？定理是在《Mathematics_of_Public_Key_Cryptography》这本数里面提到的，我们将我们上面得到的N的值带入上图的式子中。计算(1&#x2F;根号2)*N</span><br></pre></td></tr></table></figure>\n<ul>\n<li>由上式得出：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if p.bit_length &#x3D;&#x3D; 1024 ,p的高位需已知约576位</span><br><span class=\"line\"></span><br><span class=\"line\">if p.bit_length &#x3D;&#x3D; 1024 ,p的高位需已知约288位</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>1.sage里面的small_roots能实现上述的给出已知的p高位进行分解N的函数方法，利用了LLL算法求解非线性低维度多项式方程小根的方法。</p>\n</li>\n<li><p>2.Coppersmith证明了在已知p和q部分比特的情况下，若q和p的未知部分的上界X和Y满足XY &lt;= N ^ (0.5)则Ｎ的多项式可以被分解。<br>这里的0.5可以替换成其他的数，具体原因不详。</p>\n</li>\n<li><p>链接：<br><a href=\"https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots\" target=\"_blank\" rel=\"noopener\">sage里small_roots的具体用法</a></p>\n</li>\n</ul>\n<h1 id=\"已知高位攻击分为三种情况\"><a href=\"#已知高位攻击分为三种情况\" class=\"headerlink\" title=\"已知高位攻击分为三种情况\"></a>已知高位攻击分为三种情况</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt;已知P的高位</span><br><span class=\"line\">&lt;2&gt;已知d的高位</span><br><span class=\"line\">&lt;3&gt;已知m的高位</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知P的高位\"><a href=\"#已知P的高位\" class=\"headerlink\" title=\"已知P的高位\"></a>已知P的高位</h2><ul>\n<li><p>知道p的高位为p的位数的约1/2时即可</p>\n</li>\n<li><p>已知e,n爆破 1024的P，至少需要知道前576位二进制，即前144位16进制(特殊情况下，可能所得到的已知位数稍小于144位，需要爆破两三位，然后使用sage脚本)</p>\n</li>\n<li><p>正好已知144位16进制的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;</span><br><span class=\"line\">p4&#x3D;            #已知P的高位</span><br><span class=\"line\">e&#x3D;</span><br><span class=\"line\">pbits&#x3D;          #P原本的位数</span><br><span class=\"line\"></span><br><span class=\"line\">kbits&#x3D;pbits - p4.nbits()</span><br><span class=\"line\">print p4.nbits()</span><br><span class=\"line\">p4 &#x3D; p4 &lt;&lt; kbits</span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\">f &#x3D; x + p4</span><br><span class=\"line\">roots &#x3D; f.small_roots(X&#x3D;2^kbits,beta&#x3D;0.4)</span><br><span class=\"line\"># 经过以上一些函数处理后，n和p已经被转化为10进制</span><br><span class=\"line\">if roots:</span><br><span class=\"line\">    p&#x3D; p4 + int(roots([0]))</span><br><span class=\"line\">    print &quot;n&quot;,n</span><br><span class=\"line\">    print &quot;p&quot;,p</span><br><span class=\"line\">    print &quot;q&quot;,n&#x2F;p</span><br></pre></td></tr></table></figure></li>\n<li><p>已知142位16进制的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;</span><br><span class=\"line\">p4&#x3D;            #已知P的高位,最后面8位二进制，也就是两位十六进制要参与爆破，所以要用00补充</span><br><span class=\"line\">e&#x3D;</span><br><span class=\"line\">pbits&#x3D;          #P原本的位数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(0,256):        # 要爆破的8位二进制数，为2**8&#x3D;&#x3D;256，表示0~255</span><br><span class=\"line\">    p4 &#x3D;</span><br><span class=\"line\">    p4 &#x3D; p4 + int(hex(i),16)</span><br><span class=\"line\">#print hex(p4)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">kbits&#x3D;pbits - p4.nbits()</span><br><span class=\"line\">print p4.nbits()</span><br><span class=\"line\">p4 &#x3D; p4 &lt;&lt; kbits</span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\">f &#x3D; x + p4</span><br><span class=\"line\">roots &#x3D; f.small_roots(X&#x3D;2^kbits,beta&#x3D;0.4)</span><br><span class=\"line\"># 经过以上一些函数处理后，n和p已经被转化为10进制</span><br><span class=\"line\">if roots:</span><br><span class=\"line\">    p&#x3D; p4 + int(roots([0]))</span><br><span class=\"line\">    print &quot;n&quot;,n</span><br><span class=\"line\">    print &quot;p&quot;,p</span><br><span class=\"line\">    print &quot;q&quot;,n&#x2F;p</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知d的高位\"><a href=\"#已知d的高位\" class=\"headerlink\" title=\"已知d的高位\"></a>已知d的高位</h2></li>\n<li><p>如果知道d的低位，低位约为n的位数的1/4就可以恢复d。已知私钥的512位的低位 Partial Key Exposure Attack(部分私钥暴露攻击)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def partial_p(p0, kbits, n):</span><br><span class=\"line\"> </span><br><span class=\"line\">    PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\"> </span><br><span class=\"line\">    nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    f &#x3D; 2^kbits*x + p0</span><br><span class=\"line\"> </span><br><span class=\"line\">    f &#x3D; f.monic()</span><br><span class=\"line\"> </span><br><span class=\"line\">    roots &#x3D; f.small_roots(X&#x3D;2^(nbits&#x2F;&#x2F;2-kbits), beta&#x3D;0.3)  # find root &lt; 2^(nbits&#x2F;&#x2F;2-kbits) with factor &gt;&#x3D; n^0.3</span><br><span class=\"line\"> </span><br><span class=\"line\">    if roots:</span><br><span class=\"line\"> </span><br><span class=\"line\">        x0 &#x3D; roots[0]</span><br><span class=\"line\"> </span><br><span class=\"line\">        p &#x3D; gcd(2^kbits*x0 + p0, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">        return ZZ(p)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">def find_p(d0, kbits, e, n):</span><br><span class=\"line\"> </span><br><span class=\"line\">    X &#x3D; var(&#39;X&#39;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    for k in xrange(1, e+1):</span><br><span class=\"line\"> </span><br><span class=\"line\">        results &#x3D; solve_mod([e*d0*X - k*X*(n-X+1) + k*n &#x3D;&#x3D; X], 2^kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">        for x in results:</span><br><span class=\"line\"> </span><br><span class=\"line\">            p0 &#x3D; ZZ(x[0])</span><br><span class=\"line\"> </span><br><span class=\"line\">            p &#x3D; partial_p(p0, kbits, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">            if p:</span><br><span class=\"line\"> </span><br><span class=\"line\">                return p</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\"> </span><br><span class=\"line\">    n &#x3D; 0xd463feb999c9292e25acd7f98d49a13413df2c4e74820136e739281bb394a73f2d1e6b53066932f50a73310360e5a5c622507d8662dadaef860b3266222129fd645eb74a0207af9bd79a9794f4bd21f32841ce9e1700b0b049cfadb760993fcfc7c65eca63904aa197df306cad8720b1b228484629cf967d808c13f6caef94a9</span><br><span class=\"line\"> </span><br><span class=\"line\">    e &#x3D; 3</span><br><span class=\"line\"> </span><br><span class=\"line\">    d &#x3D; 0x603d033f2ef6c759aec839f132a45215fc8a635b757f3951a731fe60bc6729b3bcf819b57abfcaba3a93e9edef766c0d499cad3f7adb306bcf1645cfb63400e3</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    beta &#x3D; 0.5</span><br><span class=\"line\"> </span><br><span class=\"line\">    epsilon &#x3D; beta^2&#x2F;7</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;nbits:%d:&quot;%(nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">    #kbits &#x3D; floor(nbits*(beta^2+epsilon))</span><br><span class=\"line\"> </span><br><span class=\"line\">    kbits &#x3D; nbits - d.nbits()-1</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;kbits:%d&quot;%(kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">    d0 &#x3D; d &amp; (2^kbits-1)</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;lower %d bits (of %d bits) is given&quot; % (kbits, nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    p &#x3D; find_p(d0, kbits, e, n)</span><br><span class=\"line\"> </span><br><span class=\"line\">    print &quot;found p: %d&quot; % p</span><br><span class=\"line\"> </span><br><span class=\"line\">    q &#x3D; n&#x2F;&#x2F;p</span><br><span class=\"line\"> </span><br><span class=\"line\">    print d</span><br><span class=\"line\"> </span><br><span class=\"line\">print inverse_mod(e, (p-1)*(q-1))</span><br></pre></td></tr></table></figure>\n<h2 id=\"已知明文m的高位\"><a href=\"#已知明文m的高位\" class=\"headerlink\" title=\"已知明文m的高位\"></a>已知明文m的高位</h2></li>\n<li><p>已知明文的高位，是Stereotyped messages攻击 或 Lattice based attacks </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n &#x3D; 0x2519834a6cc3bf25d078caefc5358e41c726a7a56270e425e21515d1b195b248b82f4189a0b621694586bb254e27010ee4376a849bb373e5e3f2eb622e3e7804d18ddb897463f3516b431e7fc65ec41c42edf736d5940c3139d1e374aed1fc3b70737125e1f540b541a9c671f4bf0ded798d727211116eb8b86cdd6a29aefcc7</span><br><span class=\"line\"></span><br><span class=\"line\">e &#x3D; 3</span><br><span class=\"line\">m &#x3D; randrange(n)</span><br><span class=\"line\">c &#x3D; pow(m, e, n)</span><br><span class=\"line\"></span><br><span class=\"line\">beta &#x3D; 1</span><br><span class=\"line\"> </span><br><span class=\"line\">epsilon &#x3D; beta^2&#x2F;7</span><br><span class=\"line\"> </span><br><span class=\"line\">nbits &#x3D; n.nbits()</span><br><span class=\"line\"> </span><br><span class=\"line\">kbits &#x3D; floor(nbits*(beta^2&#x2F;e-epsilon))</span><br><span class=\"line\"> </span><br><span class=\"line\">#mbar &#x3D; m &amp; (2^nbits-2^kbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">mbar &#x3D; 0xb11ffc4ce423c77035280f1c575696327901daac8a83c057c453973ee5f4e508455648886441c0f3393fe4c922ef1c3a6249c12d21a000000000000000000</span><br><span class=\"line\"> </span><br><span class=\"line\">c &#x3D; 0x1f6f6a8e61f7b5ad8bef738f4376a96724192d8da1e3689dec7ce5d1df615e0910803317f9bafb6671ffe722e0292ce76cca399f2af1952dd31a61b37019da9cf27f82c3ecd4befc03c557efe1a5a29f9bb73c0239f62ed951955718ac0eaa3f60a4c415ef064ea33bbd61abe127c6fc808c0edb034c52c45bd20a219317fb75</span><br><span class=\"line\"> </span><br><span class=\"line\">print &quot;upper %d bits (of %d bits) is given&quot; % (nbits-kbits, nbits)</span><br><span class=\"line\"> </span><br><span class=\"line\">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class=\"line\"> </span><br><span class=\"line\">f &#x3D; (mbar + x)^e - c</span><br><span class=\"line\"></span><br><span class=\"line\">print m</span><br><span class=\"line\">x0 &#x3D; f.small_roots(X&#x3D;2^kbits, beta&#x3D;1)[0]  # find root &lt; 2^kbits with factor &#x3D; n1</span><br><span class=\"line\">print mbar + x0</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"分组加密的padding","author":"人生若只如初见","date":"2020-09-24T11:55:00.000Z","_content":"# 基本规则\n* 在分组加密中，明文长度不满足要求时，经常进行padding，即使恰好为块长度的整数倍，依旧需要padding（填充）。\n\n# 各种填充规则\n## pkcs5\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 05 05 05 05 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40\n```\n\n* pkCS5是8字节填充的，即填充一定数量的内容，使得成为8的整数倍，而填充的内容取决于需要填充的数目。例如，串0x56在经过PKCS5填充之后会成为0x56 0x07 0x07 0x07 0x07 0x07 0x07 0x07因为需要填充7字节，因此填充的内容就是7。当然特殊情况下，如果已经满足了8的整倍数，按照PKCS5的规则，仍然需要在尾部填充8个字节，并且内容是0x08,目的是为了加解密时统一处理填充。\n* pkcs5总结来说就是在需要填充的位置，8字节缺少多少就填充多少，例如上面缺少5字节，所以填充0x05。\n\n## pkcs7\n\n\n\n\n## OneAndZeroes Padding\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 80 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40\n```\n\n* 这里其实就是和 md5 和 sha1 的 padding 差不多。\n\n\n## Pad with zeroes except make the last byte equal to the number of padding bytes\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8\n```\n\n* 按照上面的例子，依旧缺失5字节，中间全部填充0x00，在最后一字节填充填充了多少，上面一共需要填充5字节，所以结尾为0x05。\n\n## Pad with zero (null) characters（零填充）\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75\n```\n\n* 在所有需要填充的地方填充0x00，直到满足填充原则。\n\n## Pad with spaces（空格填充）\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 20 20 20 20 20\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25\n```\n\n* 所有需要填充的地方都使用空格填充。\n\n","source":"_posts/分组加密的padding.md","raw":"title: 分组加密的padding\nauthor: 人生若只如初见\ntags:\n  - ''\ncategories:\n  - 密码学\n  - 填充方式\ndate: 2020-09-24 19:55:00\n---\n# 基本规则\n* 在分组加密中，明文长度不满足要求时，经常进行padding，即使恰好为块长度的整数倍，依旧需要padding（填充）。\n\n# 各种填充规则\n## pkcs5\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 05 05 05 05 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40\n```\n\n* pkCS5是8字节填充的，即填充一定数量的内容，使得成为8的整数倍，而填充的内容取决于需要填充的数目。例如，串0x56在经过PKCS5填充之后会成为0x56 0x07 0x07 0x07 0x07 0x07 0x07 0x07因为需要填充7字节，因此填充的内容就是7。当然特殊情况下，如果已经满足了8的整倍数，按照PKCS5的规则，仍然需要在尾部填充8个字节，并且内容是0x08,目的是为了加解密时统一处理填充。\n* pkcs5总结来说就是在需要填充的位置，8字节缺少多少就填充多少，例如上面缺少5字节，所以填充0x05。\n\n## pkcs7\n\n\n\n\n## OneAndZeroes Padding\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 80 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40\n```\n\n* 这里其实就是和 md5 和 sha1 的 padding 差不多。\n\n\n## Pad with zeroes except make the last byte equal to the number of padding bytes\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8\n```\n\n* 按照上面的例子，依旧缺失5字节，中间全部填充0x00，在最后一字节填充填充了多少，上面一共需要填充5字节，所以结尾为0x05。\n\n## Pad with zero (null) characters（零填充）\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75\n```\n\n* 在所有需要填充的地方填充0x00，直到满足填充原则。\n\n## Pad with spaces（空格填充）\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 20 20 20 20 20\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25\n```\n\n* 所有需要填充的地方都使用空格填充。\n\n","slug":"分组加密的padding","published":1,"updated":"2020-09-25T11:34:45.560Z","_id":"ckfi5r18l0026vcu96gnsbxi6","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"基本规则\"><a href=\"#基本规则\" class=\"headerlink\" title=\"基本规则\"></a>基本规则</h1><ul>\n<li>在分组加密中，明文长度不满足要求时，经常进行padding，即使恰好为块长度的整数倍，依旧需要padding（填充）。</li>\n</ul>\n<h1 id=\"各种填充规则\"><a href=\"#各种填充规则\" class=\"headerlink\" title=\"各种填充规则\"></a>各种填充规则</h1><h2 id=\"pkcs5\"><a href=\"#pkcs5\" class=\"headerlink\" title=\"pkcs5\"></a>pkcs5</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6F 72 05 05 05 05 05</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; FD 29 85 C9 E8 DF 41 40</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>pkCS5是8字节填充的，即填充一定数量的内容，使得成为8的整数倍，而填充的内容取决于需要填充的数目。例如，串0x56在经过PKCS5填充之后会成为0x56 0x07 0x07 0x07 0x07 0x07 0x07 0x07因为需要填充7字节，因此填充的内容就是7。当然特殊情况下，如果已经满足了8的整倍数，按照PKCS5的规则，仍然需要在尾部填充8个字节，并且内容是0x08,目的是为了加解密时统一处理填充。</li>\n<li>pkcs5总结来说就是在需要填充的位置，8字节缺少多少就填充多少，例如上面缺少5字节，所以填充0x05。</li>\n</ul>\n<h2 id=\"pkcs7\"><a href=\"#pkcs7\" class=\"headerlink\" title=\"pkcs7\"></a>pkcs7</h2><h2 id=\"OneAndZeroes-Padding\"><a href=\"#OneAndZeroes-Padding\" class=\"headerlink\" title=\"OneAndZeroes Padding\"></a>OneAndZeroes Padding</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6F 72 80 00 00 00 00</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; BE 62 5D 9F F3 C6 C8 40</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这里其实就是和 md5 和 sha1 的 padding 差不多。</li>\n</ul>\n<h2 id=\"Pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes\"><a href=\"#Pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes\" class=\"headerlink\" title=\"Pad with zeroes except make the last byte equal to the number of padding bytes\"></a>Pad with zeroes except make the last byte equal to the number of padding bytes</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 00 00 00 00 05</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; 91 19 2C 64 B5 5C 5D B8</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按照上面的例子，依旧缺失5字节，中间全部填充0x00，在最后一字节填充填充了多少，上面一共需要填充5字节，所以结尾为0x05。</li>\n</ul>\n<h2 id=\"Pad-with-zero-null-characters（零填充）\"><a href=\"#Pad-with-zero-null-characters（零填充）\" class=\"headerlink\" title=\"Pad with zero (null) characters（零填充）\"></a>Pad with zero (null) characters（零填充）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 00 00 00 00 00</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; 9E 14 FB 96 C5 FE EB 75</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在所有需要填充的地方填充0x00，直到满足填充原则。</li>\n</ul>\n<h2 id=\"Pad-with-spaces（空格填充）\"><a href=\"#Pad-with-spaces（空格填充）\" class=\"headerlink\" title=\"Pad with spaces（空格填充）\"></a>Pad with spaces（空格填充）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 20 20 20 20 20</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; E3 FF EC E5 21 1F 35 25</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所有需要填充的地方都使用空格填充。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本规则\"><a href=\"#基本规则\" class=\"headerlink\" title=\"基本规则\"></a>基本规则</h1><ul>\n<li>在分组加密中，明文长度不满足要求时，经常进行padding，即使恰好为块长度的整数倍，依旧需要padding（填充）。</li>\n</ul>\n<h1 id=\"各种填充规则\"><a href=\"#各种填充规则\" class=\"headerlink\" title=\"各种填充规则\"></a>各种填充规则</h1><h2 id=\"pkcs5\"><a href=\"#pkcs5\" class=\"headerlink\" title=\"pkcs5\"></a>pkcs5</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6F 72 05 05 05 05 05</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; FD 29 85 C9 E8 DF 41 40</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>pkCS5是8字节填充的，即填充一定数量的内容，使得成为8的整数倍，而填充的内容取决于需要填充的数目。例如，串0x56在经过PKCS5填充之后会成为0x56 0x07 0x07 0x07 0x07 0x07 0x07 0x07因为需要填充7字节，因此填充的内容就是7。当然特殊情况下，如果已经满足了8的整倍数，按照PKCS5的规则，仍然需要在尾部填充8个字节，并且内容是0x08,目的是为了加解密时统一处理填充。</li>\n<li>pkcs5总结来说就是在需要填充的位置，8字节缺少多少就填充多少，例如上面缺少5字节，所以填充0x05。</li>\n</ul>\n<h2 id=\"pkcs7\"><a href=\"#pkcs7\" class=\"headerlink\" title=\"pkcs7\"></a>pkcs7</h2><h2 id=\"OneAndZeroes-Padding\"><a href=\"#OneAndZeroes-Padding\" class=\"headerlink\" title=\"OneAndZeroes Padding\"></a>OneAndZeroes Padding</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6F 72 80 00 00 00 00</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; BE 62 5D 9F F3 C6 C8 40</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这里其实就是和 md5 和 sha1 的 padding 差不多。</li>\n</ul>\n<h2 id=\"Pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes\"><a href=\"#Pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes\" class=\"headerlink\" title=\"Pad with zeroes except make the last byte equal to the number of padding bytes\"></a>Pad with zeroes except make the last byte equal to the number of padding bytes</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 00 00 00 00 05</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; 91 19 2C 64 B5 5C 5D B8</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按照上面的例子，依旧缺失5字节，中间全部填充0x00，在最后一字节填充填充了多少，上面一共需要填充5字节，所以结尾为0x05。</li>\n</ul>\n<h2 id=\"Pad-with-zero-null-characters（零填充）\"><a href=\"#Pad-with-zero-null-characters（零填充）\" class=\"headerlink\" title=\"Pad with zero (null) characters（零填充）\"></a>Pad with zero (null) characters（零填充）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 00 00 00 00 00</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; 9E 14 FB 96 C5 FE EB 75</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在所有需要填充的地方填充0x00，直到满足填充原则。</li>\n</ul>\n<h2 id=\"Pad-with-spaces（空格填充）\"><a href=\"#Pad-with-spaces（空格填充）\" class=\"headerlink\" title=\"Pad with spaces（空格填充）\"></a>Pad with spaces（空格填充）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DES INPUT BLOCK  &#x3D; f  o  r  _  _  _  _  _</span><br><span class=\"line\">(IN HEX)           66 6f 72 20 20 20 20 20</span><br><span class=\"line\">KEY              &#x3D; 01 23 45 67 89 AB CD EF</span><br><span class=\"line\">DES OUTPUT BLOCK &#x3D; E3 FF EC E5 21 1F 35 25</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所有需要填充的地方都使用空格填充。</li>\n</ul>\n"},{"title":"RSA  Factor Attack 及常用脚本","author":"人生若只如初见","date":"2020-05-28T14:31:00.000Z","_content":"# 基本解密\n\n* 以下全文中^代表乘方，例如：2^3=2的3次方=8\n* c^d %n  == (m^e)^d %n ==m^ (e*d)%n ==m^(e*d %(φ（n）))%n  ==m^1 %n \n\n* 下面开始正文\n\n# Factor Attack\n\n## 1、当p==q\n\n```\n\tn=p*q=p**2\n\tφ（n）=p**2-p\n```\n\n## 2、孪生质数（twin prime）\n\n* 定义：孪生素数就是指相差2的素数对，例如：3和5，5和7，以36N（N+1）为界，孪生素数以波浪形式渐渐增多\n\n```\n\tn1=p*q,n2=(p+2)*(q+2)\n\tφ（n1）=（p-1）*(q-1)=n1-(p+q)+1\n\tφ（n2）=(p+1)*(q+1)=n1+(p+q)+1\n\tn2=(p+2)*(q+2)=n1+2*(p+q)+4\n\tp+q=(n2-n1-4)/2\n```\n\n## 3、Common Factor Attack(公约数分解)\n\n* p,q  为gcd(ni,nj)=pi=pj，所给N中有最大公因数，即可侧面分解n，也出现在唯密文攻击中，这时一般公约数出现在n与密文c之间\n\n## 4、Pollard Algorithm\n\n* 使用时机：当p-1光滑时\n* 例如：\n\n```\np=9132400715036908229752508016230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\n```\n* a,b,n,k属于N，p是素数，满足gcd(a,p)=1和p|n\n* 根据费马小定理：\n\n```\na^(p-1)≡1 (mod p)⇨a^k(p-1)≡1 (mod p)⇨p|gcd(a^b-1,n)=p^2\n```\n\n* 若p-1|b成立且满足gcd(a^b-1,n)>1,则gcd(a^b-1,n)=p,代入a=2去爆破，但可能会失败。\n\n```\ndef pollard(n):\n\t\ta,b=2,2\n\t\twhile True:\n\t\t\ta=pow(a,b,n)\n\t\t\tp=sympy.gcd(a-1,n)\n\t\t\tif 1<p<n: return p\n\t\t\tb +=1\n```\n\n## 5、Fermat's Factorization method\n* 使用时机：|p-q|很小的时候\n\n```\n让   a=(p+q)/2  b=(p-q)/2\n\t n=(a+b)^a-b)=a^2 -b^2\n```\n* 因为|p-q|很小，所以n会略等于a的平方，把a 用sqrt(n)代入，测试a^2-n是否为平方数，如果a^2-n是平方数，则(p,q)为(a+b,a-b)\n\n```\ndef fermat(n):\n\t\ta=gmpy2.isqrt(n)+1\n\t\tb=a**2-n\n\t\twhile not gmpy2.iroot(b,2)[1]:\n\t\t\ta += 1\n\t\t\tb = a**2 - n\n\t\tb= gmpy2.iroot(b , 2)[0]\n\t\treturn ( a + b , a - b )\n```\n\n# 用到的数学定理\n\n## 1、费马小定理\n* a属于N，p是素数\n\n```\na^(p-1)%p=1\na^(p-1)≡1 （mod p）\n代入φ函数\n推出：a^φ（p）≡1（mod p）\n```\n\n## Hastad's Broadcast Attack(中国剩余定理)\n\n* 对加密的指数做攻击\n* 使用时机：e固定不变，有多个n和对应的c\n\n```\n例子：\n\t\tN=3*5*7\n\tx≡2(mod 3)        N1=5*7=35   n1=3   d1=invert(N1,n1)=2\n\tx≡3(mod 5)        N2=3*7=21   n2=5   d2=invert(N2,n2)=1\n\tx≡2(mod 7)        N3=3*5=15   n3=7   d3=invert(N3,n3)=1\n\tx=(c1*d1*N1+c2*d2*N2+c3*d3*N3)%N\n\t之后对x使用gmpy2.iroot（）,开e次方\n```\n* 特例：2020网鼎杯\n* 使用中国剩余定理求出X后，gmpy2.iroot()开次方数为17，这个需要观察rsa中密文长度、明文长度和模数长度之间的关系考虑。\n\n## Wiener's Attack(维纳攻击)\n\n* 对解密指数做攻击\n* 使用时机：e非常大，d很小的时候\n* 当d<(1/3)(N^(1/4))和|p-q|<max(p,q)条件符合时，可以利用(e,n)来估计(d,φ(n))\n\n```\ne*d≡1(mod φ（n）)\n\t→e*d=k*φ（n）+1                       k属于N\n\t→e/φ（n）=k/d++1/(d*φ（n）)        divide by d*φ（n）\n\t→e/φ（n）≈k/d\n\t→e/n≈k/d\n\t方法：连分数  #如何做连分数\n```\n\n## Common Factor Attack(共模攻击)\n\n* 使用时机：相同明文，不同e，相同的N, 有对应的密文\n\n```\nm**e1%n=c1\nm**e2%n=c2\n若满足gcd(e1,e2)=1，则有线性方程满足s1*e1+s2*e2=1，其中s1=invert(e1,e2)且s2=invert(e2,e1)\nc1**s1 * c2**s2→(m**(e1*s1))*(m**(e2*s2))%n→m**(e1*s1+e2*s2)%n\n注意到(s1,s2)，他们必须是线性方程的一组解，所以分开算invert并不是一组的，所以算出s1后，因为s1*e1+s2*e2=1,所以s2=(1-s1*e1)/e2\n但python的pow报错：\n\t\tValueError:pow()2nd argument cannot be negative when 3rd argument specified\n\t\t若c2**s2≡x**(-s2)  (mod n)\n\t\t  (c2**s2)(x**s2)≡1 (mod n)\n\t\t  (c2*x)**s2≡1 (mod n)\n```\n\n* 脚本\n\n```\nimport sympy\nn=\ne1=\ne2=\nc1=\nc2=\nc2=int(sympy.invert(c2,n))  #作为上面公式中的x\ns1=int(sympy.invert(e1,e2))\ns2=(s1*e1-1)//e2\nm=(pow(c1,s1,n)*pow(c2,s2,n))%n\n```\n\n# 一些自己常用的自定义函数和脚本\n## 1、自定义的invert函数\n\n```\ndef egcd(a,b):\n\tif a==0: return (b,0,1)\n\telse:\n\t\tg,x,y=egcd(b%a,a)\n\t\treturn (g, x - (b // a)*y,y)\n\ndef invert(a,m):\n\tg,x,y=egcd(a,m)\n\tif g !=1: print ('modular inverse does not exist')\n\telse: return x%m\n\ne= \nphi=   #即φ（n）\nd=invert(e,phi)\n```\n\n## 2、维纳攻击脚本\n\n```\nimport sympy\n\ndef fractions(x,y):\n\tans=[y//x]\n\tif y%x==0: return ans\n\telse:\n\t\tans.extend(fractions(y%x,x))\n\t\treturn ans\n\ndef continued_fractions(e,n):\n\tans=[]\n\tx= fractions(e,n)\n\tfor i in range(1,len(x)):\n\t\tk, d= 1, x[i-1]\n\t\tfor j in x[:i-1][::-1]:\n\t\t\tk, d = d, d*j+k\n\t\tans.apped((k, d))\n\treturn ans\n\t\ndef Wiener(e,n):\n\tfor k, d in continued_fractions(e,n):\n\t\tphi=(e*d-1)//k\n\t\t#x**2 -(n-phi+1)x+n=0\n\t\tif d == int(sympy.invert(e,phi)):\n\t\t\treturn d\n\t\t\tbreak\n```\n","source":"_posts/rsa-Factor-Attack-及常用脚本.md","raw":"title: RSA  Factor Attack 及常用脚本\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-05-28 22:31:00\n---\n# 基本解密\n\n* 以下全文中^代表乘方，例如：2^3=2的3次方=8\n* c^d %n  == (m^e)^d %n ==m^ (e*d)%n ==m^(e*d %(φ（n）))%n  ==m^1 %n \n\n* 下面开始正文\n\n# Factor Attack\n\n## 1、当p==q\n\n```\n\tn=p*q=p**2\n\tφ（n）=p**2-p\n```\n\n## 2、孪生质数（twin prime）\n\n* 定义：孪生素数就是指相差2的素数对，例如：3和5，5和7，以36N（N+1）为界，孪生素数以波浪形式渐渐增多\n\n```\n\tn1=p*q,n2=(p+2)*(q+2)\n\tφ（n1）=（p-1）*(q-1)=n1-(p+q)+1\n\tφ（n2）=(p+1)*(q+1)=n1+(p+q)+1\n\tn2=(p+2)*(q+2)=n1+2*(p+q)+4\n\tp+q=(n2-n1-4)/2\n```\n\n## 3、Common Factor Attack(公约数分解)\n\n* p,q  为gcd(ni,nj)=pi=pj，所给N中有最大公因数，即可侧面分解n，也出现在唯密文攻击中，这时一般公约数出现在n与密文c之间\n\n## 4、Pollard Algorithm\n\n* 使用时机：当p-1光滑时\n* 例如：\n\n```\np=9132400715036908229752508016230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\n```\n* a,b,n,k属于N，p是素数，满足gcd(a,p)=1和p|n\n* 根据费马小定理：\n\n```\na^(p-1)≡1 (mod p)⇨a^k(p-1)≡1 (mod p)⇨p|gcd(a^b-1,n)=p^2\n```\n\n* 若p-1|b成立且满足gcd(a^b-1,n)>1,则gcd(a^b-1,n)=p,代入a=2去爆破，但可能会失败。\n\n```\ndef pollard(n):\n\t\ta,b=2,2\n\t\twhile True:\n\t\t\ta=pow(a,b,n)\n\t\t\tp=sympy.gcd(a-1,n)\n\t\t\tif 1<p<n: return p\n\t\t\tb +=1\n```\n\n## 5、Fermat's Factorization method\n* 使用时机：|p-q|很小的时候\n\n```\n让   a=(p+q)/2  b=(p-q)/2\n\t n=(a+b)^a-b)=a^2 -b^2\n```\n* 因为|p-q|很小，所以n会略等于a的平方，把a 用sqrt(n)代入，测试a^2-n是否为平方数，如果a^2-n是平方数，则(p,q)为(a+b,a-b)\n\n```\ndef fermat(n):\n\t\ta=gmpy2.isqrt(n)+1\n\t\tb=a**2-n\n\t\twhile not gmpy2.iroot(b,2)[1]:\n\t\t\ta += 1\n\t\t\tb = a**2 - n\n\t\tb= gmpy2.iroot(b , 2)[0]\n\t\treturn ( a + b , a - b )\n```\n\n# 用到的数学定理\n\n## 1、费马小定理\n* a属于N，p是素数\n\n```\na^(p-1)%p=1\na^(p-1)≡1 （mod p）\n代入φ函数\n推出：a^φ（p）≡1（mod p）\n```\n\n## Hastad's Broadcast Attack(中国剩余定理)\n\n* 对加密的指数做攻击\n* 使用时机：e固定不变，有多个n和对应的c\n\n```\n例子：\n\t\tN=3*5*7\n\tx≡2(mod 3)        N1=5*7=35   n1=3   d1=invert(N1,n1)=2\n\tx≡3(mod 5)        N2=3*7=21   n2=5   d2=invert(N2,n2)=1\n\tx≡2(mod 7)        N3=3*5=15   n3=7   d3=invert(N3,n3)=1\n\tx=(c1*d1*N1+c2*d2*N2+c3*d3*N3)%N\n\t之后对x使用gmpy2.iroot（）,开e次方\n```\n* 特例：2020网鼎杯\n* 使用中国剩余定理求出X后，gmpy2.iroot()开次方数为17，这个需要观察rsa中密文长度、明文长度和模数长度之间的关系考虑。\n\n## Wiener's Attack(维纳攻击)\n\n* 对解密指数做攻击\n* 使用时机：e非常大，d很小的时候\n* 当d<(1/3)(N^(1/4))和|p-q|<max(p,q)条件符合时，可以利用(e,n)来估计(d,φ(n))\n\n```\ne*d≡1(mod φ（n）)\n\t→e*d=k*φ（n）+1                       k属于N\n\t→e/φ（n）=k/d++1/(d*φ（n）)        divide by d*φ（n）\n\t→e/φ（n）≈k/d\n\t→e/n≈k/d\n\t方法：连分数  #如何做连分数\n```\n\n## Common Factor Attack(共模攻击)\n\n* 使用时机：相同明文，不同e，相同的N, 有对应的密文\n\n```\nm**e1%n=c1\nm**e2%n=c2\n若满足gcd(e1,e2)=1，则有线性方程满足s1*e1+s2*e2=1，其中s1=invert(e1,e2)且s2=invert(e2,e1)\nc1**s1 * c2**s2→(m**(e1*s1))*(m**(e2*s2))%n→m**(e1*s1+e2*s2)%n\n注意到(s1,s2)，他们必须是线性方程的一组解，所以分开算invert并不是一组的，所以算出s1后，因为s1*e1+s2*e2=1,所以s2=(1-s1*e1)/e2\n但python的pow报错：\n\t\tValueError:pow()2nd argument cannot be negative when 3rd argument specified\n\t\t若c2**s2≡x**(-s2)  (mod n)\n\t\t  (c2**s2)(x**s2)≡1 (mod n)\n\t\t  (c2*x)**s2≡1 (mod n)\n```\n\n* 脚本\n\n```\nimport sympy\nn=\ne1=\ne2=\nc1=\nc2=\nc2=int(sympy.invert(c2,n))  #作为上面公式中的x\ns1=int(sympy.invert(e1,e2))\ns2=(s1*e1-1)//e2\nm=(pow(c1,s1,n)*pow(c2,s2,n))%n\n```\n\n# 一些自己常用的自定义函数和脚本\n## 1、自定义的invert函数\n\n```\ndef egcd(a,b):\n\tif a==0: return (b,0,1)\n\telse:\n\t\tg,x,y=egcd(b%a,a)\n\t\treturn (g, x - (b // a)*y,y)\n\ndef invert(a,m):\n\tg,x,y=egcd(a,m)\n\tif g !=1: print ('modular inverse does not exist')\n\telse: return x%m\n\ne= \nphi=   #即φ（n）\nd=invert(e,phi)\n```\n\n## 2、维纳攻击脚本\n\n```\nimport sympy\n\ndef fractions(x,y):\n\tans=[y//x]\n\tif y%x==0: return ans\n\telse:\n\t\tans.extend(fractions(y%x,x))\n\t\treturn ans\n\ndef continued_fractions(e,n):\n\tans=[]\n\tx= fractions(e,n)\n\tfor i in range(1,len(x)):\n\t\tk, d= 1, x[i-1]\n\t\tfor j in x[:i-1][::-1]:\n\t\t\tk, d = d, d*j+k\n\t\tans.apped((k, d))\n\treturn ans\n\t\ndef Wiener(e,n):\n\tfor k, d in continued_fractions(e,n):\n\t\tphi=(e*d-1)//k\n\t\t#x**2 -(n-phi+1)x+n=0\n\t\tif d == int(sympy.invert(e,phi)):\n\t\t\treturn d\n\t\t\tbreak\n```\n","slug":"rsa-Factor-Attack-及常用脚本","published":1,"updated":"2020-05-28T15:07:13.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18l0028vcu9gs6xgudc","content":"<h1 id=\"基本解密\"><a href=\"#基本解密\" class=\"headerlink\" title=\"基本解密\"></a>基本解密</h1><ul>\n<li><p>以下全文中^代表乘方，例如：2^3=2的3次方=8</p>\n</li>\n<li><p>c^d %n  == (m^e)^d %n ==m^ (e<em>d)%n ==m^(e</em>d %(φ（n）))%n  ==m^1 %n </p>\n</li>\n<li><p>下面开始正文</p>\n</li>\n</ul>\n<h1 id=\"Factor-Attack\"><a href=\"#Factor-Attack\" class=\"headerlink\" title=\"Factor Attack\"></a>Factor Attack</h1><h2 id=\"1、当p-q\"><a href=\"#1、当p-q\" class=\"headerlink\" title=\"1、当p==q\"></a>1、当p==q</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;p*q&#x3D;p**2</span><br><span class=\"line\">φ（n）&#x3D;p**2-p</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、孪生质数（twin-prime）\"><a href=\"#2、孪生质数（twin-prime）\" class=\"headerlink\" title=\"2、孪生质数（twin prime）\"></a>2、孪生质数（twin prime）</h2><ul>\n<li>定义：孪生素数就是指相差2的素数对，例如：3和5，5和7，以36N（N+1）为界，孪生素数以波浪形式渐渐增多</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1&#x3D;p*q,n2&#x3D;(p+2)*(q+2)</span><br><span class=\"line\">φ（n1）&#x3D;（p-1）*(q-1)&#x3D;n1-(p+q)+1</span><br><span class=\"line\">φ（n2）&#x3D;(p+1)*(q+1)&#x3D;n1+(p+q)+1</span><br><span class=\"line\">n2&#x3D;(p+2)*(q+2)&#x3D;n1+2*(p+q)+4</span><br><span class=\"line\">p+q&#x3D;(n2-n1-4)&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、Common-Factor-Attack-公约数分解\"><a href=\"#3、Common-Factor-Attack-公约数分解\" class=\"headerlink\" title=\"3、Common Factor Attack(公约数分解)\"></a>3、Common Factor Attack(公约数分解)</h2><ul>\n<li>p,q  为gcd(ni,nj)=pi=pj，所给N中有最大公因数，即可侧面分解n，也出现在唯密文攻击中，这时一般公约数出现在n与密文c之间</li>\n</ul>\n<h2 id=\"4、Pollard-Algorithm\"><a href=\"#4、Pollard-Algorithm\" class=\"headerlink\" title=\"4、Pollard Algorithm\"></a>4、Pollard Algorithm</h2><ul>\n<li>使用时机：当p-1光滑时</li>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p&#x3D;9132400715036908229752508016230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure>\n<ul>\n<li>a,b,n,k属于N，p是素数，满足gcd(a,p)=1和p|n</li>\n<li>根据费马小定理：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a^(p-1)≡1 (mod p)⇨a^k(p-1)≡1 (mod p)⇨p|gcd(a^b-1,n)&#x3D;p^2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若p-1|b成立且满足gcd(a^b-1,n)&gt;1,则gcd(a^b-1,n)=p,代入a=2去爆破，但可能会失败。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def pollard(n):</span><br><span class=\"line\">\t\ta,b&#x3D;2,2</span><br><span class=\"line\">\t\twhile True:</span><br><span class=\"line\">\t\t\ta&#x3D;pow(a,b,n)</span><br><span class=\"line\">\t\t\tp&#x3D;sympy.gcd(a-1,n)</span><br><span class=\"line\">\t\t\tif 1&lt;p&lt;n: return p</span><br><span class=\"line\">\t\t\tb +&#x3D;1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5、Fermat’s-Factorization-method\"><a href=\"#5、Fermat’s-Factorization-method\" class=\"headerlink\" title=\"5、Fermat’s Factorization method\"></a>5、Fermat’s Factorization method</h2><ul>\n<li>使用时机：|p-q|很小的时候</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">让   a&#x3D;(p+q)&#x2F;2  b&#x3D;(p-q)&#x2F;2</span><br><span class=\"line\">\t n&#x3D;(a+b)^a-b)&#x3D;a^2 -b^2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>因为|p-q|很小，所以n会略等于a的平方，把a 用sqrt(n)代入，测试a^2-n是否为平方数，如果a^2-n是平方数，则(p,q)为(a+b,a-b)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fermat(n):</span><br><span class=\"line\">\t\ta&#x3D;gmpy2.isqrt(n)+1</span><br><span class=\"line\">\t\tb&#x3D;a**2-n</span><br><span class=\"line\">\t\twhile not gmpy2.iroot(b,2)[1]:</span><br><span class=\"line\">\t\t\ta +&#x3D; 1</span><br><span class=\"line\">\t\t\tb &#x3D; a**2 - n</span><br><span class=\"line\">\t\tb&#x3D; gmpy2.iroot(b , 2)[0]</span><br><span class=\"line\">\t\treturn ( a + b , a - b )</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用到的数学定理\"><a href=\"#用到的数学定理\" class=\"headerlink\" title=\"用到的数学定理\"></a>用到的数学定理</h1><h2 id=\"1、费马小定理\"><a href=\"#1、费马小定理\" class=\"headerlink\" title=\"1、费马小定理\"></a>1、费马小定理</h2><ul>\n<li>a属于N，p是素数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a^(p-1)%p&#x3D;1</span><br><span class=\"line\">a^(p-1)≡1 （mod p）</span><br><span class=\"line\">代入φ函数</span><br><span class=\"line\">推出：a^φ（p）≡1（mod p）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hastad’s-Broadcast-Attack-中国剩余定理\"><a href=\"#Hastad’s-Broadcast-Attack-中国剩余定理\" class=\"headerlink\" title=\"Hastad’s Broadcast Attack(中国剩余定理)\"></a>Hastad’s Broadcast Attack(中国剩余定理)</h2><ul>\n<li>对加密的指数做攻击</li>\n<li>使用时机：e固定不变，有多个n和对应的c</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子：</span><br><span class=\"line\">\t\tN&#x3D;3*5*7</span><br><span class=\"line\">\tx≡2(mod 3)        N1&#x3D;5*7&#x3D;35   n1&#x3D;3   d1&#x3D;invert(N1,n1)&#x3D;2</span><br><span class=\"line\">\tx≡3(mod 5)        N2&#x3D;3*7&#x3D;21   n2&#x3D;5   d2&#x3D;invert(N2,n2)&#x3D;1</span><br><span class=\"line\">\tx≡2(mod 7)        N3&#x3D;3*5&#x3D;15   n3&#x3D;7   d3&#x3D;invert(N3,n3)&#x3D;1</span><br><span class=\"line\">\tx&#x3D;(c1*d1*N1+c2*d2*N2+c3*d3*N3)%N</span><br><span class=\"line\">\t之后对x使用gmpy2.iroot（）,开e次方</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特例：2020网鼎杯</li>\n<li>使用中国剩余定理求出X后，gmpy2.iroot()开次方数为17，这个需要观察rsa中密文长度、明文长度和模数长度之间的关系考虑。</li>\n</ul>\n<h2 id=\"Wiener’s-Attack-维纳攻击\"><a href=\"#Wiener’s-Attack-维纳攻击\" class=\"headerlink\" title=\"Wiener’s Attack(维纳攻击)\"></a>Wiener’s Attack(维纳攻击)</h2><ul>\n<li>对解密指数做攻击</li>\n<li>使用时机：e非常大，d很小的时候</li>\n<li>当d&lt;(1/3)(N^(1/4))和|p-q|&lt;max(p,q)条件符合时，可以利用(e,n)来估计(d,φ(n))</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e*d≡1(mod φ（n）)</span><br><span class=\"line\">\t→e*d&#x3D;k*φ（n）+1                       k属于N</span><br><span class=\"line\">\t→e&#x2F;φ（n）&#x3D;k&#x2F;d++1&#x2F;(d*φ（n）)        divide by d*φ（n）</span><br><span class=\"line\">\t→e&#x2F;φ（n）≈k&#x2F;d</span><br><span class=\"line\">\t→e&#x2F;n≈k&#x2F;d</span><br><span class=\"line\">\t方法：连分数  #如何做连分数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Common-Factor-Attack-共模攻击\"><a href=\"#Common-Factor-Attack-共模攻击\" class=\"headerlink\" title=\"Common Factor Attack(共模攻击)\"></a>Common Factor Attack(共模攻击)</h2><ul>\n<li>使用时机：相同明文，不同e，相同的N, 有对应的密文</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m**e1%n&#x3D;c1</span><br><span class=\"line\">m**e2%n&#x3D;c2</span><br><span class=\"line\">若满足gcd(e1,e2)&#x3D;1，则有线性方程满足s1*e1+s2*e2&#x3D;1，其中s1&#x3D;invert(e1,e2)且s2&#x3D;invert(e2,e1)</span><br><span class=\"line\">c1**s1 * c2**s2→(m**(e1*s1))*(m**(e2*s2))%n→m**(e1*s1+e2*s2)%n</span><br><span class=\"line\">注意到(s1,s2)，他们必须是线性方程的一组解，所以分开算invert并不是一组的，所以算出s1后，因为s1*e1+s2*e2&#x3D;1,所以s2&#x3D;(1-s1*e1)&#x2F;e2</span><br><span class=\"line\">但python的pow报错：</span><br><span class=\"line\">\t\tValueError:pow()2nd argument cannot be negative when 3rd argument specified</span><br><span class=\"line\">\t\t若c2**s2≡x**(-s2)  (mod n)</span><br><span class=\"line\">\t\t  (c2**s2)(x**s2)≡1 (mod n)</span><br><span class=\"line\">\t\t  (c2*x)**s2≡1 (mod n)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>脚本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\">n&#x3D;</span><br><span class=\"line\">e1&#x3D;</span><br><span class=\"line\">e2&#x3D;</span><br><span class=\"line\">c1&#x3D;</span><br><span class=\"line\">c2&#x3D;</span><br><span class=\"line\">c2&#x3D;int(sympy.invert(c2,n))  #作为上面公式中的x</span><br><span class=\"line\">s1&#x3D;int(sympy.invert(e1,e2))</span><br><span class=\"line\">s2&#x3D;(s1*e1-1)&#x2F;&#x2F;e2</span><br><span class=\"line\">m&#x3D;(pow(c1,s1,n)*pow(c2,s2,n))%n</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"一些自己常用的自定义函数和脚本\"><a href=\"#一些自己常用的自定义函数和脚本\" class=\"headerlink\" title=\"一些自己常用的自定义函数和脚本\"></a>一些自己常用的自定义函数和脚本</h1><h2 id=\"1、自定义的invert函数\"><a href=\"#1、自定义的invert函数\" class=\"headerlink\" title=\"1、自定义的invert函数\"></a>1、自定义的invert函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def egcd(a,b):</span><br><span class=\"line\">\tif a&#x3D;&#x3D;0: return (b,0,1)</span><br><span class=\"line\">\telse:</span><br><span class=\"line\">\t\tg,x,y&#x3D;egcd(b%a,a)</span><br><span class=\"line\">\t\treturn (g, x - (b &#x2F;&#x2F; a)*y,y)</span><br><span class=\"line\"></span><br><span class=\"line\">def invert(a,m):</span><br><span class=\"line\">\tg,x,y&#x3D;egcd(a,m)</span><br><span class=\"line\">\tif g !&#x3D;1: print (&#39;modular inverse does not exist&#39;)</span><br><span class=\"line\">\telse: return x%m</span><br><span class=\"line\"></span><br><span class=\"line\">e&#x3D; </span><br><span class=\"line\">phi&#x3D;   #即φ（n）</span><br><span class=\"line\">d&#x3D;invert(e,phi)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、维纳攻击脚本\"><a href=\"#2、维纳攻击脚本\" class=\"headerlink\" title=\"2、维纳攻击脚本\"></a>2、维纳攻击脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\"></span><br><span class=\"line\">def fractions(x,y):</span><br><span class=\"line\">\tans&#x3D;[y&#x2F;&#x2F;x]</span><br><span class=\"line\">\tif y%x&#x3D;&#x3D;0: return ans</span><br><span class=\"line\">\telse:</span><br><span class=\"line\">\t\tans.extend(fractions(y%x,x))</span><br><span class=\"line\">\t\treturn ans</span><br><span class=\"line\"></span><br><span class=\"line\">def continued_fractions(e,n):</span><br><span class=\"line\">\tans&#x3D;[]</span><br><span class=\"line\">\tx&#x3D; fractions(e,n)</span><br><span class=\"line\">\tfor i in range(1,len(x)):</span><br><span class=\"line\">\t\tk, d&#x3D; 1, x[i-1]</span><br><span class=\"line\">\t\tfor j in x[:i-1][::-1]:</span><br><span class=\"line\">\t\t\tk, d &#x3D; d, d*j+k</span><br><span class=\"line\">\t\tans.apped((k, d))</span><br><span class=\"line\">\treturn ans</span><br><span class=\"line\">\t</span><br><span class=\"line\">def Wiener(e,n):</span><br><span class=\"line\">\tfor k, d in continued_fractions(e,n):</span><br><span class=\"line\">\t\tphi&#x3D;(e*d-1)&#x2F;&#x2F;k</span><br><span class=\"line\">\t\t#x**2 -(n-phi+1)x+n&#x3D;0</span><br><span class=\"line\">\t\tif d &#x3D;&#x3D; int(sympy.invert(e,phi)):</span><br><span class=\"line\">\t\t\treturn d</span><br><span class=\"line\">\t\t\tbreak</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本解密\"><a href=\"#基本解密\" class=\"headerlink\" title=\"基本解密\"></a>基本解密</h1><ul>\n<li><p>以下全文中^代表乘方，例如：2^3=2的3次方=8</p>\n</li>\n<li><p>c^d %n  == (m^e)^d %n ==m^ (e<em>d)%n ==m^(e</em>d %(φ（n）))%n  ==m^1 %n </p>\n</li>\n<li><p>下面开始正文</p>\n</li>\n</ul>\n<h1 id=\"Factor-Attack\"><a href=\"#Factor-Attack\" class=\"headerlink\" title=\"Factor Attack\"></a>Factor Attack</h1><h2 id=\"1、当p-q\"><a href=\"#1、当p-q\" class=\"headerlink\" title=\"1、当p==q\"></a>1、当p==q</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n&#x3D;p*q&#x3D;p**2</span><br><span class=\"line\">φ（n）&#x3D;p**2-p</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、孪生质数（twin-prime）\"><a href=\"#2、孪生质数（twin-prime）\" class=\"headerlink\" title=\"2、孪生质数（twin prime）\"></a>2、孪生质数（twin prime）</h2><ul>\n<li>定义：孪生素数就是指相差2的素数对，例如：3和5，5和7，以36N（N+1）为界，孪生素数以波浪形式渐渐增多</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1&#x3D;p*q,n2&#x3D;(p+2)*(q+2)</span><br><span class=\"line\">φ（n1）&#x3D;（p-1）*(q-1)&#x3D;n1-(p+q)+1</span><br><span class=\"line\">φ（n2）&#x3D;(p+1)*(q+1)&#x3D;n1+(p+q)+1</span><br><span class=\"line\">n2&#x3D;(p+2)*(q+2)&#x3D;n1+2*(p+q)+4</span><br><span class=\"line\">p+q&#x3D;(n2-n1-4)&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、Common-Factor-Attack-公约数分解\"><a href=\"#3、Common-Factor-Attack-公约数分解\" class=\"headerlink\" title=\"3、Common Factor Attack(公约数分解)\"></a>3、Common Factor Attack(公约数分解)</h2><ul>\n<li>p,q  为gcd(ni,nj)=pi=pj，所给N中有最大公因数，即可侧面分解n，也出现在唯密文攻击中，这时一般公约数出现在n与密文c之间</li>\n</ul>\n<h2 id=\"4、Pollard-Algorithm\"><a href=\"#4、Pollard-Algorithm\" class=\"headerlink\" title=\"4、Pollard Algorithm\"></a>4、Pollard Algorithm</h2><ul>\n<li>使用时机：当p-1光滑时</li>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p&#x3D;9132400715036908229752508016230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure>\n<ul>\n<li>a,b,n,k属于N，p是素数，满足gcd(a,p)=1和p|n</li>\n<li>根据费马小定理：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a^(p-1)≡1 (mod p)⇨a^k(p-1)≡1 (mod p)⇨p|gcd(a^b-1,n)&#x3D;p^2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若p-1|b成立且满足gcd(a^b-1,n)&gt;1,则gcd(a^b-1,n)=p,代入a=2去爆破，但可能会失败。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def pollard(n):</span><br><span class=\"line\">\t\ta,b&#x3D;2,2</span><br><span class=\"line\">\t\twhile True:</span><br><span class=\"line\">\t\t\ta&#x3D;pow(a,b,n)</span><br><span class=\"line\">\t\t\tp&#x3D;sympy.gcd(a-1,n)</span><br><span class=\"line\">\t\t\tif 1&lt;p&lt;n: return p</span><br><span class=\"line\">\t\t\tb +&#x3D;1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5、Fermat’s-Factorization-method\"><a href=\"#5、Fermat’s-Factorization-method\" class=\"headerlink\" title=\"5、Fermat’s Factorization method\"></a>5、Fermat’s Factorization method</h2><ul>\n<li>使用时机：|p-q|很小的时候</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">让   a&#x3D;(p+q)&#x2F;2  b&#x3D;(p-q)&#x2F;2</span><br><span class=\"line\">\t n&#x3D;(a+b)^a-b)&#x3D;a^2 -b^2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>因为|p-q|很小，所以n会略等于a的平方，把a 用sqrt(n)代入，测试a^2-n是否为平方数，如果a^2-n是平方数，则(p,q)为(a+b,a-b)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fermat(n):</span><br><span class=\"line\">\t\ta&#x3D;gmpy2.isqrt(n)+1</span><br><span class=\"line\">\t\tb&#x3D;a**2-n</span><br><span class=\"line\">\t\twhile not gmpy2.iroot(b,2)[1]:</span><br><span class=\"line\">\t\t\ta +&#x3D; 1</span><br><span class=\"line\">\t\t\tb &#x3D; a**2 - n</span><br><span class=\"line\">\t\tb&#x3D; gmpy2.iroot(b , 2)[0]</span><br><span class=\"line\">\t\treturn ( a + b , a - b )</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用到的数学定理\"><a href=\"#用到的数学定理\" class=\"headerlink\" title=\"用到的数学定理\"></a>用到的数学定理</h1><h2 id=\"1、费马小定理\"><a href=\"#1、费马小定理\" class=\"headerlink\" title=\"1、费马小定理\"></a>1、费马小定理</h2><ul>\n<li>a属于N，p是素数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a^(p-1)%p&#x3D;1</span><br><span class=\"line\">a^(p-1)≡1 （mod p）</span><br><span class=\"line\">代入φ函数</span><br><span class=\"line\">推出：a^φ（p）≡1（mod p）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hastad’s-Broadcast-Attack-中国剩余定理\"><a href=\"#Hastad’s-Broadcast-Attack-中国剩余定理\" class=\"headerlink\" title=\"Hastad’s Broadcast Attack(中国剩余定理)\"></a>Hastad’s Broadcast Attack(中国剩余定理)</h2><ul>\n<li>对加密的指数做攻击</li>\n<li>使用时机：e固定不变，有多个n和对应的c</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子：</span><br><span class=\"line\">\t\tN&#x3D;3*5*7</span><br><span class=\"line\">\tx≡2(mod 3)        N1&#x3D;5*7&#x3D;35   n1&#x3D;3   d1&#x3D;invert(N1,n1)&#x3D;2</span><br><span class=\"line\">\tx≡3(mod 5)        N2&#x3D;3*7&#x3D;21   n2&#x3D;5   d2&#x3D;invert(N2,n2)&#x3D;1</span><br><span class=\"line\">\tx≡2(mod 7)        N3&#x3D;3*5&#x3D;15   n3&#x3D;7   d3&#x3D;invert(N3,n3)&#x3D;1</span><br><span class=\"line\">\tx&#x3D;(c1*d1*N1+c2*d2*N2+c3*d3*N3)%N</span><br><span class=\"line\">\t之后对x使用gmpy2.iroot（）,开e次方</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特例：2020网鼎杯</li>\n<li>使用中国剩余定理求出X后，gmpy2.iroot()开次方数为17，这个需要观察rsa中密文长度、明文长度和模数长度之间的关系考虑。</li>\n</ul>\n<h2 id=\"Wiener’s-Attack-维纳攻击\"><a href=\"#Wiener’s-Attack-维纳攻击\" class=\"headerlink\" title=\"Wiener’s Attack(维纳攻击)\"></a>Wiener’s Attack(维纳攻击)</h2><ul>\n<li>对解密指数做攻击</li>\n<li>使用时机：e非常大，d很小的时候</li>\n<li>当d&lt;(1/3)(N^(1/4))和|p-q|&lt;max(p,q)条件符合时，可以利用(e,n)来估计(d,φ(n))</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">e*d≡1(mod φ（n）)</span><br><span class=\"line\">\t→e*d&#x3D;k*φ（n）+1                       k属于N</span><br><span class=\"line\">\t→e&#x2F;φ（n）&#x3D;k&#x2F;d++1&#x2F;(d*φ（n）)        divide by d*φ（n）</span><br><span class=\"line\">\t→e&#x2F;φ（n）≈k&#x2F;d</span><br><span class=\"line\">\t→e&#x2F;n≈k&#x2F;d</span><br><span class=\"line\">\t方法：连分数  #如何做连分数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Common-Factor-Attack-共模攻击\"><a href=\"#Common-Factor-Attack-共模攻击\" class=\"headerlink\" title=\"Common Factor Attack(共模攻击)\"></a>Common Factor Attack(共模攻击)</h2><ul>\n<li>使用时机：相同明文，不同e，相同的N, 有对应的密文</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m**e1%n&#x3D;c1</span><br><span class=\"line\">m**e2%n&#x3D;c2</span><br><span class=\"line\">若满足gcd(e1,e2)&#x3D;1，则有线性方程满足s1*e1+s2*e2&#x3D;1，其中s1&#x3D;invert(e1,e2)且s2&#x3D;invert(e2,e1)</span><br><span class=\"line\">c1**s1 * c2**s2→(m**(e1*s1))*(m**(e2*s2))%n→m**(e1*s1+e2*s2)%n</span><br><span class=\"line\">注意到(s1,s2)，他们必须是线性方程的一组解，所以分开算invert并不是一组的，所以算出s1后，因为s1*e1+s2*e2&#x3D;1,所以s2&#x3D;(1-s1*e1)&#x2F;e2</span><br><span class=\"line\">但python的pow报错：</span><br><span class=\"line\">\t\tValueError:pow()2nd argument cannot be negative when 3rd argument specified</span><br><span class=\"line\">\t\t若c2**s2≡x**(-s2)  (mod n)</span><br><span class=\"line\">\t\t  (c2**s2)(x**s2)≡1 (mod n)</span><br><span class=\"line\">\t\t  (c2*x)**s2≡1 (mod n)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>脚本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\">n&#x3D;</span><br><span class=\"line\">e1&#x3D;</span><br><span class=\"line\">e2&#x3D;</span><br><span class=\"line\">c1&#x3D;</span><br><span class=\"line\">c2&#x3D;</span><br><span class=\"line\">c2&#x3D;int(sympy.invert(c2,n))  #作为上面公式中的x</span><br><span class=\"line\">s1&#x3D;int(sympy.invert(e1,e2))</span><br><span class=\"line\">s2&#x3D;(s1*e1-1)&#x2F;&#x2F;e2</span><br><span class=\"line\">m&#x3D;(pow(c1,s1,n)*pow(c2,s2,n))%n</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"一些自己常用的自定义函数和脚本\"><a href=\"#一些自己常用的自定义函数和脚本\" class=\"headerlink\" title=\"一些自己常用的自定义函数和脚本\"></a>一些自己常用的自定义函数和脚本</h1><h2 id=\"1、自定义的invert函数\"><a href=\"#1、自定义的invert函数\" class=\"headerlink\" title=\"1、自定义的invert函数\"></a>1、自定义的invert函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def egcd(a,b):</span><br><span class=\"line\">\tif a&#x3D;&#x3D;0: return (b,0,1)</span><br><span class=\"line\">\telse:</span><br><span class=\"line\">\t\tg,x,y&#x3D;egcd(b%a,a)</span><br><span class=\"line\">\t\treturn (g, x - (b &#x2F;&#x2F; a)*y,y)</span><br><span class=\"line\"></span><br><span class=\"line\">def invert(a,m):</span><br><span class=\"line\">\tg,x,y&#x3D;egcd(a,m)</span><br><span class=\"line\">\tif g !&#x3D;1: print (&#39;modular inverse does not exist&#39;)</span><br><span class=\"line\">\telse: return x%m</span><br><span class=\"line\"></span><br><span class=\"line\">e&#x3D; </span><br><span class=\"line\">phi&#x3D;   #即φ（n）</span><br><span class=\"line\">d&#x3D;invert(e,phi)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、维纳攻击脚本\"><a href=\"#2、维纳攻击脚本\" class=\"headerlink\" title=\"2、维纳攻击脚本\"></a>2、维纳攻击脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sympy</span><br><span class=\"line\"></span><br><span class=\"line\">def fractions(x,y):</span><br><span class=\"line\">\tans&#x3D;[y&#x2F;&#x2F;x]</span><br><span class=\"line\">\tif y%x&#x3D;&#x3D;0: return ans</span><br><span class=\"line\">\telse:</span><br><span class=\"line\">\t\tans.extend(fractions(y%x,x))</span><br><span class=\"line\">\t\treturn ans</span><br><span class=\"line\"></span><br><span class=\"line\">def continued_fractions(e,n):</span><br><span class=\"line\">\tans&#x3D;[]</span><br><span class=\"line\">\tx&#x3D; fractions(e,n)</span><br><span class=\"line\">\tfor i in range(1,len(x)):</span><br><span class=\"line\">\t\tk, d&#x3D; 1, x[i-1]</span><br><span class=\"line\">\t\tfor j in x[:i-1][::-1]:</span><br><span class=\"line\">\t\t\tk, d &#x3D; d, d*j+k</span><br><span class=\"line\">\t\tans.apped((k, d))</span><br><span class=\"line\">\treturn ans</span><br><span class=\"line\">\t</span><br><span class=\"line\">def Wiener(e,n):</span><br><span class=\"line\">\tfor k, d in continued_fractions(e,n):</span><br><span class=\"line\">\t\tphi&#x3D;(e*d-1)&#x2F;&#x2F;k</span><br><span class=\"line\">\t\t#x**2 -(n-phi+1)x+n&#x3D;0</span><br><span class=\"line\">\t\tif d &#x3D;&#x3D; int(sympy.invert(e,phi)):</span><br><span class=\"line\">\t\t\treturn d</span><br><span class=\"line\">\t\t\tbreak</span><br></pre></td></tr></table></figure>\n"},{"title":"将CRT(中国剩余定理)与RSA结合","author":"人生若只如初见","date":"2020-06-01T01:00:00.000Z","_content":"* 使用中国剩余定理来加快RSA的运算速度，使用Zn中数字的CRT表示法，使用N的素因子预先计算出的三个额外值，来更有效的执行四次幂运算。\n\n# 在RSA中的一些运算\n\n* 正常的RSA解密，使用私钥(n,d)进行密文解密（或生成签名），不过在运算过程中，我们需要先通过公钥指数e求得私钥指数d，并不如e那么方便，所以可以选择一个值尽可能少的“1”位。\n* 对于k位的模数N，私钥质数也有类似的长度，大约一半是“1”。计算指数的时间与k^3成正比,所以需要其他的计算。\n* 基础解密：m=c^d mod n\n\n\n\n* 1、给定p、q并用p>q预计算几个值\n\n```\ndp=(1/e) mod (p-1)\ndq=(1/e) mod (q-1)\nqInv=(1/q) mod p\n```\n\n* 1/e表示e关于phi的逆元，表达式x =（1 / e）mod N也写为x = e -1 mod N，并且x是满足xe≡1（mod N）的任何整数。\n* 使用在Zn中的唯一值x，数字集合{0,1,2,...,n-1}\n* 解密给定的C可以按照下面的步骤\n\n```\nm1 = c^dP mod p\nm2 = c^dQ mod q\nh = qInv.(m1 - m2) mod p\nm = m2 + h.q\n```\n\n* 可以发现，dp,dq,qInv,p,q正好是私钥中的内容。\n\n# 中国剩余定理-特例\n\n```\n定理：令p,q为不同的素数，n=p*q对于任何对(x1,x2)，其中0≤x 1 <p和0≤x 2 <q\n\t存在唯一的数x，其中0≤x <n\n    \t  x 1 = x mod p，\n  \t\t  x 2 = x mod q。\n```\n\n* 任何整数x（0≤x <n）都可以用其CRT表示形式（x 1，x 2）唯一表示。\n\n# 欧拉定理与欧拉公式\n\n```\n如果n是一个正整数，并且a与n互质即gcd(a,n)=1，则a^φ(n) ≡ 1 (mod n)\nφ(n) 是欧拉函数\n欧拉函数是求小于等于n的数中与n互质的数的数目  \n即欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目\n或者说欧拉函数是求 1到n-1 中 与n互质的数 的数目\n \n如果n是质数\n那么1到n-1所有数都是与n互质的，\n所以φ(n) = n-1\n如果n是合数。。。自己算吧\n例如φ(8)=4，因为1,3,5,7均和8互质\n```","source":"_posts/将CRT-中国剩余定理-与RSA结合.md","raw":"title: 将CRT(中国剩余定理)与RSA结合\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-06-01 09:00:00\n---\n* 使用中国剩余定理来加快RSA的运算速度，使用Zn中数字的CRT表示法，使用N的素因子预先计算出的三个额外值，来更有效的执行四次幂运算。\n\n# 在RSA中的一些运算\n\n* 正常的RSA解密，使用私钥(n,d)进行密文解密（或生成签名），不过在运算过程中，我们需要先通过公钥指数e求得私钥指数d，并不如e那么方便，所以可以选择一个值尽可能少的“1”位。\n* 对于k位的模数N，私钥质数也有类似的长度，大约一半是“1”。计算指数的时间与k^3成正比,所以需要其他的计算。\n* 基础解密：m=c^d mod n\n\n\n\n* 1、给定p、q并用p>q预计算几个值\n\n```\ndp=(1/e) mod (p-1)\ndq=(1/e) mod (q-1)\nqInv=(1/q) mod p\n```\n\n* 1/e表示e关于phi的逆元，表达式x =（1 / e）mod N也写为x = e -1 mod N，并且x是满足xe≡1（mod N）的任何整数。\n* 使用在Zn中的唯一值x，数字集合{0,1,2,...,n-1}\n* 解密给定的C可以按照下面的步骤\n\n```\nm1 = c^dP mod p\nm2 = c^dQ mod q\nh = qInv.(m1 - m2) mod p\nm = m2 + h.q\n```\n\n* 可以发现，dp,dq,qInv,p,q正好是私钥中的内容。\n\n# 中国剩余定理-特例\n\n```\n定理：令p,q为不同的素数，n=p*q对于任何对(x1,x2)，其中0≤x 1 <p和0≤x 2 <q\n\t存在唯一的数x，其中0≤x <n\n    \t  x 1 = x mod p，\n  \t\t  x 2 = x mod q。\n```\n\n* 任何整数x（0≤x <n）都可以用其CRT表示形式（x 1，x 2）唯一表示。\n\n# 欧拉定理与欧拉公式\n\n```\n如果n是一个正整数，并且a与n互质即gcd(a,n)=1，则a^φ(n) ≡ 1 (mod n)\nφ(n) 是欧拉函数\n欧拉函数是求小于等于n的数中与n互质的数的数目  \n即欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目\n或者说欧拉函数是求 1到n-1 中 与n互质的数 的数目\n \n如果n是质数\n那么1到n-1所有数都是与n互质的，\n所以φ(n) = n-1\n如果n是合数。。。自己算吧\n例如φ(8)=4，因为1,3,5,7均和8互质\n```","slug":"将CRT-中国剩余定理-与RSA结合","published":1,"updated":"2020-09-25T09:11:11.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18m002bvcu93iu39n88","content":"<ul>\n<li>使用中国剩余定理来加快RSA的运算速度，使用Zn中数字的CRT表示法，使用N的素因子预先计算出的三个额外值，来更有效的执行四次幂运算。</li>\n</ul>\n<h1 id=\"在RSA中的一些运算\"><a href=\"#在RSA中的一些运算\" class=\"headerlink\" title=\"在RSA中的一些运算\"></a>在RSA中的一些运算</h1><ul>\n<li>正常的RSA解密，使用私钥(n,d)进行密文解密（或生成签名），不过在运算过程中，我们需要先通过公钥指数e求得私钥指数d，并不如e那么方便，所以可以选择一个值尽可能少的“1”位。</li>\n<li>对于k位的模数N，私钥质数也有类似的长度，大约一半是“1”。计算指数的时间与k^3成正比,所以需要其他的计算。</li>\n<li>基础解密：m=c^d mod n</li>\n</ul>\n<ul>\n<li>1、给定p、q并用p&gt;q预计算几个值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp&#x3D;(1&#x2F;e) mod (p-1)</span><br><span class=\"line\">dq&#x3D;(1&#x2F;e) mod (q-1)</span><br><span class=\"line\">qInv&#x3D;(1&#x2F;q) mod p</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1/e表示e关于phi的逆元，表达式x =（1 / e）mod N也写为x = e -1 mod N，并且x是满足xe≡1（mod N）的任何整数。</li>\n<li>使用在Zn中的唯一值x，数字集合{0,1,2,…,n-1}</li>\n<li>解密给定的C可以按照下面的步骤</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m1 &#x3D; c^dP mod p</span><br><span class=\"line\">m2 &#x3D; c^dQ mod q</span><br><span class=\"line\">h &#x3D; qInv.(m1 - m2) mod p</span><br><span class=\"line\">m &#x3D; m2 + h.q</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以发现，dp,dq,qInv,p,q正好是私钥中的内容。</li>\n</ul>\n<h1 id=\"中国剩余定理-特例\"><a href=\"#中国剩余定理-特例\" class=\"headerlink\" title=\"中国剩余定理-特例\"></a>中国剩余定理-特例</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定理：令p,q为不同的素数，n&#x3D;p*q对于任何对(x1,x2)，其中0≤x 1 &lt;p和0≤x 2 &lt;q</span><br><span class=\"line\">\t存在唯一的数x，其中0≤x &lt;n</span><br><span class=\"line\">    \t  x 1 &#x3D; x mod p，</span><br><span class=\"line\">  \t\t  x 2 &#x3D; x mod q。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任何整数x（0≤x &lt;n）都可以用其CRT表示形式（x 1，x 2）唯一表示。</li>\n</ul>\n<h1 id=\"欧拉定理与欧拉公式\"><a href=\"#欧拉定理与欧拉公式\" class=\"headerlink\" title=\"欧拉定理与欧拉公式\"></a>欧拉定理与欧拉公式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果n是一个正整数，并且a与n互质即gcd(a,n)&#x3D;1，则a^φ(n) ≡ 1 (mod n)</span><br><span class=\"line\">φ(n) 是欧拉函数</span><br><span class=\"line\">欧拉函数是求小于等于n的数中与n互质的数的数目  </span><br><span class=\"line\">即欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目</span><br><span class=\"line\">或者说欧拉函数是求 1到n-1 中 与n互质的数 的数目</span><br><span class=\"line\"> </span><br><span class=\"line\">如果n是质数</span><br><span class=\"line\">那么1到n-1所有数都是与n互质的，</span><br><span class=\"line\">所以φ(n) &#x3D; n-1</span><br><span class=\"line\">如果n是合数。。。自己算吧</span><br><span class=\"line\">例如φ(8)&#x3D;4，因为1,3,5,7均和8互质</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>使用中国剩余定理来加快RSA的运算速度，使用Zn中数字的CRT表示法，使用N的素因子预先计算出的三个额外值，来更有效的执行四次幂运算。</li>\n</ul>\n<h1 id=\"在RSA中的一些运算\"><a href=\"#在RSA中的一些运算\" class=\"headerlink\" title=\"在RSA中的一些运算\"></a>在RSA中的一些运算</h1><ul>\n<li>正常的RSA解密，使用私钥(n,d)进行密文解密（或生成签名），不过在运算过程中，我们需要先通过公钥指数e求得私钥指数d，并不如e那么方便，所以可以选择一个值尽可能少的“1”位。</li>\n<li>对于k位的模数N，私钥质数也有类似的长度，大约一半是“1”。计算指数的时间与k^3成正比,所以需要其他的计算。</li>\n<li>基础解密：m=c^d mod n</li>\n</ul>\n<ul>\n<li>1、给定p、q并用p&gt;q预计算几个值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp&#x3D;(1&#x2F;e) mod (p-1)</span><br><span class=\"line\">dq&#x3D;(1&#x2F;e) mod (q-1)</span><br><span class=\"line\">qInv&#x3D;(1&#x2F;q) mod p</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1/e表示e关于phi的逆元，表达式x =（1 / e）mod N也写为x = e -1 mod N，并且x是满足xe≡1（mod N）的任何整数。</li>\n<li>使用在Zn中的唯一值x，数字集合{0,1,2,…,n-1}</li>\n<li>解密给定的C可以按照下面的步骤</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m1 &#x3D; c^dP mod p</span><br><span class=\"line\">m2 &#x3D; c^dQ mod q</span><br><span class=\"line\">h &#x3D; qInv.(m1 - m2) mod p</span><br><span class=\"line\">m &#x3D; m2 + h.q</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以发现，dp,dq,qInv,p,q正好是私钥中的内容。</li>\n</ul>\n<h1 id=\"中国剩余定理-特例\"><a href=\"#中国剩余定理-特例\" class=\"headerlink\" title=\"中国剩余定理-特例\"></a>中国剩余定理-特例</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定理：令p,q为不同的素数，n&#x3D;p*q对于任何对(x1,x2)，其中0≤x 1 &lt;p和0≤x 2 &lt;q</span><br><span class=\"line\">\t存在唯一的数x，其中0≤x &lt;n</span><br><span class=\"line\">    \t  x 1 &#x3D; x mod p，</span><br><span class=\"line\">  \t\t  x 2 &#x3D; x mod q。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任何整数x（0≤x &lt;n）都可以用其CRT表示形式（x 1，x 2）唯一表示。</li>\n</ul>\n<h1 id=\"欧拉定理与欧拉公式\"><a href=\"#欧拉定理与欧拉公式\" class=\"headerlink\" title=\"欧拉定理与欧拉公式\"></a>欧拉定理与欧拉公式</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果n是一个正整数，并且a与n互质即gcd(a,n)&#x3D;1，则a^φ(n) ≡ 1 (mod n)</span><br><span class=\"line\">φ(n) 是欧拉函数</span><br><span class=\"line\">欧拉函数是求小于等于n的数中与n互质的数的数目  </span><br><span class=\"line\">即欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目</span><br><span class=\"line\">或者说欧拉函数是求 1到n-1 中 与n互质的数 的数目</span><br><span class=\"line\"> </span><br><span class=\"line\">如果n是质数</span><br><span class=\"line\">那么1到n-1所有数都是与n互质的，</span><br><span class=\"line\">所以φ(n) &#x3D; n-1</span><br><span class=\"line\">如果n是合数。。。自己算吧</span><br><span class=\"line\">例如φ(8)&#x3D;4，因为1,3,5,7均和8互质</span><br></pre></td></tr></table></figure>"},{"title":"rsa当e=2且不互素时处理方式","author":"人生若只如初见","date":"2020-06-23T10:10:00.000Z","_content":"# 整个过程简化为6步\n* 1、运用广义Euclid除法，求出整数s和t使得sp+tq=1\n* 2、计算u≡c**((p+1)/4) (mod p)\n* 3、计算v≡c**((q+1)/4) (mod q)\n* 4、计算x≡(tqu+spv)  (mod n)\n* 5、计算y≡(tqu-spv)  (mod n)\n* 6、同余式x**2≡c (mod n) 的四个根是x,-x(mod n),y,-y(mod n)\n\n\n\n*  其中一个根即为密文\n\n```\n# -*-coding: utf-8 -*-  \nimport gmpy  \n\ndef n2s(num):  \n    t = hex(num)[2:]  \n    if len(t) % 2 == 1:  \n        return ('0'+t).decode('hex')  \n    return t.decode('hex')  \n\nc = int(open('flag.enc','rb').read().encode('hex'),16)  # 密文 c  \np = 275127860351348928173285174381581152299             # 分解后的素数 p  \nq = 319576316814478949870590164193048041239             # 分解后的素数 q  \nn = p*q                                                 # 公钥 N  \n\n# 根据中国剩余定理求解相应明文  \nr = pow(c,(p+1)/4,p)  \ns = pow(c,(q+1)/4,q)  \na = gmpy.invert(p,q)  \nb = gmpy.invert(q,p)  \nx =(a*p*s+b*q*r)%n  \ny =(a*p*s-b*q*r)%n  \n\n# 打印明文  \nprint n2s(x%n)  \nprint n2s((-x)%n)  \nprint n2s(y%n)  \nprint n2s((-y)%n)\n```","source":"_posts/rsa当e-2且不互素时处理方式.md","raw":"title: rsa当e=2且不互素时处理方式\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - rsa\ndate: 2020-06-23 18:10:00\n---\n# 整个过程简化为6步\n* 1、运用广义Euclid除法，求出整数s和t使得sp+tq=1\n* 2、计算u≡c**((p+1)/4) (mod p)\n* 3、计算v≡c**((q+1)/4) (mod q)\n* 4、计算x≡(tqu+spv)  (mod n)\n* 5、计算y≡(tqu-spv)  (mod n)\n* 6、同余式x**2≡c (mod n) 的四个根是x,-x(mod n),y,-y(mod n)\n\n\n\n*  其中一个根即为密文\n\n```\n# -*-coding: utf-8 -*-  \nimport gmpy  \n\ndef n2s(num):  \n    t = hex(num)[2:]  \n    if len(t) % 2 == 1:  \n        return ('0'+t).decode('hex')  \n    return t.decode('hex')  \n\nc = int(open('flag.enc','rb').read().encode('hex'),16)  # 密文 c  \np = 275127860351348928173285174381581152299             # 分解后的素数 p  \nq = 319576316814478949870590164193048041239             # 分解后的素数 q  \nn = p*q                                                 # 公钥 N  \n\n# 根据中国剩余定理求解相应明文  \nr = pow(c,(p+1)/4,p)  \ns = pow(c,(q+1)/4,q)  \na = gmpy.invert(p,q)  \nb = gmpy.invert(q,p)  \nx =(a*p*s+b*q*r)%n  \ny =(a*p*s-b*q*r)%n  \n\n# 打印明文  \nprint n2s(x%n)  \nprint n2s((-x)%n)  \nprint n2s(y%n)  \nprint n2s((-y)%n)\n```","slug":"rsa当e-2且不互素时处理方式","published":1,"updated":"2020-06-23T10:35:18.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18n002evcu9gl93gakf","content":"<h1 id=\"整个过程简化为6步\"><a href=\"#整个过程简化为6步\" class=\"headerlink\" title=\"整个过程简化为6步\"></a>整个过程简化为6步</h1><ul>\n<li>1、运用广义Euclid除法，求出整数s和t使得sp+tq=1</li>\n<li>2、计算u≡c**((p+1)/4) (mod p)</li>\n<li>3、计算v≡c**((q+1)/4) (mod q)</li>\n<li>4、计算x≡(tqu+spv)  (mod n)</li>\n<li>5、计算y≡(tqu-spv)  (mod n)</li>\n<li>6、同余式x**2≡c (mod n) 的四个根是x,-x(mod n),y,-y(mod n)</li>\n</ul>\n<ul>\n<li>其中一个根即为密文</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -*-coding: utf-8 -*-  </span><br><span class=\"line\">import gmpy  </span><br><span class=\"line\"></span><br><span class=\"line\">def n2s(num):  </span><br><span class=\"line\">    t &#x3D; hex(num)[2:]  </span><br><span class=\"line\">    if len(t) % 2 &#x3D;&#x3D; 1:  </span><br><span class=\"line\">        return (&#39;0&#39;+t).decode(&#39;hex&#39;)  </span><br><span class=\"line\">    return t.decode(&#39;hex&#39;)  </span><br><span class=\"line\"></span><br><span class=\"line\">c &#x3D; int(open(&#39;flag.enc&#39;,&#39;rb&#39;).read().encode(&#39;hex&#39;),16)  # 密文 c  </span><br><span class=\"line\">p &#x3D; 275127860351348928173285174381581152299             # 分解后的素数 p  </span><br><span class=\"line\">q &#x3D; 319576316814478949870590164193048041239             # 分解后的素数 q  </span><br><span class=\"line\">n &#x3D; p*q                                                 # 公钥 N  </span><br><span class=\"line\"></span><br><span class=\"line\"># 根据中国剩余定理求解相应明文  </span><br><span class=\"line\">r &#x3D; pow(c,(p+1)&#x2F;4,p)  </span><br><span class=\"line\">s &#x3D; pow(c,(q+1)&#x2F;4,q)  </span><br><span class=\"line\">a &#x3D; gmpy.invert(p,q)  </span><br><span class=\"line\">b &#x3D; gmpy.invert(q,p)  </span><br><span class=\"line\">x &#x3D;(a*p*s+b*q*r)%n  </span><br><span class=\"line\">y &#x3D;(a*p*s-b*q*r)%n  </span><br><span class=\"line\"></span><br><span class=\"line\"># 打印明文  </span><br><span class=\"line\">print n2s(x%n)  </span><br><span class=\"line\">print n2s((-x)%n)  </span><br><span class=\"line\">print n2s(y%n)  </span><br><span class=\"line\">print n2s((-y)%n)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"整个过程简化为6步\"><a href=\"#整个过程简化为6步\" class=\"headerlink\" title=\"整个过程简化为6步\"></a>整个过程简化为6步</h1><ul>\n<li>1、运用广义Euclid除法，求出整数s和t使得sp+tq=1</li>\n<li>2、计算u≡c**((p+1)/4) (mod p)</li>\n<li>3、计算v≡c**((q+1)/4) (mod q)</li>\n<li>4、计算x≡(tqu+spv)  (mod n)</li>\n<li>5、计算y≡(tqu-spv)  (mod n)</li>\n<li>6、同余式x**2≡c (mod n) 的四个根是x,-x(mod n),y,-y(mod n)</li>\n</ul>\n<ul>\n<li>其中一个根即为密文</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -*-coding: utf-8 -*-  </span><br><span class=\"line\">import gmpy  </span><br><span class=\"line\"></span><br><span class=\"line\">def n2s(num):  </span><br><span class=\"line\">    t &#x3D; hex(num)[2:]  </span><br><span class=\"line\">    if len(t) % 2 &#x3D;&#x3D; 1:  </span><br><span class=\"line\">        return (&#39;0&#39;+t).decode(&#39;hex&#39;)  </span><br><span class=\"line\">    return t.decode(&#39;hex&#39;)  </span><br><span class=\"line\"></span><br><span class=\"line\">c &#x3D; int(open(&#39;flag.enc&#39;,&#39;rb&#39;).read().encode(&#39;hex&#39;),16)  # 密文 c  </span><br><span class=\"line\">p &#x3D; 275127860351348928173285174381581152299             # 分解后的素数 p  </span><br><span class=\"line\">q &#x3D; 319576316814478949870590164193048041239             # 分解后的素数 q  </span><br><span class=\"line\">n &#x3D; p*q                                                 # 公钥 N  </span><br><span class=\"line\"></span><br><span class=\"line\"># 根据中国剩余定理求解相应明文  </span><br><span class=\"line\">r &#x3D; pow(c,(p+1)&#x2F;4,p)  </span><br><span class=\"line\">s &#x3D; pow(c,(q+1)&#x2F;4,q)  </span><br><span class=\"line\">a &#x3D; gmpy.invert(p,q)  </span><br><span class=\"line\">b &#x3D; gmpy.invert(q,p)  </span><br><span class=\"line\">x &#x3D;(a*p*s+b*q*r)%n  </span><br><span class=\"line\">y &#x3D;(a*p*s-b*q*r)%n  </span><br><span class=\"line\"></span><br><span class=\"line\"># 打印明文  </span><br><span class=\"line\">print n2s(x%n)  </span><br><span class=\"line\">print n2s((-x)%n)  </span><br><span class=\"line\">print n2s(y%n)  </span><br><span class=\"line\">print n2s((-y)%n)</span><br></pre></td></tr></table></figure>"},{"title":"密码学编码(一)ASCII编码","author":"人生若只如初见","date":"2020-05-27T09:56:00.000Z","_content":"* 我的密码学入门是从编码开始，逐步认识到各种密码类型，我会逐步总结。\n* 今天先介绍ASCII，base系列等编码\n\n# ASCII\n\n* 计算机的最早发明者是美国人，所以他们首要面临的问题就是如何让机器能够将他们的文字，也就是拉丁字母与二进制相对应，然而在计算机出现早期，各个公司都创建了属于自己的一套编码规则，这给不同计算机之间的数据交换带来了极大困难。\n* ASCII的标准版本第一次发布于1967年，迄今为止共收录了128个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是1234567890）、标点符号（,.!等）、特殊符号（@#$%^&等）以及一些具有控制功能的字符（往往不会显示出来）。\n* 在ASCII编码中，大写字母、小写字母和阿拉伯数字都是连续分布的。\n\n* 连续分布的ASCII编码为程序员带来了极大方便，例如：当寻找某个字母的位置时，只需要记住A的ASCII编码，然后加上两者之间的间隔。\n\n![](/images/pasted-7.png)\n* 扩展ASCII打印字符\n* 扩展的ASCII字符满足了对更多字符的需求.增加了128个字符.\n* 即使有了这些更多的字符,许多语言还是包含无法压缩到256个字符中的符号.因此,出现了一些ASCII的变体来囊括地区性字符和符号.\n\n![](/images/pasted-8.png)\n* 在平时遇到大批量的ASCII编码需要转换时，可进入下列在线网站 ：[ASCII编码](https://www.qqxiuzi.cn/bianma/ascii.htm)\n\n* 除此以外，还可以将二进制，十六进制直接转换为ASCII编码（本质上是将其他进制转换为十进制，再将十进制与ASCII编码一一对应）\n\n* 下面附上python3脚本（将十六进制转换为ASCII）\n\n```\nfrom binascii import a2b_hex\n\nh =input()\np1 = bytes(h,'utf-8')\np2 = a2b_hex(p1)\nprint(p2.decode())\n```\n* 下一节我们讲解base系列编码\n","source":"_posts/密码学编码-一-ASCII编码.md","raw":"title: 密码学编码(一)ASCII编码\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 编码\ndate: 2020-05-27 17:56:00\n---\n* 我的密码学入门是从编码开始，逐步认识到各种密码类型，我会逐步总结。\n* 今天先介绍ASCII，base系列等编码\n\n# ASCII\n\n* 计算机的最早发明者是美国人，所以他们首要面临的问题就是如何让机器能够将他们的文字，也就是拉丁字母与二进制相对应，然而在计算机出现早期，各个公司都创建了属于自己的一套编码规则，这给不同计算机之间的数据交换带来了极大困难。\n* ASCII的标准版本第一次发布于1967年，迄今为止共收录了128个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是1234567890）、标点符号（,.!等）、特殊符号（@#$%^&等）以及一些具有控制功能的字符（往往不会显示出来）。\n* 在ASCII编码中，大写字母、小写字母和阿拉伯数字都是连续分布的。\n\n* 连续分布的ASCII编码为程序员带来了极大方便，例如：当寻找某个字母的位置时，只需要记住A的ASCII编码，然后加上两者之间的间隔。\n\n![](/images/pasted-7.png)\n* 扩展ASCII打印字符\n* 扩展的ASCII字符满足了对更多字符的需求.增加了128个字符.\n* 即使有了这些更多的字符,许多语言还是包含无法压缩到256个字符中的符号.因此,出现了一些ASCII的变体来囊括地区性字符和符号.\n\n![](/images/pasted-8.png)\n* 在平时遇到大批量的ASCII编码需要转换时，可进入下列在线网站 ：[ASCII编码](https://www.qqxiuzi.cn/bianma/ascii.htm)\n\n* 除此以外，还可以将二进制，十六进制直接转换为ASCII编码（本质上是将其他进制转换为十进制，再将十进制与ASCII编码一一对应）\n\n* 下面附上python3脚本（将十六进制转换为ASCII）\n\n```\nfrom binascii import a2b_hex\n\nh =input()\np1 = bytes(h,'utf-8')\np2 = a2b_hex(p1)\nprint(p2.decode())\n```\n* 下一节我们讲解base系列编码\n","slug":"密码学编码-一-ASCII编码","published":1,"updated":"2020-05-27T09:59:26.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18o002gvcu9e1l223u2","content":"<ul>\n<li>我的密码学入门是从编码开始，逐步认识到各种密码类型，我会逐步总结。</li>\n<li>今天先介绍ASCII，base系列等编码</li>\n</ul>\n<h1 id=\"ASCII\"><a href=\"#ASCII\" class=\"headerlink\" title=\"ASCII\"></a>ASCII</h1><ul>\n<li><p>计算机的最早发明者是美国人，所以他们首要面临的问题就是如何让机器能够将他们的文字，也就是拉丁字母与二进制相对应，然而在计算机出现早期，各个公司都创建了属于自己的一套编码规则，这给不同计算机之间的数据交换带来了极大困难。</p>\n</li>\n<li><p>ASCII的标准版本第一次发布于1967年，迄今为止共收录了128个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是1234567890）、标点符号（,.!等）、特殊符号（@#$%^&amp;等）以及一些具有控制功能的字符（往往不会显示出来）。</p>\n</li>\n<li><p>在ASCII编码中，大写字母、小写字母和阿拉伯数字都是连续分布的。</p>\n</li>\n<li><p>连续分布的ASCII编码为程序员带来了极大方便，例如：当寻找某个字母的位置时，只需要记住A的ASCII编码，然后加上两者之间的间隔。</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-7.png\" alt=\"\"></p>\n<ul>\n<li>扩展ASCII打印字符</li>\n<li>扩展的ASCII字符满足了对更多字符的需求.增加了128个字符.</li>\n<li>即使有了这些更多的字符,许多语言还是包含无法压缩到256个字符中的符号.因此,出现了一些ASCII的变体来囊括地区性字符和符号.</li>\n</ul>\n<p><img src=\"/images/pasted-8.png\" alt=\"\"></p>\n<ul>\n<li><p>在平时遇到大批量的ASCII编码需要转换时，可进入下列在线网站 ：<a href=\"https://www.qqxiuzi.cn/bianma/ascii.htm\" target=\"_blank\" rel=\"noopener\">ASCII编码</a></p>\n</li>\n<li><p>除此以外，还可以将二进制，十六进制直接转换为ASCII编码（本质上是将其他进制转换为十进制，再将十进制与ASCII编码一一对应）</p>\n</li>\n<li><p>下面附上python3脚本（将十六进制转换为ASCII）</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from binascii import a2b_hex</span><br><span class=\"line\"></span><br><span class=\"line\">h &#x3D;input()</span><br><span class=\"line\">p1 &#x3D; bytes(h,&#39;utf-8&#39;)</span><br><span class=\"line\">p2 &#x3D; a2b_hex(p1)</span><br><span class=\"line\">print(p2.decode())</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下一节我们讲解base系列编码</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>我的密码学入门是从编码开始，逐步认识到各种密码类型，我会逐步总结。</li>\n<li>今天先介绍ASCII，base系列等编码</li>\n</ul>\n<h1 id=\"ASCII\"><a href=\"#ASCII\" class=\"headerlink\" title=\"ASCII\"></a>ASCII</h1><ul>\n<li><p>计算机的最早发明者是美国人，所以他们首要面临的问题就是如何让机器能够将他们的文字，也就是拉丁字母与二进制相对应，然而在计算机出现早期，各个公司都创建了属于自己的一套编码规则，这给不同计算机之间的数据交换带来了极大困难。</p>\n</li>\n<li><p>ASCII的标准版本第一次发布于1967年，迄今为止共收录了128个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是1234567890）、标点符号（,.!等）、特殊符号（@#$%^&amp;等）以及一些具有控制功能的字符（往往不会显示出来）。</p>\n</li>\n<li><p>在ASCII编码中，大写字母、小写字母和阿拉伯数字都是连续分布的。</p>\n</li>\n<li><p>连续分布的ASCII编码为程序员带来了极大方便，例如：当寻找某个字母的位置时，只需要记住A的ASCII编码，然后加上两者之间的间隔。</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-7.png\" alt=\"\"></p>\n<ul>\n<li>扩展ASCII打印字符</li>\n<li>扩展的ASCII字符满足了对更多字符的需求.增加了128个字符.</li>\n<li>即使有了这些更多的字符,许多语言还是包含无法压缩到256个字符中的符号.因此,出现了一些ASCII的变体来囊括地区性字符和符号.</li>\n</ul>\n<p><img src=\"/images/pasted-8.png\" alt=\"\"></p>\n<ul>\n<li><p>在平时遇到大批量的ASCII编码需要转换时，可进入下列在线网站 ：<a href=\"https://www.qqxiuzi.cn/bianma/ascii.htm\" target=\"_blank\" rel=\"noopener\">ASCII编码</a></p>\n</li>\n<li><p>除此以外，还可以将二进制，十六进制直接转换为ASCII编码（本质上是将其他进制转换为十进制，再将十进制与ASCII编码一一对应）</p>\n</li>\n<li><p>下面附上python3脚本（将十六进制转换为ASCII）</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from binascii import a2b_hex</span><br><span class=\"line\"></span><br><span class=\"line\">h &#x3D;input()</span><br><span class=\"line\">p1 &#x3D; bytes(h,&#39;utf-8&#39;)</span><br><span class=\"line\">p2 &#x3D; a2b_hex(p1)</span><br><span class=\"line\">print(p2.decode())</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下一节我们讲解base系列编码</li>\n</ul>\n"},{"title":"密码学编码(二)base编码","author":"人生若只如初见","date":"2020-05-27T07:23:00.000Z","_content":"* 我们接着上一节。\n* 上一节我们讲述了ASCII编码，接下来的base系列编码与ASCII之间联系非常紧密。好，我们继续讲解。\n\n* base系列编码：\n* ASCII 是用128（2^8）个字符，对二进制数据进行编码的方式，\n* base64编码是用64（2^6）个字符，对二进制数据进行编码的方式 \n* base32就是用32（2^5）个字符，对二进制数据进行编码的方式\n* base16就是用16（2^4）个字符，对二进制数据进行编码的方式\n\n* 这里我们可以清楚的看到，base系列编码之间的不同，在于用于编码的字符数量的多少。\n\n* 那我们如何直接区分出base16、32、64编码呢？\n* 那可以从编码字符的数量方面入手，对于base16，用于编码的字符只有：1-9，A-F ,只有简单的15个字符。对于base32而言，编码字符有了明显改变，由base16的类型转变为了A-Z,2-7。作为base系列中最完善的base64编码，是在base32的基础上，增加了”a-z,0,1,8,9,+,/“，以及特殊填充字符”=”\n* Base-64编码将一个8位子节序列拆散为6位的片段，并为每个6位的片短分配一个字符，这个字符是Base-64字母表中的64个字符之一。\n\n* 编码解码过程：\n* base系列编码过程都类似，所以我们用base64来说明\n# base64填充\n* base64编码收到一个8位字节序列，将这个二进制序列流划分成6位的块。二进制序列有时不能正好平均地分为6位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为24的倍数(6和8的最小公倍数)。\n* 对已填充的二进制进行编码时，任何完全填充(不包括原始数组中的位)的6位组都有特殊的第65个符号”=”表示。如果6位组是部分填充的，就将填充位设置为0.\n* 下面会写一个填充实例。初始输入字符串为”a:a”为3个字节(24位)。24是6和8的倍数，因此按照上面给出的例子计算。无需填充就会得到base64编码为”YTph”。\n* 然而，再增加一个字符，输入字符串变为”a:aa”,转换为二进制就会有32位长。而6和8的下一个公倍数为48.因此要添加16为的填充码。填充的前4位是与数据位混合在一起的。得到的6位组01xxxx，会被当作010000、十进制中的16，或者base64编码的Q来处理。剩下的两个6位组都是填充码，用=来表示。\n\n```\na:a -- 011000 010011 101001 100001 -- YTph\n\na:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ==\n\na:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE=\n\na:aaaa -- 011000 010011 101001 100001 011000 010110 000101 1000001 -- YTphYWFh\n```\n* 特别注意，Base64编码后的文本的长度总是4的倍数，但是如果再加上1到2个=不就不是4的倍数了吗？\n* 所以并不是先编码，再加上1到2个=，而是编码之后，把最后的1到2个字符（这个字符肯定是A）替换成=\n* 改进：\n\n```\n1.  标准Base64里是包含 + 和 / 的，在URL里不能直接作为参数，所以出现一种 “url safe” 的Base64编码，其实就是把 + 和 / 替换成 - 和 _ 。\n2.  同样的，=也会被误解，所以编码后干脆去掉=，解码时，自动添加一定数量的等号，使得其长度为4的倍数即可正常解码了。\n```\n\n* 对于base系列的编码解码，可在下面的在线网站进行解码： [base16，base32,base64编码在线](https://www.qqxiuzi.cn/bianma/base.php)\n* base16相当于是16进制，可以直接16进制转字符串\n* base64编码图\n\n\n![](/images/pasted-0.png)\n\n## c语言实现base64：\n\n\n* base64编码、解码实现\n* C语言源代码\n\n\n* 使用说明：\n* 命令行参数说明：若有“-d”参数，则为base64解码，否则为base64编码。\n* 若有“-o”参数，后接文件名，则输出到标准输出文件。\n* 输入来自标准输入stdin，输出为标准输出stdout。可重定向输入输出流。\n\n* base64编码：输入任意二进制流，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出纯文本的base64编码。\n\n* base64解码：输入纯文本的base64编码，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出原来的二进制流。\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <io.h>\n#include <fcntl.h>\n#include <stdbool.h>\n\n#ifndef MAX_PATH\n#define MAX_PATH 256\n#endif\n\nconst char * base64char = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nchar * base64_encode( const unsigned char * bindata, char * base64, int binlength )\n{\n    int i, j;\n    unsigned char current;\n\n    for ( i = 0, j = 0 ; i < binlength ; i += 3 )\n    {\n        current = (bindata[i] >> 2) ;\n        current &= (unsigned char)0x3F;\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i] << 4 ) ) & ( (unsigned char)0x30 ) ;\n        if ( i + 1 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+1] >> 4) ) & ( (unsigned char) 0x0F );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i+1] << 2) ) & ( (unsigned char)0x3C ) ;\n        if ( i + 2 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+2] >> 6) ) & ( (unsigned char) 0x03 );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)bindata[i+2] ) & ( (unsigned char)0x3F ) ;\n        base64[j++] = base64char[(int)current];\n    }\n    base64[j] = '\\0';\n    return base64;\n}\n\nint base64_decode( const char * base64, unsigned char * bindata )\n{\n    int i, j;\n    unsigned char k;\n    unsigned char temp[4];\n    for ( i = 0, j = 0; base64[i] != '\\0' ; i += 4 )\n    {\n        memset( temp, 0xFF, sizeof(temp) );\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i] )\n                temp[0]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+1] )\n                temp[1]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+2] )\n                temp[2]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+3] )\n                temp[3]= k;\n        }\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[0] << 2))&0xFC)) |\n                ((unsigned char)((unsigned char)(temp[1]>>4)&0x03));\n        if ( base64[i+2] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[1] << 4))&0xF0)) |\n                ((unsigned char)((unsigned char)(temp[2]>>2)&0x0F));\n        if ( base64[i+3] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[2] << 6))&0xF0)) |\n                ((unsigned char)(temp[3]&0x3F));\n    }\n    return j;\n}\n\nvoid encode(FILE * fp_in, FILE * fp_out)\n{\n    unsigned char bindata[2050];\n    char base64[4096];\n    size_t bytes;\n    while ( !feof( fp_in ) )\n    {\n        bytes = fread( bindata, 1, 2049, fp_in );\n        base64_encode( bindata, base64, bytes );\n        fprintf( fp_out, \"%s\", base64 );\n    }\n}\n\nvoid decode(FILE * fp_in, FILE * fp_out)\n{\n    int i;\n    unsigned char bindata[2050];\n    char base64[4096];\n    size_t bytes;\n    while ( !feof( fp_in ) )\n    {\n        for ( i = 0 ; i < 2048 ; i ++ )\n        {\n            base64[i] = fgetc(fp_in);\n            if ( base64[i] == EOF )\n                break;\n            else if ( base64[i] == '\\n' || base64[i] == '\\r' )\n                i --;\n        }\n        bytes = base64_decode( base64, bindata );\n        fwrite( bindata, bytes, 1, fp_out );\n    }\n}\n\nvoid help(const char * filepath)\n{\n    fprintf( stderr, \"Usage: %s [-d] [input_filename] [-o output_filepath]\\n\", filepath );\n    fprintf( stderr, \"\\t-d\\tdecode data\\n\" );\n    fprintf( stderr, \"\\t-o\\toutput filepath\\n\\n\" );\n}\n\nint main(int argc, char * argv[])\n{\n    FILE * fp_input = NULL;\n    FILE * fp_output = NULL;\n    bool isencode = true;\n    bool needHelp = false;\n    int opt = 0;\n    char input_filename[MAX_PATH] = \"\";\n    char output_filename[MAX_PATH] = \"\";\n\n    opterr = 0;\n    while ( (opt = getopt(argc, argv, \"hdo:\")) != -1 )\n    {\n        switch(opt)\n        {\n        case 'd':\n            isencode = false;\n            break;\n        case 'o':\n            strncpy(output_filename, optarg, sizeof(output_filename));\n            output_filename[sizeof(output_filename)-1] = '\\0';\n            break;\n        case 'h':\n            needHelp = true;\n            break;\n        default:\n            fprintf(stderr, \"%s: invalid option -- %c\\n\", argv[0], optopt);\n            needHelp = true;\n            break;\n        }\n    }\n    if ( optind < argc )\n    {\n        strncpy(input_filename, argv[optind], sizeof(input_filename));\n        input_filename[sizeof(input_filename)-1] = '\\0';\n    }\n\n    if (needHelp)\n    {\n        help(argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    if ( !strcmp(input_filename, \"\") )\n    {\n        fp_input = stdin;\n        if (isencode)\n            _setmode( _fileno(stdin), _O_BINARY );\n    }\n    else\n    {\n        if (isencode)\n            fp_input = fopen(input_filename, \"rb\");\n        else\n            fp_input = fopen(input_filename, \"r\");\n    }\n    if ( fp_input == NULL )\n    {\n        fprintf(stderr, \"Input file open error\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if ( !strcmp(output_filename, \"\") )\n    {\n        fp_output = stdout;\n        if (!isencode)\n            _setmode( _fileno(stdout), _O_BINARY );\n    }\n    else\n    {\n        if (isencode)\n            fp_output = fopen(output_filename, \"w\");\n        else\n            fp_output = fopen(output_filename, \"wb\");\n    }\n    if ( fp_output == NULL )\n    {\n        fclose(fp_input);\n        fp_input = NULL;\n        fprintf(stderr, \"Output file open error\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if (isencode)\n        encode(fp_input, fp_output);\n    else\n        decode(fp_input, fp_output);\n    fclose(fp_input);\n    fclose(fp_output);\n    fp_input = fp_output = NULL;\n    return EXIT_SUCCESS;\n}\n```\n* 除了以上的三种编码外，base系列还有其他的几种\n* base58,base85,base91,base92，base128\n\n* base58的应用：比特币、Monero、Ripple、Flickr都在用这个Base58的编码方式\n\n* base58编码表：\n\n![](/images/pasted-1.png)\n* 也就是字符1代表0，字符2代表1,字符3代表2…字符z代表57。然后回一下辗转相除法。\n* 如要将1234转换为58进制；\n* 第一步：1234除于58，商21，余数为16，查表得H\n* 第二步：21除于58，商0，余数为21，查表得N\n* 所以得到base58编码为：NH\n* 如果待转换的数前面有0怎么办？直接附加编码1来代表，有多少个就附加多少个（编码表中1代表0）\n* 大值思路为：\n\n```\n    将数据转换为大整数x，\n    依次将（x % 58）的值表示的编码添加到输出字符串末尾；\n    令x = ( x / 58 );\n    重复2-3，直到x等于0；\n    将数据前所有0的编码（即“1”）添加到输出字符串末尾；\n    将输出字符串反转，即为Base58编码字符串。\n    由于编码前数据可以视为256进制编码数据，所以转换为58进制编码数据后，数据长度为变长。\n```\n* 即：\n* Base58的本质就是把256进制的值转成58进制的值。\n* 所以它在编码时不需要考虑补\\x00的问题，直接转换即可。\n* 把字节流转成一个256进制的大数，然后不断除以58，保留余数，最后余数当作索引，再倒序，即为转换后的结果。\n\n* 特殊处理：\n* 不同于一个普通的数字转成某个进制，普通数字最高位是不会为0的，而我们要编码的对象是字节流，那么如果字节流的最前面是0（\\x00），那么就会丢失这个信息。所以编码时要特殊记录一下，字节流的开端有多少个\\x00，就直接在转换后的编码前面加上多少个b58Alphabet[0]，同理，解码的时候先记录一下前面的b58Alphabet[0]的个数，然后解码之后再在解码的前面加上相同数量的0x00。\n\n* 假设原长度为Len256，转换为长度为Len58，则：\n* Len58 = Len256 * ( log256 / log58 ) + 1\n* 使用C语言进行base58的加密：\n\n![](/images/pasted-2.png)\n\n![](/images/pasted-3.png)\n\n![](/images/pasted-4.png)\n\n![](/images/pasted-5.png)\n\n![](/images/pasted-6.png)\n\n* 关于base64和base58的总结：\n* 不管是Base64还是Base58，都会造成信息的冗余，使得需要传输的数据量增大，所以不会用在很大的数据上。\n\n```\n    使用Base64最普遍的是URL、邮件文本、图片；\n    相比于Base64直接切割比特的方法（3个比特变为4个比特），Base58采用的大数进制转换，效率更低，所以使用场景的数据更少，例如上面提到的比特币的地址的编码。\n```\n* 下一节我们讲述Unicode编码","source":"_posts/密码学编码-二-base编码.md","raw":"title: 密码学编码(二)base编码\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 编码\ndate: 2020-05-27 15:23:00\n---\n* 我们接着上一节。\n* 上一节我们讲述了ASCII编码，接下来的base系列编码与ASCII之间联系非常紧密。好，我们继续讲解。\n\n* base系列编码：\n* ASCII 是用128（2^8）个字符，对二进制数据进行编码的方式，\n* base64编码是用64（2^6）个字符，对二进制数据进行编码的方式 \n* base32就是用32（2^5）个字符，对二进制数据进行编码的方式\n* base16就是用16（2^4）个字符，对二进制数据进行编码的方式\n\n* 这里我们可以清楚的看到，base系列编码之间的不同，在于用于编码的字符数量的多少。\n\n* 那我们如何直接区分出base16、32、64编码呢？\n* 那可以从编码字符的数量方面入手，对于base16，用于编码的字符只有：1-9，A-F ,只有简单的15个字符。对于base32而言，编码字符有了明显改变，由base16的类型转变为了A-Z,2-7。作为base系列中最完善的base64编码，是在base32的基础上，增加了”a-z,0,1,8,9,+,/“，以及特殊填充字符”=”\n* Base-64编码将一个8位子节序列拆散为6位的片段，并为每个6位的片短分配一个字符，这个字符是Base-64字母表中的64个字符之一。\n\n* 编码解码过程：\n* base系列编码过程都类似，所以我们用base64来说明\n# base64填充\n* base64编码收到一个8位字节序列，将这个二进制序列流划分成6位的块。二进制序列有时不能正好平均地分为6位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为24的倍数(6和8的最小公倍数)。\n* 对已填充的二进制进行编码时，任何完全填充(不包括原始数组中的位)的6位组都有特殊的第65个符号”=”表示。如果6位组是部分填充的，就将填充位设置为0.\n* 下面会写一个填充实例。初始输入字符串为”a:a”为3个字节(24位)。24是6和8的倍数，因此按照上面给出的例子计算。无需填充就会得到base64编码为”YTph”。\n* 然而，再增加一个字符，输入字符串变为”a:aa”,转换为二进制就会有32位长。而6和8的下一个公倍数为48.因此要添加16为的填充码。填充的前4位是与数据位混合在一起的。得到的6位组01xxxx，会被当作010000、十进制中的16，或者base64编码的Q来处理。剩下的两个6位组都是填充码，用=来表示。\n\n```\na:a -- 011000 010011 101001 100001 -- YTph\n\na:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ==\n\na:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE=\n\na:aaaa -- 011000 010011 101001 100001 011000 010110 000101 1000001 -- YTphYWFh\n```\n* 特别注意，Base64编码后的文本的长度总是4的倍数，但是如果再加上1到2个=不就不是4的倍数了吗？\n* 所以并不是先编码，再加上1到2个=，而是编码之后，把最后的1到2个字符（这个字符肯定是A）替换成=\n* 改进：\n\n```\n1.  标准Base64里是包含 + 和 / 的，在URL里不能直接作为参数，所以出现一种 “url safe” 的Base64编码，其实就是把 + 和 / 替换成 - 和 _ 。\n2.  同样的，=也会被误解，所以编码后干脆去掉=，解码时，自动添加一定数量的等号，使得其长度为4的倍数即可正常解码了。\n```\n\n* 对于base系列的编码解码，可在下面的在线网站进行解码： [base16，base32,base64编码在线](https://www.qqxiuzi.cn/bianma/base.php)\n* base16相当于是16进制，可以直接16进制转字符串\n* base64编码图\n\n\n![](/images/pasted-0.png)\n\n## c语言实现base64：\n\n\n* base64编码、解码实现\n* C语言源代码\n\n\n* 使用说明：\n* 命令行参数说明：若有“-d”参数，则为base64解码，否则为base64编码。\n* 若有“-o”参数，后接文件名，则输出到标准输出文件。\n* 输入来自标准输入stdin，输出为标准输出stdout。可重定向输入输出流。\n\n* base64编码：输入任意二进制流，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出纯文本的base64编码。\n\n* base64解码：输入纯文本的base64编码，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出原来的二进制流。\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <io.h>\n#include <fcntl.h>\n#include <stdbool.h>\n\n#ifndef MAX_PATH\n#define MAX_PATH 256\n#endif\n\nconst char * base64char = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nchar * base64_encode( const unsigned char * bindata, char * base64, int binlength )\n{\n    int i, j;\n    unsigned char current;\n\n    for ( i = 0, j = 0 ; i < binlength ; i += 3 )\n    {\n        current = (bindata[i] >> 2) ;\n        current &= (unsigned char)0x3F;\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i] << 4 ) ) & ( (unsigned char)0x30 ) ;\n        if ( i + 1 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+1] >> 4) ) & ( (unsigned char) 0x0F );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i+1] << 2) ) & ( (unsigned char)0x3C ) ;\n        if ( i + 2 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+2] >> 6) ) & ( (unsigned char) 0x03 );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)bindata[i+2] ) & ( (unsigned char)0x3F ) ;\n        base64[j++] = base64char[(int)current];\n    }\n    base64[j] = '\\0';\n    return base64;\n}\n\nint base64_decode( const char * base64, unsigned char * bindata )\n{\n    int i, j;\n    unsigned char k;\n    unsigned char temp[4];\n    for ( i = 0, j = 0; base64[i] != '\\0' ; i += 4 )\n    {\n        memset( temp, 0xFF, sizeof(temp) );\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i] )\n                temp[0]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+1] )\n                temp[1]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+2] )\n                temp[2]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+3] )\n                temp[3]= k;\n        }\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[0] << 2))&0xFC)) |\n                ((unsigned char)((unsigned char)(temp[1]>>4)&0x03));\n        if ( base64[i+2] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[1] << 4))&0xF0)) |\n                ((unsigned char)((unsigned char)(temp[2]>>2)&0x0F));\n        if ( base64[i+3] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[2] << 6))&0xF0)) |\n                ((unsigned char)(temp[3]&0x3F));\n    }\n    return j;\n}\n\nvoid encode(FILE * fp_in, FILE * fp_out)\n{\n    unsigned char bindata[2050];\n    char base64[4096];\n    size_t bytes;\n    while ( !feof( fp_in ) )\n    {\n        bytes = fread( bindata, 1, 2049, fp_in );\n        base64_encode( bindata, base64, bytes );\n        fprintf( fp_out, \"%s\", base64 );\n    }\n}\n\nvoid decode(FILE * fp_in, FILE * fp_out)\n{\n    int i;\n    unsigned char bindata[2050];\n    char base64[4096];\n    size_t bytes;\n    while ( !feof( fp_in ) )\n    {\n        for ( i = 0 ; i < 2048 ; i ++ )\n        {\n            base64[i] = fgetc(fp_in);\n            if ( base64[i] == EOF )\n                break;\n            else if ( base64[i] == '\\n' || base64[i] == '\\r' )\n                i --;\n        }\n        bytes = base64_decode( base64, bindata );\n        fwrite( bindata, bytes, 1, fp_out );\n    }\n}\n\nvoid help(const char * filepath)\n{\n    fprintf( stderr, \"Usage: %s [-d] [input_filename] [-o output_filepath]\\n\", filepath );\n    fprintf( stderr, \"\\t-d\\tdecode data\\n\" );\n    fprintf( stderr, \"\\t-o\\toutput filepath\\n\\n\" );\n}\n\nint main(int argc, char * argv[])\n{\n    FILE * fp_input = NULL;\n    FILE * fp_output = NULL;\n    bool isencode = true;\n    bool needHelp = false;\n    int opt = 0;\n    char input_filename[MAX_PATH] = \"\";\n    char output_filename[MAX_PATH] = \"\";\n\n    opterr = 0;\n    while ( (opt = getopt(argc, argv, \"hdo:\")) != -1 )\n    {\n        switch(opt)\n        {\n        case 'd':\n            isencode = false;\n            break;\n        case 'o':\n            strncpy(output_filename, optarg, sizeof(output_filename));\n            output_filename[sizeof(output_filename)-1] = '\\0';\n            break;\n        case 'h':\n            needHelp = true;\n            break;\n        default:\n            fprintf(stderr, \"%s: invalid option -- %c\\n\", argv[0], optopt);\n            needHelp = true;\n            break;\n        }\n    }\n    if ( optind < argc )\n    {\n        strncpy(input_filename, argv[optind], sizeof(input_filename));\n        input_filename[sizeof(input_filename)-1] = '\\0';\n    }\n\n    if (needHelp)\n    {\n        help(argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    if ( !strcmp(input_filename, \"\") )\n    {\n        fp_input = stdin;\n        if (isencode)\n            _setmode( _fileno(stdin), _O_BINARY );\n    }\n    else\n    {\n        if (isencode)\n            fp_input = fopen(input_filename, \"rb\");\n        else\n            fp_input = fopen(input_filename, \"r\");\n    }\n    if ( fp_input == NULL )\n    {\n        fprintf(stderr, \"Input file open error\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if ( !strcmp(output_filename, \"\") )\n    {\n        fp_output = stdout;\n        if (!isencode)\n            _setmode( _fileno(stdout), _O_BINARY );\n    }\n    else\n    {\n        if (isencode)\n            fp_output = fopen(output_filename, \"w\");\n        else\n            fp_output = fopen(output_filename, \"wb\");\n    }\n    if ( fp_output == NULL )\n    {\n        fclose(fp_input);\n        fp_input = NULL;\n        fprintf(stderr, \"Output file open error\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if (isencode)\n        encode(fp_input, fp_output);\n    else\n        decode(fp_input, fp_output);\n    fclose(fp_input);\n    fclose(fp_output);\n    fp_input = fp_output = NULL;\n    return EXIT_SUCCESS;\n}\n```\n* 除了以上的三种编码外，base系列还有其他的几种\n* base58,base85,base91,base92，base128\n\n* base58的应用：比特币、Monero、Ripple、Flickr都在用这个Base58的编码方式\n\n* base58编码表：\n\n![](/images/pasted-1.png)\n* 也就是字符1代表0，字符2代表1,字符3代表2…字符z代表57。然后回一下辗转相除法。\n* 如要将1234转换为58进制；\n* 第一步：1234除于58，商21，余数为16，查表得H\n* 第二步：21除于58，商0，余数为21，查表得N\n* 所以得到base58编码为：NH\n* 如果待转换的数前面有0怎么办？直接附加编码1来代表，有多少个就附加多少个（编码表中1代表0）\n* 大值思路为：\n\n```\n    将数据转换为大整数x，\n    依次将（x % 58）的值表示的编码添加到输出字符串末尾；\n    令x = ( x / 58 );\n    重复2-3，直到x等于0；\n    将数据前所有0的编码（即“1”）添加到输出字符串末尾；\n    将输出字符串反转，即为Base58编码字符串。\n    由于编码前数据可以视为256进制编码数据，所以转换为58进制编码数据后，数据长度为变长。\n```\n* 即：\n* Base58的本质就是把256进制的值转成58进制的值。\n* 所以它在编码时不需要考虑补\\x00的问题，直接转换即可。\n* 把字节流转成一个256进制的大数，然后不断除以58，保留余数，最后余数当作索引，再倒序，即为转换后的结果。\n\n* 特殊处理：\n* 不同于一个普通的数字转成某个进制，普通数字最高位是不会为0的，而我们要编码的对象是字节流，那么如果字节流的最前面是0（\\x00），那么就会丢失这个信息。所以编码时要特殊记录一下，字节流的开端有多少个\\x00，就直接在转换后的编码前面加上多少个b58Alphabet[0]，同理，解码的时候先记录一下前面的b58Alphabet[0]的个数，然后解码之后再在解码的前面加上相同数量的0x00。\n\n* 假设原长度为Len256，转换为长度为Len58，则：\n* Len58 = Len256 * ( log256 / log58 ) + 1\n* 使用C语言进行base58的加密：\n\n![](/images/pasted-2.png)\n\n![](/images/pasted-3.png)\n\n![](/images/pasted-4.png)\n\n![](/images/pasted-5.png)\n\n![](/images/pasted-6.png)\n\n* 关于base64和base58的总结：\n* 不管是Base64还是Base58，都会造成信息的冗余，使得需要传输的数据量增大，所以不会用在很大的数据上。\n\n```\n    使用Base64最普遍的是URL、邮件文本、图片；\n    相比于Base64直接切割比特的方法（3个比特变为4个比特），Base58采用的大数进制转换，效率更低，所以使用场景的数据更少，例如上面提到的比特币的地址的编码。\n```\n* 下一节我们讲述Unicode编码","slug":"密码学编码-二-base编码","published":1,"updated":"2020-05-27T09:55:12.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18r002ivcu99mjkboaf","content":"<ul>\n<li><p>我们接着上一节。</p>\n</li>\n<li><p>上一节我们讲述了ASCII编码，接下来的base系列编码与ASCII之间联系非常紧密。好，我们继续讲解。</p>\n</li>\n<li><p>base系列编码：</p>\n</li>\n<li><p>ASCII 是用128（2^8）个字符，对二进制数据进行编码的方式，</p>\n</li>\n<li><p>base64编码是用64（2^6）个字符，对二进制数据进行编码的方式 </p>\n</li>\n<li><p>base32就是用32（2^5）个字符，对二进制数据进行编码的方式</p>\n</li>\n<li><p>base16就是用16（2^4）个字符，对二进制数据进行编码的方式</p>\n</li>\n<li><p>这里我们可以清楚的看到，base系列编码之间的不同，在于用于编码的字符数量的多少。</p>\n</li>\n<li><p>那我们如何直接区分出base16、32、64编码呢？</p>\n</li>\n<li><p>那可以从编码字符的数量方面入手，对于base16，用于编码的字符只有：1-9，A-F ,只有简单的15个字符。对于base32而言，编码字符有了明显改变，由base16的类型转变为了A-Z,2-7。作为base系列中最完善的base64编码，是在base32的基础上，增加了”a-z,0,1,8,9,+,/“，以及特殊填充字符”=”</p>\n</li>\n<li><p>Base-64编码将一个8位子节序列拆散为6位的片段，并为每个6位的片短分配一个字符，这个字符是Base-64字母表中的64个字符之一。</p>\n</li>\n<li><p>编码解码过程：</p>\n</li>\n<li><p>base系列编码过程都类似，所以我们用base64来说明</p>\n<h1 id=\"base64填充\"><a href=\"#base64填充\" class=\"headerlink\" title=\"base64填充\"></a>base64填充</h1></li>\n<li><p>base64编码收到一个8位字节序列，将这个二进制序列流划分成6位的块。二进制序列有时不能正好平均地分为6位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为24的倍数(6和8的最小公倍数)。</p>\n</li>\n<li><p>对已填充的二进制进行编码时，任何完全填充(不包括原始数组中的位)的6位组都有特殊的第65个符号”=”表示。如果6位组是部分填充的，就将填充位设置为0.</p>\n</li>\n<li><p>下面会写一个填充实例。初始输入字符串为”a:a”为3个字节(24位)。24是6和8的倍数，因此按照上面给出的例子计算。无需填充就会得到base64编码为”YTph”。</p>\n</li>\n<li><p>然而，再增加一个字符，输入字符串变为”a:aa”,转换为二进制就会有32位长。而6和8的下一个公倍数为48.因此要添加16为的填充码。填充的前4位是与数据位混合在一起的。得到的6位组01xxxx，会被当作010000、十进制中的16，或者base64编码的Q来处理。剩下的两个6位组都是填充码，用=来表示。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:a -- 011000 010011 101001 100001 -- YTph</span><br><span class=\"line\"></span><br><span class=\"line\">a:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ&#x3D;&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">a:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">a:aaaa -- 011000 010011 101001 100001 011000 010110 000101 1000001 -- YTphYWFh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特别注意，Base64编码后的文本的长度总是4的倍数，但是如果再加上1到2个=不就不是4的倍数了吗？</li>\n<li>所以并不是先编码，再加上1到2个=，而是编码之后，把最后的1到2个字符（这个字符肯定是A）替换成=</li>\n<li>改进：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.  标准Base64里是包含 + 和 &#x2F; 的，在URL里不能直接作为参数，所以出现一种 “url safe” 的Base64编码，其实就是把 + 和 &#x2F; 替换成 - 和 _ 。</span><br><span class=\"line\">2.  同样的，&#x3D;也会被误解，所以编码后干脆去掉&#x3D;，解码时，自动添加一定数量的等号，使得其长度为4的倍数即可正常解码了。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于base系列的编码解码，可在下面的在线网站进行解码： <a href=\"https://www.qqxiuzi.cn/bianma/base.php\" target=\"_blank\" rel=\"noopener\">base16，base32,base64编码在线</a></li>\n<li>base16相当于是16进制，可以直接16进制转字符串</li>\n<li>base64编码图</li>\n</ul>\n<p><img src=\"/images/pasted-0.png\" alt=\"\"></p>\n<h2 id=\"c语言实现base64：\"><a href=\"#c语言实现base64：\" class=\"headerlink\" title=\"c语言实现base64：\"></a>c语言实现base64：</h2><ul>\n<li>base64编码、解码实现</li>\n<li>C语言源代码</li>\n</ul>\n<ul>\n<li><p>使用说明：</p>\n</li>\n<li><p>命令行参数说明：若有“-d”参数，则为base64解码，否则为base64编码。</p>\n</li>\n<li><p>若有“-o”参数，后接文件名，则输出到标准输出文件。</p>\n</li>\n<li><p>输入来自标准输入stdin，输出为标准输出stdout。可重定向输入输出流。</p>\n</li>\n<li><p>base64编码：输入任意二进制流，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出纯文本的base64编码。</p>\n</li>\n<li><p>base64解码：输入纯文本的base64编码，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出原来的二进制流。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;io.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;stdbool.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#ifndef MAX_PATH</span><br><span class=\"line\">#define MAX_PATH 256</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">const char * base64char &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">char * base64_encode( const unsigned char * bindata, char * base64, int binlength )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, j;</span><br><span class=\"line\">    unsigned char current;</span><br><span class=\"line\"></span><br><span class=\"line\">    for ( i &#x3D; 0, j &#x3D; 0 ; i &lt; binlength ; i +&#x3D; 3 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current &#x3D; (bindata[i] &gt;&gt; 2) ;</span><br><span class=\"line\">        current &amp;&#x3D; (unsigned char)0x3F;</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)(bindata[i] &lt;&lt; 4 ) ) &amp; ( (unsigned char)0x30 ) ;</span><br><span class=\"line\">        if ( i + 1 &gt;&#x3D; binlength )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current |&#x3D; ( (unsigned char)(bindata[i+1] &gt;&gt; 4) ) &amp; ( (unsigned char) 0x0F );</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)(bindata[i+1] &lt;&lt; 2) ) &amp; ( (unsigned char)0x3C ) ;</span><br><span class=\"line\">        if ( i + 2 &gt;&#x3D; binlength )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current |&#x3D; ( (unsigned char)(bindata[i+2] &gt;&gt; 6) ) &amp; ( (unsigned char) 0x03 );</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)bindata[i+2] ) &amp; ( (unsigned char)0x3F ) ;</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    base64[j] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">    return base64;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int base64_decode( const char * base64, unsigned char * bindata )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, j;</span><br><span class=\"line\">    unsigned char k;</span><br><span class=\"line\">    unsigned char temp[4];</span><br><span class=\"line\">    for ( i &#x3D; 0, j &#x3D; 0; base64[i] !&#x3D; &#39;\\0&#39; ; i +&#x3D; 4 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        memset( temp, 0xFF, sizeof(temp) );</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i] )</span><br><span class=\"line\">                temp[0]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+1] )</span><br><span class=\"line\">                temp[1]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+2] )</span><br><span class=\"line\">                temp[2]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+3] )</span><br><span class=\"line\">                temp[3]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[0] &lt;&lt; 2))&amp;0xFC)) |</span><br><span class=\"line\">                ((unsigned char)((unsigned char)(temp[1]&gt;&gt;4)&amp;0x03));</span><br><span class=\"line\">        if ( base64[i+2] &#x3D;&#x3D; &#39;&#x3D;&#39; )</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[1] &lt;&lt; 4))&amp;0xF0)) |</span><br><span class=\"line\">                ((unsigned char)((unsigned char)(temp[2]&gt;&gt;2)&amp;0x0F));</span><br><span class=\"line\">        if ( base64[i+3] &#x3D;&#x3D; &#39;&#x3D;&#39; )</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[2] &lt;&lt; 6))&amp;0xF0)) |</span><br><span class=\"line\">                ((unsigned char)(temp[3]&amp;0x3F));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void encode(FILE * fp_in, FILE * fp_out)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char bindata[2050];</span><br><span class=\"line\">    char base64[4096];</span><br><span class=\"line\">    size_t bytes;</span><br><span class=\"line\">    while ( !feof( fp_in ) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bytes &#x3D; fread( bindata, 1, 2049, fp_in );</span><br><span class=\"line\">        base64_encode( bindata, base64, bytes );</span><br><span class=\"line\">        fprintf( fp_out, &quot;%s&quot;, base64 );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void decode(FILE * fp_in, FILE * fp_out)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    unsigned char bindata[2050];</span><br><span class=\"line\">    char base64[4096];</span><br><span class=\"line\">    size_t bytes;</span><br><span class=\"line\">    while ( !feof( fp_in ) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        for ( i &#x3D; 0 ; i &lt; 2048 ; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[i] &#x3D; fgetc(fp_in);</span><br><span class=\"line\">            if ( base64[i] &#x3D;&#x3D; EOF )</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            else if ( base64[i] &#x3D;&#x3D; &#39;\\n&#39; || base64[i] &#x3D;&#x3D; &#39;\\r&#39; )</span><br><span class=\"line\">                i --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bytes &#x3D; base64_decode( base64, bindata );</span><br><span class=\"line\">        fwrite( bindata, bytes, 1, fp_out );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void help(const char * filepath)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fprintf( stderr, &quot;Usage: %s [-d] [input_filename] [-o output_filepath]\\n&quot;, filepath );</span><br><span class=\"line\">    fprintf( stderr, &quot;\\t-d\\tdecode data\\n&quot; );</span><br><span class=\"line\">    fprintf( stderr, &quot;\\t-o\\toutput filepath\\n\\n&quot; );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char * argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE * fp_input &#x3D; NULL;</span><br><span class=\"line\">    FILE * fp_output &#x3D; NULL;</span><br><span class=\"line\">    bool isencode &#x3D; true;</span><br><span class=\"line\">    bool needHelp &#x3D; false;</span><br><span class=\"line\">    int opt &#x3D; 0;</span><br><span class=\"line\">    char input_filename[MAX_PATH] &#x3D; &quot;&quot;;</span><br><span class=\"line\">    char output_filename[MAX_PATH] &#x3D; &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    opterr &#x3D; 0;</span><br><span class=\"line\">    while ( (opt &#x3D; getopt(argc, argv, &quot;hdo:&quot;)) !&#x3D; -1 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        switch(opt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        case &#39;d&#39;:</span><br><span class=\"line\">            isencode &#x3D; false;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &#39;o&#39;:</span><br><span class=\"line\">            strncpy(output_filename, optarg, sizeof(output_filename));</span><br><span class=\"line\">            output_filename[sizeof(output_filename)-1] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &#39;h&#39;:</span><br><span class=\"line\">            needHelp &#x3D; true;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            fprintf(stderr, &quot;%s: invalid option -- %c\\n&quot;, argv[0], optopt);</span><br><span class=\"line\">            needHelp &#x3D; true;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( optind &lt; argc )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        strncpy(input_filename, argv[optind], sizeof(input_filename));</span><br><span class=\"line\">        input_filename[sizeof(input_filename)-1] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (needHelp)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        help(argv[0]);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ( !strcmp(input_filename, &quot;&quot;) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fp_input &#x3D; stdin;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            _setmode( _fileno(stdin), _O_BINARY );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            fp_input &#x3D; fopen(input_filename, &quot;rb&quot;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            fp_input &#x3D; fopen(input_filename, &quot;r&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( fp_input &#x3D;&#x3D; NULL )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;Input file open error\\n&quot;);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ( !strcmp(output_filename, &quot;&quot;) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fp_output &#x3D; stdout;</span><br><span class=\"line\">        if (!isencode)</span><br><span class=\"line\">            _setmode( _fileno(stdout), _O_BINARY );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            fp_output &#x3D; fopen(output_filename, &quot;w&quot;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            fp_output &#x3D; fopen(output_filename, &quot;wb&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( fp_output &#x3D;&#x3D; NULL )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fclose(fp_input);</span><br><span class=\"line\">        fp_input &#x3D; NULL;</span><br><span class=\"line\">        fprintf(stderr, &quot;Output file open error\\n&quot;);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (isencode)</span><br><span class=\"line\">        encode(fp_input, fp_output);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        decode(fp_input, fp_output);</span><br><span class=\"line\">    fclose(fp_input);</span><br><span class=\"line\">    fclose(fp_output);</span><br><span class=\"line\">    fp_input &#x3D; fp_output &#x3D; NULL;</span><br><span class=\"line\">    return EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>除了以上的三种编码外，base系列还有其他的几种</p>\n</li>\n<li><p>base58,base85,base91,base92，base128</p>\n</li>\n<li><p>base58的应用：比特币、Monero、Ripple、Flickr都在用这个Base58的编码方式</p>\n</li>\n<li><p>base58编码表：</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-1.png\" alt=\"\"></p>\n<ul>\n<li>也就是字符1代表0，字符2代表1,字符3代表2…字符z代表57。然后回一下辗转相除法。</li>\n<li>如要将1234转换为58进制；</li>\n<li>第一步：1234除于58，商21，余数为16，查表得H</li>\n<li>第二步：21除于58，商0，余数为21，查表得N</li>\n<li>所以得到base58编码为：NH</li>\n<li>如果待转换的数前面有0怎么办？直接附加编码1来代表，有多少个就附加多少个（编码表中1代表0）</li>\n<li>大值思路为：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将数据转换为大整数x，</span><br><span class=\"line\">依次将（x % 58）的值表示的编码添加到输出字符串末尾；</span><br><span class=\"line\">令x &#x3D; ( x &#x2F; 58 );</span><br><span class=\"line\">重复2-3，直到x等于0；</span><br><span class=\"line\">将数据前所有0的编码（即“1”）添加到输出字符串末尾；</span><br><span class=\"line\">将输出字符串反转，即为Base58编码字符串。</span><br><span class=\"line\">由于编码前数据可以视为256进制编码数据，所以转换为58进制编码数据后，数据长度为变长。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>即：</p>\n</li>\n<li><p>Base58的本质就是把256进制的值转成58进制的值。</p>\n</li>\n<li><p>所以它在编码时不需要考虑补\\x00的问题，直接转换即可。</p>\n</li>\n<li><p>把字节流转成一个256进制的大数，然后不断除以58，保留余数，最后余数当作索引，再倒序，即为转换后的结果。</p>\n</li>\n<li><p>特殊处理：</p>\n</li>\n<li><p>不同于一个普通的数字转成某个进制，普通数字最高位是不会为0的，而我们要编码的对象是字节流，那么如果字节流的最前面是0（\\x00），那么就会丢失这个信息。所以编码时要特殊记录一下，字节流的开端有多少个\\x00，就直接在转换后的编码前面加上多少个b58Alphabet[0]，同理，解码的时候先记录一下前面的b58Alphabet[0]的个数，然后解码之后再在解码的前面加上相同数量的0x00。</p>\n</li>\n<li><p>假设原长度为Len256，转换为长度为Len58，则：</p>\n</li>\n<li><p>Len58 = Len256 * ( log256 / log58 ) + 1</p>\n</li>\n<li><p>使用C语言进行base58的加密：</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-2.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-3.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-4.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-5.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-6.png\" alt=\"\"></p>\n<ul>\n<li>关于base64和base58的总结：</li>\n<li>不管是Base64还是Base58，都会造成信息的冗余，使得需要传输的数据量增大，所以不会用在很大的数据上。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用Base64最普遍的是URL、邮件文本、图片；</span><br><span class=\"line\">相比于Base64直接切割比特的方法（3个比特变为4个比特），Base58采用的大数进制转换，效率更低，所以使用场景的数据更少，例如上面提到的比特币的地址的编码。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下一节我们讲述Unicode编码</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>我们接着上一节。</p>\n</li>\n<li><p>上一节我们讲述了ASCII编码，接下来的base系列编码与ASCII之间联系非常紧密。好，我们继续讲解。</p>\n</li>\n<li><p>base系列编码：</p>\n</li>\n<li><p>ASCII 是用128（2^8）个字符，对二进制数据进行编码的方式，</p>\n</li>\n<li><p>base64编码是用64（2^6）个字符，对二进制数据进行编码的方式 </p>\n</li>\n<li><p>base32就是用32（2^5）个字符，对二进制数据进行编码的方式</p>\n</li>\n<li><p>base16就是用16（2^4）个字符，对二进制数据进行编码的方式</p>\n</li>\n<li><p>这里我们可以清楚的看到，base系列编码之间的不同，在于用于编码的字符数量的多少。</p>\n</li>\n<li><p>那我们如何直接区分出base16、32、64编码呢？</p>\n</li>\n<li><p>那可以从编码字符的数量方面入手，对于base16，用于编码的字符只有：1-9，A-F ,只有简单的15个字符。对于base32而言，编码字符有了明显改变，由base16的类型转变为了A-Z,2-7。作为base系列中最完善的base64编码，是在base32的基础上，增加了”a-z,0,1,8,9,+,/“，以及特殊填充字符”=”</p>\n</li>\n<li><p>Base-64编码将一个8位子节序列拆散为6位的片段，并为每个6位的片短分配一个字符，这个字符是Base-64字母表中的64个字符之一。</p>\n</li>\n<li><p>编码解码过程：</p>\n</li>\n<li><p>base系列编码过程都类似，所以我们用base64来说明</p>\n<h1 id=\"base64填充\"><a href=\"#base64填充\" class=\"headerlink\" title=\"base64填充\"></a>base64填充</h1></li>\n<li><p>base64编码收到一个8位字节序列，将这个二进制序列流划分成6位的块。二进制序列有时不能正好平均地分为6位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为24的倍数(6和8的最小公倍数)。</p>\n</li>\n<li><p>对已填充的二进制进行编码时，任何完全填充(不包括原始数组中的位)的6位组都有特殊的第65个符号”=”表示。如果6位组是部分填充的，就将填充位设置为0.</p>\n</li>\n<li><p>下面会写一个填充实例。初始输入字符串为”a:a”为3个字节(24位)。24是6和8的倍数，因此按照上面给出的例子计算。无需填充就会得到base64编码为”YTph”。</p>\n</li>\n<li><p>然而，再增加一个字符，输入字符串变为”a:aa”,转换为二进制就会有32位长。而6和8的下一个公倍数为48.因此要添加16为的填充码。填充的前4位是与数据位混合在一起的。得到的6位组01xxxx，会被当作010000、十进制中的16，或者base64编码的Q来处理。剩下的两个6位组都是填充码，用=来表示。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:a -- 011000 010011 101001 100001 -- YTph</span><br><span class=\"line\"></span><br><span class=\"line\">a:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ&#x3D;&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">a:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">a:aaaa -- 011000 010011 101001 100001 011000 010110 000101 1000001 -- YTphYWFh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特别注意，Base64编码后的文本的长度总是4的倍数，但是如果再加上1到2个=不就不是4的倍数了吗？</li>\n<li>所以并不是先编码，再加上1到2个=，而是编码之后，把最后的1到2个字符（这个字符肯定是A）替换成=</li>\n<li>改进：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.  标准Base64里是包含 + 和 &#x2F; 的，在URL里不能直接作为参数，所以出现一种 “url safe” 的Base64编码，其实就是把 + 和 &#x2F; 替换成 - 和 _ 。</span><br><span class=\"line\">2.  同样的，&#x3D;也会被误解，所以编码后干脆去掉&#x3D;，解码时，自动添加一定数量的等号，使得其长度为4的倍数即可正常解码了。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于base系列的编码解码，可在下面的在线网站进行解码： <a href=\"https://www.qqxiuzi.cn/bianma/base.php\" target=\"_blank\" rel=\"noopener\">base16，base32,base64编码在线</a></li>\n<li>base16相当于是16进制，可以直接16进制转字符串</li>\n<li>base64编码图</li>\n</ul>\n<p><img src=\"/images/pasted-0.png\" alt=\"\"></p>\n<h2 id=\"c语言实现base64：\"><a href=\"#c语言实现base64：\" class=\"headerlink\" title=\"c语言实现base64：\"></a>c语言实现base64：</h2><ul>\n<li>base64编码、解码实现</li>\n<li>C语言源代码</li>\n</ul>\n<ul>\n<li><p>使用说明：</p>\n</li>\n<li><p>命令行参数说明：若有“-d”参数，则为base64解码，否则为base64编码。</p>\n</li>\n<li><p>若有“-o”参数，后接文件名，则输出到标准输出文件。</p>\n</li>\n<li><p>输入来自标准输入stdin，输出为标准输出stdout。可重定向输入输出流。</p>\n</li>\n<li><p>base64编码：输入任意二进制流，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出纯文本的base64编码。</p>\n</li>\n<li><p>base64解码：输入纯文本的base64编码，读取到文件读完了为止（键盘输入则遇到文件结尾符为止）。输出原来的二进制流。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;io.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\">#include &lt;stdbool.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#ifndef MAX_PATH</span><br><span class=\"line\">#define MAX_PATH 256</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">const char * base64char &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">char * base64_encode( const unsigned char * bindata, char * base64, int binlength )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, j;</span><br><span class=\"line\">    unsigned char current;</span><br><span class=\"line\"></span><br><span class=\"line\">    for ( i &#x3D; 0, j &#x3D; 0 ; i &lt; binlength ; i +&#x3D; 3 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current &#x3D; (bindata[i] &gt;&gt; 2) ;</span><br><span class=\"line\">        current &amp;&#x3D; (unsigned char)0x3F;</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)(bindata[i] &lt;&lt; 4 ) ) &amp; ( (unsigned char)0x30 ) ;</span><br><span class=\"line\">        if ( i + 1 &gt;&#x3D; binlength )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current |&#x3D; ( (unsigned char)(bindata[i+1] &gt;&gt; 4) ) &amp; ( (unsigned char) 0x0F );</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)(bindata[i+1] &lt;&lt; 2) ) &amp; ( (unsigned char)0x3C ) ;</span><br><span class=\"line\">        if ( i + 2 &gt;&#x3D; binlength )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">            base64[j++] &#x3D; &#39;&#x3D;&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current |&#x3D; ( (unsigned char)(bindata[i+2] &gt;&gt; 6) ) &amp; ( (unsigned char) 0x03 );</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\"></span><br><span class=\"line\">        current &#x3D; ( (unsigned char)bindata[i+2] ) &amp; ( (unsigned char)0x3F ) ;</span><br><span class=\"line\">        base64[j++] &#x3D; base64char[(int)current];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    base64[j] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">    return base64;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int base64_decode( const char * base64, unsigned char * bindata )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, j;</span><br><span class=\"line\">    unsigned char k;</span><br><span class=\"line\">    unsigned char temp[4];</span><br><span class=\"line\">    for ( i &#x3D; 0, j &#x3D; 0; base64[i] !&#x3D; &#39;\\0&#39; ; i +&#x3D; 4 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        memset( temp, 0xFF, sizeof(temp) );</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i] )</span><br><span class=\"line\">                temp[0]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+1] )</span><br><span class=\"line\">                temp[1]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+2] )</span><br><span class=\"line\">                temp[2]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for ( k &#x3D; 0 ; k &lt; 64 ; k ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( base64char[k] &#x3D;&#x3D; base64[i+3] )</span><br><span class=\"line\">                temp[3]&#x3D; k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[0] &lt;&lt; 2))&amp;0xFC)) |</span><br><span class=\"line\">                ((unsigned char)((unsigned char)(temp[1]&gt;&gt;4)&amp;0x03));</span><br><span class=\"line\">        if ( base64[i+2] &#x3D;&#x3D; &#39;&#x3D;&#39; )</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[1] &lt;&lt; 4))&amp;0xF0)) |</span><br><span class=\"line\">                ((unsigned char)((unsigned char)(temp[2]&gt;&gt;2)&amp;0x0F));</span><br><span class=\"line\">        if ( base64[i+3] &#x3D;&#x3D; &#39;&#x3D;&#39; )</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        bindata[j++] &#x3D; ((unsigned char)(((unsigned char)(temp[2] &lt;&lt; 6))&amp;0xF0)) |</span><br><span class=\"line\">                ((unsigned char)(temp[3]&amp;0x3F));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void encode(FILE * fp_in, FILE * fp_out)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char bindata[2050];</span><br><span class=\"line\">    char base64[4096];</span><br><span class=\"line\">    size_t bytes;</span><br><span class=\"line\">    while ( !feof( fp_in ) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bytes &#x3D; fread( bindata, 1, 2049, fp_in );</span><br><span class=\"line\">        base64_encode( bindata, base64, bytes );</span><br><span class=\"line\">        fprintf( fp_out, &quot;%s&quot;, base64 );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void decode(FILE * fp_in, FILE * fp_out)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    unsigned char bindata[2050];</span><br><span class=\"line\">    char base64[4096];</span><br><span class=\"line\">    size_t bytes;</span><br><span class=\"line\">    while ( !feof( fp_in ) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        for ( i &#x3D; 0 ; i &lt; 2048 ; i ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            base64[i] &#x3D; fgetc(fp_in);</span><br><span class=\"line\">            if ( base64[i] &#x3D;&#x3D; EOF )</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            else if ( base64[i] &#x3D;&#x3D; &#39;\\n&#39; || base64[i] &#x3D;&#x3D; &#39;\\r&#39; )</span><br><span class=\"line\">                i --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bytes &#x3D; base64_decode( base64, bindata );</span><br><span class=\"line\">        fwrite( bindata, bytes, 1, fp_out );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void help(const char * filepath)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fprintf( stderr, &quot;Usage: %s [-d] [input_filename] [-o output_filepath]\\n&quot;, filepath );</span><br><span class=\"line\">    fprintf( stderr, &quot;\\t-d\\tdecode data\\n&quot; );</span><br><span class=\"line\">    fprintf( stderr, &quot;\\t-o\\toutput filepath\\n\\n&quot; );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char * argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE * fp_input &#x3D; NULL;</span><br><span class=\"line\">    FILE * fp_output &#x3D; NULL;</span><br><span class=\"line\">    bool isencode &#x3D; true;</span><br><span class=\"line\">    bool needHelp &#x3D; false;</span><br><span class=\"line\">    int opt &#x3D; 0;</span><br><span class=\"line\">    char input_filename[MAX_PATH] &#x3D; &quot;&quot;;</span><br><span class=\"line\">    char output_filename[MAX_PATH] &#x3D; &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    opterr &#x3D; 0;</span><br><span class=\"line\">    while ( (opt &#x3D; getopt(argc, argv, &quot;hdo:&quot;)) !&#x3D; -1 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        switch(opt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        case &#39;d&#39;:</span><br><span class=\"line\">            isencode &#x3D; false;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &#39;o&#39;:</span><br><span class=\"line\">            strncpy(output_filename, optarg, sizeof(output_filename));</span><br><span class=\"line\">            output_filename[sizeof(output_filename)-1] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &#39;h&#39;:</span><br><span class=\"line\">            needHelp &#x3D; true;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            fprintf(stderr, &quot;%s: invalid option -- %c\\n&quot;, argv[0], optopt);</span><br><span class=\"line\">            needHelp &#x3D; true;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( optind &lt; argc )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        strncpy(input_filename, argv[optind], sizeof(input_filename));</span><br><span class=\"line\">        input_filename[sizeof(input_filename)-1] &#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (needHelp)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        help(argv[0]);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ( !strcmp(input_filename, &quot;&quot;) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fp_input &#x3D; stdin;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            _setmode( _fileno(stdin), _O_BINARY );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            fp_input &#x3D; fopen(input_filename, &quot;rb&quot;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            fp_input &#x3D; fopen(input_filename, &quot;r&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( fp_input &#x3D;&#x3D; NULL )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fprintf(stderr, &quot;Input file open error\\n&quot;);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ( !strcmp(output_filename, &quot;&quot;) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fp_output &#x3D; stdout;</span><br><span class=\"line\">        if (!isencode)</span><br><span class=\"line\">            _setmode( _fileno(stdout), _O_BINARY );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (isencode)</span><br><span class=\"line\">            fp_output &#x3D; fopen(output_filename, &quot;w&quot;);</span><br><span class=\"line\">        else</span><br><span class=\"line\">            fp_output &#x3D; fopen(output_filename, &quot;wb&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if ( fp_output &#x3D;&#x3D; NULL )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fclose(fp_input);</span><br><span class=\"line\">        fp_input &#x3D; NULL;</span><br><span class=\"line\">        fprintf(stderr, &quot;Output file open error\\n&quot;);</span><br><span class=\"line\">        return EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (isencode)</span><br><span class=\"line\">        encode(fp_input, fp_output);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        decode(fp_input, fp_output);</span><br><span class=\"line\">    fclose(fp_input);</span><br><span class=\"line\">    fclose(fp_output);</span><br><span class=\"line\">    fp_input &#x3D; fp_output &#x3D; NULL;</span><br><span class=\"line\">    return EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>除了以上的三种编码外，base系列还有其他的几种</p>\n</li>\n<li><p>base58,base85,base91,base92，base128</p>\n</li>\n<li><p>base58的应用：比特币、Monero、Ripple、Flickr都在用这个Base58的编码方式</p>\n</li>\n<li><p>base58编码表：</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-1.png\" alt=\"\"></p>\n<ul>\n<li>也就是字符1代表0，字符2代表1,字符3代表2…字符z代表57。然后回一下辗转相除法。</li>\n<li>如要将1234转换为58进制；</li>\n<li>第一步：1234除于58，商21，余数为16，查表得H</li>\n<li>第二步：21除于58，商0，余数为21，查表得N</li>\n<li>所以得到base58编码为：NH</li>\n<li>如果待转换的数前面有0怎么办？直接附加编码1来代表，有多少个就附加多少个（编码表中1代表0）</li>\n<li>大值思路为：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将数据转换为大整数x，</span><br><span class=\"line\">依次将（x % 58）的值表示的编码添加到输出字符串末尾；</span><br><span class=\"line\">令x &#x3D; ( x &#x2F; 58 );</span><br><span class=\"line\">重复2-3，直到x等于0；</span><br><span class=\"line\">将数据前所有0的编码（即“1”）添加到输出字符串末尾；</span><br><span class=\"line\">将输出字符串反转，即为Base58编码字符串。</span><br><span class=\"line\">由于编码前数据可以视为256进制编码数据，所以转换为58进制编码数据后，数据长度为变长。</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>即：</p>\n</li>\n<li><p>Base58的本质就是把256进制的值转成58进制的值。</p>\n</li>\n<li><p>所以它在编码时不需要考虑补\\x00的问题，直接转换即可。</p>\n</li>\n<li><p>把字节流转成一个256进制的大数，然后不断除以58，保留余数，最后余数当作索引，再倒序，即为转换后的结果。</p>\n</li>\n<li><p>特殊处理：</p>\n</li>\n<li><p>不同于一个普通的数字转成某个进制，普通数字最高位是不会为0的，而我们要编码的对象是字节流，那么如果字节流的最前面是0（\\x00），那么就会丢失这个信息。所以编码时要特殊记录一下，字节流的开端有多少个\\x00，就直接在转换后的编码前面加上多少个b58Alphabet[0]，同理，解码的时候先记录一下前面的b58Alphabet[0]的个数，然后解码之后再在解码的前面加上相同数量的0x00。</p>\n</li>\n<li><p>假设原长度为Len256，转换为长度为Len58，则：</p>\n</li>\n<li><p>Len58 = Len256 * ( log256 / log58 ) + 1</p>\n</li>\n<li><p>使用C语言进行base58的加密：</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-2.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-3.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-4.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-5.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-6.png\" alt=\"\"></p>\n<ul>\n<li>关于base64和base58的总结：</li>\n<li>不管是Base64还是Base58，都会造成信息的冗余，使得需要传输的数据量增大，所以不会用在很大的数据上。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用Base64最普遍的是URL、邮件文本、图片；</span><br><span class=\"line\">相比于Base64直接切割比特的方法（3个比特变为4个比特），Base58采用的大数进制转换，效率更低，所以使用场景的数据更少，例如上面提到的比特币的地址的编码。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下一节我们讲述Unicode编码</li>\n</ul>\n"},{"title":"红黑树的删除和变色","author":"人生若只如初见","date":"2020-05-28T11:02:00.000Z","_content":"# 二叉搜索树和红黑树简介\n\n* 二叉搜索树：\n\n```\n二叉搜索树是一种节点值之间具有一定数量级次序的二叉树\n对于树中的每个节点：如果存在左子树，则左子树的值小于根节点的值\n如果存在右子树，则右子树的值一定大于根节点的值\n```\n\n* 红黑树：自平衡的二叉搜索树。\n\n## 性质\n\n```\n\t性质1：每个节点要么是黑色，要么是红色。 \n\t性质2：根节点是黑色。 \n\t性质3：每个叶子节点（NIL）是黑色。 \n\t性质4：每个红色结点的两个子结点一定都是黑色。 \n\t性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。\n```\n\n# 红黑树的自平衡\n\n* \t自平衡的三种操作：左旋、右旋和变色\n*\t左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子节点，左子结点不变。\n*\t右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。\n*\t变色：结点颜色由红变黑或者由黑变红。\n\n\n![](/images/pasted-26.png)\n\n![](/images/pasted-27.png)\n\n* 红黑树左旋/右旋的实际操作意义：\n\n```\n<1> 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪。\n<2> 右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪。\n<3> 所以旋转操作是局部的。旋转保持红黑树平衡的端详：当一边子树的结点少了，那么向另外一边子树“借”一\t些结点；当一边的子树的结点多了，那么向另外一边子树“租”一些结点。\n```\n\n# 红黑树的查找\n\n* 因为红黑树是一颗二叉平衡树，并且查找并不会破坏树的平衡，所以查找和二叉平衡树的查找无异。\n\n```\n1、从根节点开始查找，把根节点设置为当前结点；\n2、若当前结点为空，返回NULL；\n3、若当前结点不为空，用当前结点的key跟查找key作比较；\n4、若当前结点key等于查找key，那么该key就是查找目标，返回当前结点； \n5、若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2； \n6、若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；\n```\n\n![](/images/pasted-28.png)\n\n# 红黑树的删除\n\n* 删除时先作为普通二叉树进行删除：\n\n```\n1、若删除结点无子结点，直接删除。\n2、若删除结点只有一个子结点，用子结点替换删除结点。\n3、若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点。（回到1和2）\n```\n\n* \t寻找前继结点和后继结点的方法：将二叉树所有结点投射到X轴上，所有结点都是从左到右排序的，所有目标结点的前后结点就是对应前继和后继结点。\n\n![](/images/pasted-29.png)\n\n* 我们在删除红黑树结点时是先将他作为普通的二叉搜索树进行操作的，我们将结点删除后，再进行变色，避免同时操作时发生混乱。\n\n\n![](/images/pasted-30.png)\n\n* 在删除结点时，我们可以将单一的结点树进行操作，而将未进行操作的树保留在一旁；整个的删除过程全部满足红黑树本身的五条性质，也就是说在变换过程中，对红黑树的一切操作都是为了让整个红黑树删除结点后依旧满足红黑树的性质。","source":"_posts/红黑树的删除和变色.md","raw":"title: 红黑树的删除和变色\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 算法\ndate: 2020-05-28 19:02:00\n---\n# 二叉搜索树和红黑树简介\n\n* 二叉搜索树：\n\n```\n二叉搜索树是一种节点值之间具有一定数量级次序的二叉树\n对于树中的每个节点：如果存在左子树，则左子树的值小于根节点的值\n如果存在右子树，则右子树的值一定大于根节点的值\n```\n\n* 红黑树：自平衡的二叉搜索树。\n\n## 性质\n\n```\n\t性质1：每个节点要么是黑色，要么是红色。 \n\t性质2：根节点是黑色。 \n\t性质3：每个叶子节点（NIL）是黑色。 \n\t性质4：每个红色结点的两个子结点一定都是黑色。 \n\t性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。\n```\n\n# 红黑树的自平衡\n\n* \t自平衡的三种操作：左旋、右旋和变色\n*\t左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子节点，左子结点不变。\n*\t右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。\n*\t变色：结点颜色由红变黑或者由黑变红。\n\n\n![](/images/pasted-26.png)\n\n![](/images/pasted-27.png)\n\n* 红黑树左旋/右旋的实际操作意义：\n\n```\n<1> 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪。\n<2> 右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪。\n<3> 所以旋转操作是局部的。旋转保持红黑树平衡的端详：当一边子树的结点少了，那么向另外一边子树“借”一\t些结点；当一边的子树的结点多了，那么向另外一边子树“租”一些结点。\n```\n\n# 红黑树的查找\n\n* 因为红黑树是一颗二叉平衡树，并且查找并不会破坏树的平衡，所以查找和二叉平衡树的查找无异。\n\n```\n1、从根节点开始查找，把根节点设置为当前结点；\n2、若当前结点为空，返回NULL；\n3、若当前结点不为空，用当前结点的key跟查找key作比较；\n4、若当前结点key等于查找key，那么该key就是查找目标，返回当前结点； \n5、若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2； \n6、若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；\n```\n\n![](/images/pasted-28.png)\n\n# 红黑树的删除\n\n* 删除时先作为普通二叉树进行删除：\n\n```\n1、若删除结点无子结点，直接删除。\n2、若删除结点只有一个子结点，用子结点替换删除结点。\n3、若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点。（回到1和2）\n```\n\n* \t寻找前继结点和后继结点的方法：将二叉树所有结点投射到X轴上，所有结点都是从左到右排序的，所有目标结点的前后结点就是对应前继和后继结点。\n\n![](/images/pasted-29.png)\n\n* 我们在删除红黑树结点时是先将他作为普通的二叉搜索树进行操作的，我们将结点删除后，再进行变色，避免同时操作时发生混乱。\n\n\n![](/images/pasted-30.png)\n\n* 在删除结点时，我们可以将单一的结点树进行操作，而将未进行操作的树保留在一旁；整个的删除过程全部满足红黑树本身的五条性质，也就是说在变换过程中，对红黑树的一切操作都是为了让整个红黑树删除结点后依旧满足红黑树的性质。","slug":"红黑树的删除和变色","published":1,"updated":"2020-05-28T14:17:59.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18r002kvcu9hke9aqwz","content":"<h1 id=\"二叉搜索树和红黑树简介\"><a href=\"#二叉搜索树和红黑树简介\" class=\"headerlink\" title=\"二叉搜索树和红黑树简介\"></a>二叉搜索树和红黑树简介</h1><ul>\n<li>二叉搜索树：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二叉搜索树是一种节点值之间具有一定数量级次序的二叉树</span><br><span class=\"line\">对于树中的每个节点：如果存在左子树，则左子树的值小于根节点的值</span><br><span class=\"line\">如果存在右子树，则右子树的值一定大于根节点的值</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>红黑树：自平衡的二叉搜索树。</li>\n</ul>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">性质1：每个节点要么是黑色，要么是红色。 </span><br><span class=\"line\">性质2：根节点是黑色。 </span><br><span class=\"line\">性质3：每个叶子节点（NIL）是黑色。 </span><br><span class=\"line\">性质4：每个红色结点的两个子结点一定都是黑色。 </span><br><span class=\"line\">性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"红黑树的自平衡\"><a href=\"#红黑树的自平衡\" class=\"headerlink\" title=\"红黑树的自平衡\"></a>红黑树的自平衡</h1><ul>\n<li>自平衡的三种操作：左旋、右旋和变色</li>\n<li>左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子节点，左子结点不变。</li>\n<li>右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</li>\n<li>变色：结点颜色由红变黑或者由黑变红。</li>\n</ul>\n<p><img src=\"/images/pasted-26.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-27.png\" alt=\"\"></p>\n<ul>\n<li>红黑树左旋/右旋的实际操作意义：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪。</span><br><span class=\"line\">&lt;2&gt; 右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪。</span><br><span class=\"line\">&lt;3&gt; 所以旋转操作是局部的。旋转保持红黑树平衡的端详：当一边子树的结点少了，那么向另外一边子树“借”一\t些结点；当一边的子树的结点多了，那么向另外一边子树“租”一些结点。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"红黑树的查找\"><a href=\"#红黑树的查找\" class=\"headerlink\" title=\"红黑树的查找\"></a>红黑树的查找</h1><ul>\n<li>因为红黑树是一颗二叉平衡树，并且查找并不会破坏树的平衡，所以查找和二叉平衡树的查找无异。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、从根节点开始查找，把根节点设置为当前结点；</span><br><span class=\"line\">2、若当前结点为空，返回NULL；</span><br><span class=\"line\">3、若当前结点不为空，用当前结点的key跟查找key作比较；</span><br><span class=\"line\">4、若当前结点key等于查找key，那么该key就是查找目标，返回当前结点； </span><br><span class=\"line\">5、若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2； </span><br><span class=\"line\">6、若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/pasted-28.png\" alt=\"\"></p>\n<h1 id=\"红黑树的删除\"><a href=\"#红黑树的删除\" class=\"headerlink\" title=\"红黑树的删除\"></a>红黑树的删除</h1><ul>\n<li>删除时先作为普通二叉树进行删除：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、若删除结点无子结点，直接删除。</span><br><span class=\"line\">2、若删除结点只有一个子结点，用子结点替换删除结点。</span><br><span class=\"line\">3、若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点。（回到1和2）</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>寻找前继结点和后继结点的方法：将二叉树所有结点投射到X轴上，所有结点都是从左到右排序的，所有目标结点的前后结点就是对应前继和后继结点。</li>\n</ul>\n<p><img src=\"/images/pasted-29.png\" alt=\"\"></p>\n<ul>\n<li>我们在删除红黑树结点时是先将他作为普通的二叉搜索树进行操作的，我们将结点删除后，再进行变色，避免同时操作时发生混乱。</li>\n</ul>\n<p><img src=\"/images/pasted-30.png\" alt=\"\"></p>\n<ul>\n<li>在删除结点时，我们可以将单一的结点树进行操作，而将未进行操作的树保留在一旁；整个的删除过程全部满足红黑树本身的五条性质，也就是说在变换过程中，对红黑树的一切操作都是为了让整个红黑树删除结点后依旧满足红黑树的性质。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"二叉搜索树和红黑树简介\"><a href=\"#二叉搜索树和红黑树简介\" class=\"headerlink\" title=\"二叉搜索树和红黑树简介\"></a>二叉搜索树和红黑树简介</h1><ul>\n<li>二叉搜索树：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二叉搜索树是一种节点值之间具有一定数量级次序的二叉树</span><br><span class=\"line\">对于树中的每个节点：如果存在左子树，则左子树的值小于根节点的值</span><br><span class=\"line\">如果存在右子树，则右子树的值一定大于根节点的值</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>红黑树：自平衡的二叉搜索树。</li>\n</ul>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">性质1：每个节点要么是黑色，要么是红色。 </span><br><span class=\"line\">性质2：根节点是黑色。 </span><br><span class=\"line\">性质3：每个叶子节点（NIL）是黑色。 </span><br><span class=\"line\">性质4：每个红色结点的两个子结点一定都是黑色。 </span><br><span class=\"line\">性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"红黑树的自平衡\"><a href=\"#红黑树的自平衡\" class=\"headerlink\" title=\"红黑树的自平衡\"></a>红黑树的自平衡</h1><ul>\n<li>自平衡的三种操作：左旋、右旋和变色</li>\n<li>左旋：以某个结点作为支点（旋转结点），其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子节点，左子结点不变。</li>\n<li>右旋：以某个结点作为支点（旋转结点），其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</li>\n<li>变色：结点颜色由红变黑或者由黑变红。</li>\n</ul>\n<p><img src=\"/images/pasted-26.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-27.png\" alt=\"\"></p>\n<ul>\n<li>红黑树左旋/右旋的实际操作意义：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;1&gt; 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪。</span><br><span class=\"line\">&lt;2&gt; 右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪。</span><br><span class=\"line\">&lt;3&gt; 所以旋转操作是局部的。旋转保持红黑树平衡的端详：当一边子树的结点少了，那么向另外一边子树“借”一\t些结点；当一边的子树的结点多了，那么向另外一边子树“租”一些结点。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"红黑树的查找\"><a href=\"#红黑树的查找\" class=\"headerlink\" title=\"红黑树的查找\"></a>红黑树的查找</h1><ul>\n<li>因为红黑树是一颗二叉平衡树，并且查找并不会破坏树的平衡，所以查找和二叉平衡树的查找无异。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、从根节点开始查找，把根节点设置为当前结点；</span><br><span class=\"line\">2、若当前结点为空，返回NULL；</span><br><span class=\"line\">3、若当前结点不为空，用当前结点的key跟查找key作比较；</span><br><span class=\"line\">4、若当前结点key等于查找key，那么该key就是查找目标，返回当前结点； </span><br><span class=\"line\">5、若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2； </span><br><span class=\"line\">6、若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/pasted-28.png\" alt=\"\"></p>\n<h1 id=\"红黑树的删除\"><a href=\"#红黑树的删除\" class=\"headerlink\" title=\"红黑树的删除\"></a>红黑树的删除</h1><ul>\n<li>删除时先作为普通二叉树进行删除：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、若删除结点无子结点，直接删除。</span><br><span class=\"line\">2、若删除结点只有一个子结点，用子结点替换删除结点。</span><br><span class=\"line\">3、若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点。（回到1和2）</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>寻找前继结点和后继结点的方法：将二叉树所有结点投射到X轴上，所有结点都是从左到右排序的，所有目标结点的前后结点就是对应前继和后继结点。</li>\n</ul>\n<p><img src=\"/images/pasted-29.png\" alt=\"\"></p>\n<ul>\n<li>我们在删除红黑树结点时是先将他作为普通的二叉搜索树进行操作的，我们将结点删除后，再进行变色，避免同时操作时发生混乱。</li>\n</ul>\n<p><img src=\"/images/pasted-30.png\" alt=\"\"></p>\n<ul>\n<li>在删除结点时，我们可以将单一的结点树进行操作，而将未进行操作的树保留在一旁；整个的删除过程全部满足红黑树本身的五条性质，也就是说在变换过程中，对红黑树的一切操作都是为了让整个红黑树删除结点后依旧满足红黑树的性质。</li>\n</ul>\n"},{"title":"密码学编码(三)Unicode编码","author":"人生若只如初见","date":"2020-05-27T10:01:00.000Z","_content":"* 计算机发展早期，编码只有ASCII编码，但ASCII编码只能够用来表示拉丁字母、数字以及一些特殊符号，而语言不止英语一种，例如中文一个字节是不够表示的，最少需要两个字节，并且需要兼容ASCII编码，不能与之发生冲突。为了解决传统字符编码方案的局限性，所以Unicode编码应运而生。\n\n* Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。\n\n* 在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。\n* 几乎所有电脑系统都支持基本拉丁字母，并各自支持不同的其他编码方式。Unicode为了和它们相互兼容，其首256字符保留给ISO 8859-1所定义的字符，使既有的西欧语系文字的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。举例来说，全角格式区段包含了主要的拉丁字母的全角格式，在中文、日文、以及韩文字形当中，这些字符以全角的方式来呈现，而不以常见的半角形式显示，这对竖排文字和等宽排列文字有重要作用。\n\n* Unicode为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF(十六进制)，有110多万，每个字符都有一个唯一的Unicode编号，这个编号一般写成16进制，在前面加上U+。例如：“马”的Unicode是U+9A6C。\n* Unicode就相当于一张表，建立了字符与编号之间的联系,它是一种规定，Unicode本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。\n* 除了直接转换为二进制的策略，Unicode 可以使用的编码有三种，分别是：\n\n```\nUFT-8：一种变长的编码方案，使用 1~6 个字节来存储；\nUFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；\nUTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。\n```\n\n* ①Unicode其实应该是一个码值表。（百度百科：Unicode的功用是为每一个字符提供一个唯一的代码（即一组数字））。\n* ②UTF-8/UTF-16/UTF-32是通过对Unicode码值进行对应规则转换后，编码保持到内存/文件中。UTF-8/UTF-16/UTF-32都是可变长度的编码方式。（后面将进行Unicode码值转换为UTF-8的说明）。\n* ③我们平常说的 “Unicode编码是2个字节” 这句话，其实是因为windows默认的Unicode编码就是UTF-16，在常用基本字符上2个字节的编码方式已经够用导致的误解，其实是可变长度的。在没有特殊说明的情况下，常说的Unicode编码可以理解为UTF-16编码。\n* ④UTF-32是因为UTF-16编码方式不能表示全部的字符而扩充的编码方式。\n* ps：显示的字符是表现形式，具体内存中的编码方式和字符显示之间通过中间层进行转换。（根据编码规则，1个字符可能对应内存中1个到几个字节。）\n\n* 这里转换为二进制后计算机的储存问题：计算机在存储器中排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34\n* UTF-8编码不存在字节序大小端问题！（因为字节序只影响同时处理多于两个字节的编码方式，比如UTF-16/UTF-32，而UTF-8是按照单字节进行处理的）\n* UTF-8的解码都必须先读取首字节获取字节数，所以必须找到首字节的第一位要么是0，要么是110/1110/11110/111110/1111110，所以上面的“中”字，无论是保存为11100100 10111000 10101101还是10101101 10111000 11100100，都必须要先找到11100100这个字节，所以UTF-8从机制上就能避免字节序的问题。\n* UTF-16/UTF-32存在字节序问题（UTF-16常用情况下一次处理2个字节/UTF-32一次处理4个字节）！一个“奎”的Unicode码值是0x594E，“乙”的Unicode码值是0x4E59。如果我们的UTF-16字节数据是0x594E，那么这是“奎”还是“乙”？如果大端序，0x594E是“奎”，如果是小端序，0x4E59，是“乙”。\n\n![](/images/pasted-9.png)\n## UTF-8\n* UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：\n\n```\n对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。\n\n对于需要使用 N 个字节来表示的字符（N > 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。\n```\n\n* 编码规则：\n![](/images/pasted-10.png)\n\n![](/images/pasted-11.png)\n\n![](/images/pasted-12.png)\n* 对于具体的Unicode编号，进行UTF-8编码的方法：\n* 首先找到该Unicode编号所在的编号范围，进而找到对应的二进制格式，然后将该Unicode编号转换为二进制数有（去掉高位的0）最后将该二进制数一次填充入二进制格式的X中，未填充的X变为0.\n* 例：马的Unicode编号是：0x9A6C，整数编号是39532，其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532对应的二进制为1001 1010 0110 1100，填入为：11101001 10101001 10101100\n\n## UTF-16\n* 为了弄清楚UTF-16文件的大小尾序，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文字档案是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。\n* 使用2字节或者4字节进行编码\n* 字符按照UTF-16进行编码的规则是： - 字符的值小于0x10000的用等于该值的16位整数来表示。 - 字符的值介于0x10000和0x10FFFF之间的，用一个值介于0xD800和0xDBFF(在所谓的高8位区)的16位整数和值介于0xDC00和0xDFFF(在所谓的低8位区)的16位整数来表示。 - 字符的值大于0x10FFFF不能按照UTF-16进行编码。注意：在0xD800和0xDFFF间的值是特别为UTF-16预留，所以不应该将任何字符的值指定为这个区间内的数值。\n\n```\nD800－DB7F High Surrogates 高位替代 895\nDB80－DBFF High Private Use Surrogates 高位专用替代 127\nDC00－DFFF Low Surrogates 低位替代 1023\n```\n\n* 高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。\n* 如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：\n\n```\n1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111\n```\n\n* 按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到\n\n```\n1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111\n```\n* 即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代。\n## UTF-32\n* UTF-32 是固定长度的编码，始终占用 4 个字节，足以容纳所有的 Unicode 字符，所以直接存储 Unicode 编号即可，不需要任何编码转换。浪费了空间，赢得了效率。\n* BOM（Byte Order Mark）\n\n```\n①为了保证编码和解码字节顺序问题（因为只有保证编码和解码的规则一致才能保证是同一个字符），所以Unicode规范中推荐的标记字节顺序的方法是BOM（Byte Order Mark）。\n②UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。根据BOM的规则，在一段字节流开始时，如果接收到以下字节，则分别表明了该文本文件的编码。\n\tUTF-8: EF BB BF\n\tUTF-16 : FF FE\n\tUTF-16 big-endian: FE FF\n\tUTF-32 little-endian: FF FE 00 00\n\tUTF-32 big-endian: 00 00 FE FF\n而如果不是以这个开头，那程序则会以ANSI，也就是系统默认编码读取。\n如同样是字符“A”﹐在以下几种格式中的存储形式分别是﹕\n\tUTF-16 big-endian : 00 41\n\tUTF-16 little-endian : 41 00\n\tUTF-32 big-endian : 00 00 00 41\n\tUTF-32 little-endian : 41 00 00 00\n```","source":"_posts/密码学编码-三-Unicode编码.md","raw":"title: 密码学编码(三)Unicode编码\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - 密码学\n  - 编码\ndate: 2020-05-27 18:01:00\n---\n* 计算机发展早期，编码只有ASCII编码，但ASCII编码只能够用来表示拉丁字母、数字以及一些特殊符号，而语言不止英语一种，例如中文一个字节是不够表示的，最少需要两个字节，并且需要兼容ASCII编码，不能与之发生冲突。为了解决传统字符编码方案的局限性，所以Unicode编码应运而生。\n\n* Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。\n\n* 在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。\n* 几乎所有电脑系统都支持基本拉丁字母，并各自支持不同的其他编码方式。Unicode为了和它们相互兼容，其首256字符保留给ISO 8859-1所定义的字符，使既有的西欧语系文字的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。举例来说，全角格式区段包含了主要的拉丁字母的全角格式，在中文、日文、以及韩文字形当中，这些字符以全角的方式来呈现，而不以常见的半角形式显示，这对竖排文字和等宽排列文字有重要作用。\n\n* Unicode为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF(十六进制)，有110多万，每个字符都有一个唯一的Unicode编号，这个编号一般写成16进制，在前面加上U+。例如：“马”的Unicode是U+9A6C。\n* Unicode就相当于一张表，建立了字符与编号之间的联系,它是一种规定，Unicode本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。\n* 除了直接转换为二进制的策略，Unicode 可以使用的编码有三种，分别是：\n\n```\nUFT-8：一种变长的编码方案，使用 1~6 个字节来存储；\nUFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；\nUTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。\n```\n\n* ①Unicode其实应该是一个码值表。（百度百科：Unicode的功用是为每一个字符提供一个唯一的代码（即一组数字））。\n* ②UTF-8/UTF-16/UTF-32是通过对Unicode码值进行对应规则转换后，编码保持到内存/文件中。UTF-8/UTF-16/UTF-32都是可变长度的编码方式。（后面将进行Unicode码值转换为UTF-8的说明）。\n* ③我们平常说的 “Unicode编码是2个字节” 这句话，其实是因为windows默认的Unicode编码就是UTF-16，在常用基本字符上2个字节的编码方式已经够用导致的误解，其实是可变长度的。在没有特殊说明的情况下，常说的Unicode编码可以理解为UTF-16编码。\n* ④UTF-32是因为UTF-16编码方式不能表示全部的字符而扩充的编码方式。\n* ps：显示的字符是表现形式，具体内存中的编码方式和字符显示之间通过中间层进行转换。（根据编码规则，1个字符可能对应内存中1个到几个字节。）\n\n* 这里转换为二进制后计算机的储存问题：计算机在存储器中排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34\n* UTF-8编码不存在字节序大小端问题！（因为字节序只影响同时处理多于两个字节的编码方式，比如UTF-16/UTF-32，而UTF-8是按照单字节进行处理的）\n* UTF-8的解码都必须先读取首字节获取字节数，所以必须找到首字节的第一位要么是0，要么是110/1110/11110/111110/1111110，所以上面的“中”字，无论是保存为11100100 10111000 10101101还是10101101 10111000 11100100，都必须要先找到11100100这个字节，所以UTF-8从机制上就能避免字节序的问题。\n* UTF-16/UTF-32存在字节序问题（UTF-16常用情况下一次处理2个字节/UTF-32一次处理4个字节）！一个“奎”的Unicode码值是0x594E，“乙”的Unicode码值是0x4E59。如果我们的UTF-16字节数据是0x594E，那么这是“奎”还是“乙”？如果大端序，0x594E是“奎”，如果是小端序，0x4E59，是“乙”。\n\n![](/images/pasted-9.png)\n## UTF-8\n* UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：\n\n```\n对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。\n\n对于需要使用 N 个字节来表示的字符（N > 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。\n```\n\n* 编码规则：\n![](/images/pasted-10.png)\n\n![](/images/pasted-11.png)\n\n![](/images/pasted-12.png)\n* 对于具体的Unicode编号，进行UTF-8编码的方法：\n* 首先找到该Unicode编号所在的编号范围，进而找到对应的二进制格式，然后将该Unicode编号转换为二进制数有（去掉高位的0）最后将该二进制数一次填充入二进制格式的X中，未填充的X变为0.\n* 例：马的Unicode编号是：0x9A6C，整数编号是39532，其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532对应的二进制为1001 1010 0110 1100，填入为：11101001 10101001 10101100\n\n## UTF-16\n* 为了弄清楚UTF-16文件的大小尾序，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文字档案是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。\n* 使用2字节或者4字节进行编码\n* 字符按照UTF-16进行编码的规则是： - 字符的值小于0x10000的用等于该值的16位整数来表示。 - 字符的值介于0x10000和0x10FFFF之间的，用一个值介于0xD800和0xDBFF(在所谓的高8位区)的16位整数和值介于0xDC00和0xDFFF(在所谓的低8位区)的16位整数来表示。 - 字符的值大于0x10FFFF不能按照UTF-16进行编码。注意：在0xD800和0xDFFF间的值是特别为UTF-16预留，所以不应该将任何字符的值指定为这个区间内的数值。\n\n```\nD800－DB7F High Surrogates 高位替代 895\nDB80－DBFF High Private Use Surrogates 高位专用替代 127\nDC00－DFFF Low Surrogates 低位替代 1023\n```\n\n* 高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。\n* 如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：\n\n```\n1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111\n```\n\n* 按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到\n\n```\n1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111\n```\n* 即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代。\n## UTF-32\n* UTF-32 是固定长度的编码，始终占用 4 个字节，足以容纳所有的 Unicode 字符，所以直接存储 Unicode 编号即可，不需要任何编码转换。浪费了空间，赢得了效率。\n* BOM（Byte Order Mark）\n\n```\n①为了保证编码和解码字节顺序问题（因为只有保证编码和解码的规则一致才能保证是同一个字符），所以Unicode规范中推荐的标记字节顺序的方法是BOM（Byte Order Mark）。\n②UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。根据BOM的规则，在一段字节流开始时，如果接收到以下字节，则分别表明了该文本文件的编码。\n\tUTF-8: EF BB BF\n\tUTF-16 : FF FE\n\tUTF-16 big-endian: FE FF\n\tUTF-32 little-endian: FF FE 00 00\n\tUTF-32 big-endian: 00 00 FE FF\n而如果不是以这个开头，那程序则会以ANSI，也就是系统默认编码读取。\n如同样是字符“A”﹐在以下几种格式中的存储形式分别是﹕\n\tUTF-16 big-endian : 00 41\n\tUTF-16 little-endian : 41 00\n\tUTF-32 big-endian : 00 00 00 41\n\tUTF-32 little-endian : 41 00 00 00\n```","slug":"密码学编码-三-Unicode编码","published":1,"updated":"2020-05-27T10:08:57.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18s002mvcu96tex1v2k","content":"<ul>\n<li><p>计算机发展早期，编码只有ASCII编码，但ASCII编码只能够用来表示拉丁字母、数字以及一些特殊符号，而语言不止英语一种，例如中文一个字节是不够表示的，最少需要两个字节，并且需要兼容ASCII编码，不能与之发生冲突。为了解决传统字符编码方案的局限性，所以Unicode编码应运而生。</p>\n</li>\n<li><p>Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p>\n</li>\n<li><p>在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。</p>\n</li>\n<li><p>几乎所有电脑系统都支持基本拉丁字母，并各自支持不同的其他编码方式。Unicode为了和它们相互兼容，其首256字符保留给ISO 8859-1所定义的字符，使既有的西欧语系文字的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。举例来说，全角格式区段包含了主要的拉丁字母的全角格式，在中文、日文、以及韩文字形当中，这些字符以全角的方式来呈现，而不以常见的半角形式显示，这对竖排文字和等宽排列文字有重要作用。</p>\n</li>\n<li><p>Unicode为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF(十六进制)，有110多万，每个字符都有一个唯一的Unicode编号，这个编号一般写成16进制，在前面加上U+。例如：“马”的Unicode是U+9A6C。</p>\n</li>\n<li><p>Unicode就相当于一张表，建立了字符与编号之间的联系,它是一种规定，Unicode本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。</p>\n</li>\n<li><p>除了直接转换为二进制的策略，Unicode 可以使用的编码有三种，分别是：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UFT-8：一种变长的编码方案，使用 1~6 个字节来存储；</span><br><span class=\"line\">UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；</span><br><span class=\"line\">UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>①Unicode其实应该是一个码值表。（百度百科：Unicode的功用是为每一个字符提供一个唯一的代码（即一组数字））。</p>\n</li>\n<li><p>②UTF-8/UTF-16/UTF-32是通过对Unicode码值进行对应规则转换后，编码保持到内存/文件中。UTF-8/UTF-16/UTF-32都是可变长度的编码方式。（后面将进行Unicode码值转换为UTF-8的说明）。</p>\n</li>\n<li><p>③我们平常说的 “Unicode编码是2个字节” 这句话，其实是因为windows默认的Unicode编码就是UTF-16，在常用基本字符上2个字节的编码方式已经够用导致的误解，其实是可变长度的。在没有特殊说明的情况下，常说的Unicode编码可以理解为UTF-16编码。</p>\n</li>\n<li><p>④UTF-32是因为UTF-16编码方式不能表示全部的字符而扩充的编码方式。</p>\n</li>\n<li><p>ps：显示的字符是表现形式，具体内存中的编码方式和字符显示之间通过中间层进行转换。（根据编码规则，1个字符可能对应内存中1个到几个字节。）</p>\n</li>\n<li><p>这里转换为二进制后计算机的储存问题：计算机在存储器中排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34</p>\n</li>\n<li><p>UTF-8编码不存在字节序大小端问题！（因为字节序只影响同时处理多于两个字节的编码方式，比如UTF-16/UTF-32，而UTF-8是按照单字节进行处理的）</p>\n</li>\n<li><p>UTF-8的解码都必须先读取首字节获取字节数，所以必须找到首字节的第一位要么是0，要么是110/1110/11110/111110/1111110，所以上面的“中”字，无论是保存为11100100 10111000 10101101还是10101101 10111000 11100100，都必须要先找到11100100这个字节，所以UTF-8从机制上就能避免字节序的问题。</p>\n</li>\n<li><p>UTF-16/UTF-32存在字节序问题（UTF-16常用情况下一次处理2个字节/UTF-32一次处理4个字节）！一个“奎”的Unicode码值是0x594E，“乙”的Unicode码值是0x4E59。如果我们的UTF-16字节数据是0x594E，那么这是“奎”还是“乙”？如果大端序，0x594E是“奎”，如果是小端序，0x4E59，是“乙”。</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-9.png\" alt=\"\"></p>\n<h2 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h2><ul>\n<li>UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。</span><br><span class=\"line\"></span><br><span class=\"line\">对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编码规则：<br><img src=\"/images/pasted-10.png\" alt=\"\"></li>\n</ul>\n<p><img src=\"/images/pasted-11.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-12.png\" alt=\"\"></p>\n<ul>\n<li>对于具体的Unicode编号，进行UTF-8编码的方法：</li>\n<li>首先找到该Unicode编号所在的编号范围，进而找到对应的二进制格式，然后将该Unicode编号转换为二进制数有（去掉高位的0）最后将该二进制数一次填充入二进制格式的X中，未填充的X变为0.</li>\n<li>例：马的Unicode编号是：0x9A6C，整数编号是39532，其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532对应的二进制为1001 1010 0110 1100，填入为：11101001 10101001 10101100</li>\n</ul>\n<h2 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h2><ul>\n<li>为了弄清楚UTF-16文件的大小尾序，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文字档案是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。</li>\n<li>使用2字节或者4字节进行编码</li>\n<li>字符按照UTF-16进行编码的规则是： - 字符的值小于0x10000的用等于该值的16位整数来表示。 - 字符的值介于0x10000和0x10FFFF之间的，用一个值介于0xD800和0xDBFF(在所谓的高8位区)的16位整数和值介于0xDC00和0xDFFF(在所谓的低8位区)的16位整数来表示。 - 字符的值大于0x10FFFF不能按照UTF-16进行编码。注意：在0xD800和0xDFFF间的值是特别为UTF-16预留，所以不应该将任何字符的值指定为这个区间内的数值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D800－DB7F High Surrogates 高位替代 895</span><br><span class=\"line\">DB80－DBFF High Private Use Surrogates 高位专用替代 127</span><br><span class=\"line\">DC00－DFFF Low Surrogates 低位替代 1023</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。</li>\n<li>如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>\n<ul>\n<li>即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代。<h2 id=\"UTF-32\"><a href=\"#UTF-32\" class=\"headerlink\" title=\"UTF-32\"></a>UTF-32</h2></li>\n<li>UTF-32 是固定长度的编码，始终占用 4 个字节，足以容纳所有的 Unicode 字符，所以直接存储 Unicode 编号即可，不需要任何编码转换。浪费了空间，赢得了效率。</li>\n<li>BOM（Byte Order Mark）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">①为了保证编码和解码字节顺序问题（因为只有保证编码和解码的规则一致才能保证是同一个字符），所以Unicode规范中推荐的标记字节顺序的方法是BOM（Byte Order Mark）。</span><br><span class=\"line\">②UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。根据BOM的规则，在一段字节流开始时，如果接收到以下字节，则分别表明了该文本文件的编码。</span><br><span class=\"line\">\tUTF-8: EF BB BF</span><br><span class=\"line\">\tUTF-16 : FF FE</span><br><span class=\"line\">\tUTF-16 big-endian: FE FF</span><br><span class=\"line\">\tUTF-32 little-endian: FF FE 00 00</span><br><span class=\"line\">\tUTF-32 big-endian: 00 00 FE FF</span><br><span class=\"line\">而如果不是以这个开头，那程序则会以ANSI，也就是系统默认编码读取。</span><br><span class=\"line\">如同样是字符“A”﹐在以下几种格式中的存储形式分别是﹕</span><br><span class=\"line\">\tUTF-16 big-endian : 00 41</span><br><span class=\"line\">\tUTF-16 little-endian : 41 00</span><br><span class=\"line\">\tUTF-32 big-endian : 00 00 00 41</span><br><span class=\"line\">\tUTF-32 little-endian : 41 00 00 00</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>计算机发展早期，编码只有ASCII编码，但ASCII编码只能够用来表示拉丁字母、数字以及一些特殊符号，而语言不止英语一种，例如中文一个字节是不够表示的，最少需要两个字节，并且需要兼容ASCII编码，不能与之发生冲突。为了解决传统字符编码方案的局限性，所以Unicode编码应运而生。</p>\n</li>\n<li><p>Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p>\n</li>\n<li><p>在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。</p>\n</li>\n<li><p>几乎所有电脑系统都支持基本拉丁字母，并各自支持不同的其他编码方式。Unicode为了和它们相互兼容，其首256字符保留给ISO 8859-1所定义的字符，使既有的西欧语系文字的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息。举例来说，全角格式区段包含了主要的拉丁字母的全角格式，在中文、日文、以及韩文字形当中，这些字符以全角的方式来呈现，而不以常见的半角形式显示，这对竖排文字和等宽排列文字有重要作用。</p>\n</li>\n<li><p>Unicode为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF(十六进制)，有110多万，每个字符都有一个唯一的Unicode编号，这个编号一般写成16进制，在前面加上U+。例如：“马”的Unicode是U+9A6C。</p>\n</li>\n<li><p>Unicode就相当于一张表，建立了字符与编号之间的联系,它是一种规定，Unicode本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。</p>\n</li>\n<li><p>除了直接转换为二进制的策略，Unicode 可以使用的编码有三种，分别是：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UFT-8：一种变长的编码方案，使用 1~6 个字节来存储；</span><br><span class=\"line\">UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；</span><br><span class=\"line\">UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>①Unicode其实应该是一个码值表。（百度百科：Unicode的功用是为每一个字符提供一个唯一的代码（即一组数字））。</p>\n</li>\n<li><p>②UTF-8/UTF-16/UTF-32是通过对Unicode码值进行对应规则转换后，编码保持到内存/文件中。UTF-8/UTF-16/UTF-32都是可变长度的编码方式。（后面将进行Unicode码值转换为UTF-8的说明）。</p>\n</li>\n<li><p>③我们平常说的 “Unicode编码是2个字节” 这句话，其实是因为windows默认的Unicode编码就是UTF-16，在常用基本字符上2个字节的编码方式已经够用导致的误解，其实是可变长度的。在没有特殊说明的情况下，常说的Unicode编码可以理解为UTF-16编码。</p>\n</li>\n<li><p>④UTF-32是因为UTF-16编码方式不能表示全部的字符而扩充的编码方式。</p>\n</li>\n<li><p>ps：显示的字符是表现形式，具体内存中的编码方式和字符显示之间通过中间层进行转换。（根据编码规则，1个字符可能对应内存中1个到几个字节。）</p>\n</li>\n<li><p>这里转换为二进制后计算机的储存问题：计算机在存储器中排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34</p>\n</li>\n<li><p>UTF-8编码不存在字节序大小端问题！（因为字节序只影响同时处理多于两个字节的编码方式，比如UTF-16/UTF-32，而UTF-8是按照单字节进行处理的）</p>\n</li>\n<li><p>UTF-8的解码都必须先读取首字节获取字节数，所以必须找到首字节的第一位要么是0，要么是110/1110/11110/111110/1111110，所以上面的“中”字，无论是保存为11100100 10111000 10101101还是10101101 10111000 11100100，都必须要先找到11100100这个字节，所以UTF-8从机制上就能避免字节序的问题。</p>\n</li>\n<li><p>UTF-16/UTF-32存在字节序问题（UTF-16常用情况下一次处理2个字节/UTF-32一次处理4个字节）！一个“奎”的Unicode码值是0x594E，“乙”的Unicode码值是0x4E59。如果我们的UTF-16字节数据是0x594E，那么这是“奎”还是“乙”？如果大端序，0x594E是“奎”，如果是小端序，0x4E59，是“乙”。</p>\n</li>\n</ul>\n<p><img src=\"/images/pasted-9.png\" alt=\"\"></p>\n<h2 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h2><ul>\n<li>UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。</span><br><span class=\"line\"></span><br><span class=\"line\">对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编码规则：<br><img src=\"/images/pasted-10.png\" alt=\"\"></li>\n</ul>\n<p><img src=\"/images/pasted-11.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-12.png\" alt=\"\"></p>\n<ul>\n<li>对于具体的Unicode编号，进行UTF-8编码的方法：</li>\n<li>首先找到该Unicode编号所在的编号范围，进而找到对应的二进制格式，然后将该Unicode编号转换为二进制数有（去掉高位的0）最后将该二进制数一次填充入二进制格式的X中，未填充的X变为0.</li>\n<li>例：马的Unicode编号是：0x9A6C，整数编号是39532，其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532对应的二进制为1001 1010 0110 1100，填入为：11101001 10101001 10101100</li>\n</ul>\n<h2 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h2><ul>\n<li>为了弄清楚UTF-16文件的大小尾序，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文字档案是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。</li>\n<li>使用2字节或者4字节进行编码</li>\n<li>字符按照UTF-16进行编码的规则是： - 字符的值小于0x10000的用等于该值的16位整数来表示。 - 字符的值介于0x10000和0x10FFFF之间的，用一个值介于0xD800和0xDBFF(在所谓的高8位区)的16位整数和值介于0xDC00和0xDFFF(在所谓的低8位区)的16位整数来表示。 - 字符的值大于0x10FFFF不能按照UTF-16进行编码。注意：在0xD800和0xDFFF间的值是特别为UTF-16预留，所以不应该将任何字符的值指定为这个区间内的数值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D800－DB7F High Surrogates 高位替代 895</span><br><span class=\"line\">DB80－DBFF High Private Use Surrogates 高位专用替代 127</span><br><span class=\"line\">DC00－DFFF Low Surrogates 低位替代 1023</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。</li>\n<li>如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>\n<ul>\n<li>即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代。<h2 id=\"UTF-32\"><a href=\"#UTF-32\" class=\"headerlink\" title=\"UTF-32\"></a>UTF-32</h2></li>\n<li>UTF-32 是固定长度的编码，始终占用 4 个字节，足以容纳所有的 Unicode 字符，所以直接存储 Unicode 编号即可，不需要任何编码转换。浪费了空间，赢得了效率。</li>\n<li>BOM（Byte Order Mark）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">①为了保证编码和解码字节顺序问题（因为只有保证编码和解码的规则一致才能保证是同一个字符），所以Unicode规范中推荐的标记字节顺序的方法是BOM（Byte Order Mark）。</span><br><span class=\"line\">②UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。根据BOM的规则，在一段字节流开始时，如果接收到以下字节，则分别表明了该文本文件的编码。</span><br><span class=\"line\">\tUTF-8: EF BB BF</span><br><span class=\"line\">\tUTF-16 : FF FE</span><br><span class=\"line\">\tUTF-16 big-endian: FE FF</span><br><span class=\"line\">\tUTF-32 little-endian: FF FE 00 00</span><br><span class=\"line\">\tUTF-32 big-endian: 00 00 FE FF</span><br><span class=\"line\">而如果不是以这个开头，那程序则会以ANSI，也就是系统默认编码读取。</span><br><span class=\"line\">如同样是字符“A”﹐在以下几种格式中的存储形式分别是﹕</span><br><span class=\"line\">\tUTF-16 big-endian : 00 41</span><br><span class=\"line\">\tUTF-16 little-endian : 41 00</span><br><span class=\"line\">\tUTF-32 big-endian : 00 00 00 41</span><br><span class=\"line\">\tUTF-32 little-endian : 41 00 00 00</span><br></pre></td></tr></table></figure>"},{"title":"网鼎杯2020青龙组crypto","author":"人生若只如初见","date":"2020-06-24T01:06:00.000Z","_content":"# Boom\n* IDA打开，发现有三个验证，第一个验证md5值相等，解密得到en5oy,第二个解密三元一次方程，得到x=74,y=68,z=31,第三个解一元二次方程，正整数根x=89127561，得到flag\n\n\n![](/images/pasted-31.png)\n\n\n![](/images/pasted-32.png)\n\n# You raise me up\n\n* sage求离散对数\n* 脚本如下：\n\n```\nimport binascii\nm = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075\nc = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499\nn=2**512\n\na=Mod(m,n)\nb=Mod(c,n)\n\nflag_bin=discrete_log(b,a)\nprint (binascii.unhexlify(hex(flag_bin)[2:].strip(\"L\")))\n```\n\n# easy_ya\n\n* nc每次连接会改变加密方式，直接爆破\n\n\n```\nfrom hashlib import *\nfrom pwn import *\nimport string\nimport itertools\n#context.log_level = \"debug\"\nio = remote(\"39.96.90.217\", \"17497\")\nio.recvuntil(\"= \")\nsuffix = io.recvline().strip().decode(\"utf-8\")\nprint(suffix)\nio.recvuntil(\"openssl_\")\nmode = io.recvuntil(\">\")[:-1].decode(\"utf-8\")\nprint(mode)\npts = itertools.product(string.printable, repeat=4)\nlen = 100**4\ncnt = 0\nfor pt in pts:\n    if cnt % 1000 == 0:\n        print(\"{}%\".format(100*cnt/len))\n    p = \"\".join(list(pt))\n    if mode == \"sha1\":\n        ct = sha1(p.encode()).hexdigest()\n    elif mode == \"sha224\":\n        ct = sha224(p.encode()).hexdigest()\n    elif mode == \"sha256\":\n        ct = sha256(p.encode()).hexdigest()\n    elif mode == \"sha384\":\n        ct = sha384(p.encode()).hexdigest()\n    elif mode == \"sha512\":\n        ct = sha512(p.encode()).hexdigest()\n    elif mode == \"md5\":\n        ct = md5(p.encode()).hexdigest()\n    else:\n        exit(0)\n    if ct[:20] == suffix:\n        print(p)\n        break\n    cnt += 1\nio.interactive()\n\n```\n\n* 提交token之后得到rsa中的n1 c1 n2 c2\n* 找到n1和n2的公约数，侧面分解n1,.n2\n* 解得ek是中文：愿我所爱无忧恙岁长安，根据ek生成规则得到key,算出题目的a,b,c,d\n\n\n* 题目在加密时，每8个字符作为一组，利用该组生成y和z然后对y和z进行运算，返回结果。注意到返回的结果为hex((y << 52) ^ (pads << 20) ^ z)\n* 所以可以知道\n\n```\n\t1.返回结果（视作84位）的前32位是y；\n\t2.返回结果的第33位至第54位为pads的前20位，第55位至第64位为pads的后12位和z的前12位异或的结果。\n```\n    \n* 注意到y和z一共运算了32轮，所以这时pads应该是limit(32*pad)，其后5位是0，所以pads的情况相当于：\n\n```\n????? ******** ******** ****???? ???00000\n```\n\n* 其中 * 代表已知，? 代表未知，0就是0。去掉后边5个0后，另外32位就是pad。\n* 这个pad中，未知的地方只有12位，总计4096种情况，每种情况对应唯一的z。\n* 所以可以通过爆破这4096种情况，逆推32轮得到初始的y和z，再观察其转为字符后是否在string.printable中来确定答案。完整代码如下\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport gmpy2\nfrom libnum import n2s,s2n\nimport string\n\nn1 = 523302236767994199900474363344509016779069116440336509402579663927023212822016176967224920257215697515649639915194389392664393435704126520500342935380422629852958893595198501678886910437288107490865842806189885864227955305292596726620737250011643028592306930279653650874633693082819617471411085797465171317473575199984137570425840763157847215554005503026976635376775672263338018024842152016782550728415532850496820668169596712488535626476321971915772540785626943870257914929277013026283202706480202573253694027965561121582254805059775814137542861056288774182091519461752761702279929984980399296157122817271523455097901334302748985253698791419583126820263035649222528798493821648538568572195005358978375666451378629463679501572550304224399031869931606326980885244883575380615433423693907673692911481956161922234589747374211957098461625670478121184734721478951324090304946630772999533103517416951906651316589244984076827527352185687877958699658011472950078992791104307370649334689901210147765149584862868749574640976109508247204313701721196275177445231013673265642224568068643851710967790673640935447579098048865343477978938147696617434878198467680874826616766904653374028721826187308127128623535689512750830887981058826202565202400511\nc1 = 498116479126828060721351777093052860074248131123861633687756928866328288114135612849582257727497809922257024131348207980532057240060103798568227977564521497134127080257805342446192248133124844549442334197110567598270256443362563074473166503647429611051333058467042150637666479765740465760837773368463067714839472516227071241189038004851446423799255357523722335018334006275302424683874359612832738469924300750750078529793617519763670882091967677827342326944222743651042579235831828367996040140715066967834876505105847352068608085060284716208922782057542541292881761158407247706056426656079240060590899310402168208571288608455268870805780135942398347873755131825844602660879197979908250552518202142180574849619997871142575611493295891685289794234943270549985371377356916876993228441993132176346052582480841840804748103391892367360829385946406970449784716173650039815882209635063166095389007982620077884907738945623441531598991729082106049943909989119158441101967074276580858829052824691525753913860208906309655761578594225039981683717544420716889594252263165426914121554799496094906541367521362681696570717997925590955291849918357945303214885384216817697786187947817980231717851370305526120464677525392225631245022522492166336294567990\nn2 = 536990588699972595171044696252776619032179414787125154102250364726703105272855466989014009336094247702108918440942171080587326115929077717421949560294869471182366684971337895133599697112193778007924450399107079732471847945598232349103839178632745959014098099259478108015237884846605377823461726458684486899249980041743056079896277510838968230729745020510029386228057731944169220820085059789541971092769832034181463596023438597531006332700648910769750936607476390311140301912742677001065893470340950419360642998700303488716826766066363262819042158064398656956185348135880225267894029419814797931720405594656777311094389676998338309809990367862926139317751409984908306801799152005179724137997626023826392780245630698648023945119617679627945415398046106871715475183890738417311925747430222040725394347022734489930069712092197629163647317772330355887387543008085150959104427391942023985298997288368357638062454066636100000548473809891299732343069825793293706407805782587150123342081839983609199059401502925783039760450730519603070519136086703825438807058787688044991172737575437559249668471352046085614345186161595152256193672994722540039920217058451215889862638946510188311582046866299423997659515395934871167522463706085186962242421859\nc2 = 164402111514416870480151927449107349163820084533580709383993929301187569338852498622073106678649496858117593538947720740640339668153033620409471744700183709591276280704323985437330452541949262852531710176243561888397374683972759177181684560891529123569371241980602358823138808014488471284855401456011020109937046905434967828616466812821052222924691090808870700970795942705766163862790406417148540210339722273902825469460099520769061522024042123766536620554426683612099219790921573403278241760344418925630823806366949039901279532624187976211611528860461687073096888450694175459321193571925480949635977079339284905452476161156840739751431793628217796061271713787710176980187083301171958573364765677389306720995362317264018186392366551999368657422142163919262968449796794407119199996178284891867472060688293602896147398028717874542567143635071645595076767066361989345197270110842062044509038468406120271061465308775126927579741460684420290619983532930017201223504143911140388202527374930493248620993306321032961537876323380443523093814730204234290659449391857198796743587265894069493376291713198073023178977070834614584650913597763729414655680380751407408769289343905637501434637829997447542901620528323133332447667258731683700542347651\np = gmpy2.gcd(n1, n2)\nq1 = n1 // p\nq2 = n2 // p\ne = 0x10001\nphi1 = (p-1)*(q1-1)\nd1 = gmpy2.invert(e, phi1)\nm = pow(c1, d1, n1)\nek = n2s(m)\n\nkey = '8891898088b197a0bfa78199b28195bfae89'.decode('hex')\nlimit = lambda n: n & 0xffffffff\n\nKey  = [ord(i) for i in key]\na = limit((Key[0] << 24) | (Key[1] << 16) | (Key[2] << 8) | Key[3])\nb = limit((Key[4] << 24) | (Key[5] << 16) | (Key[6] << 8) | Key[7])\nc = limit((Key[8] << 24) | (Key[9] << 16) | (Key[10] << 8) | Key[11])\nd = limit((Key[12] << 24) | (Key[13] << 16) | (Key[14] << 8) | Key[15])\n\noutputs = [0x65d4ce3b0b1b3f48bb9fdL, 0xf0230f43414a9c9ac0488L, 0xbd592ebe04025b783fb5bL, 0x28d194dcd1c79b4bb8074L, 0x7c493be8f0fdbb740ec29L]\n\ndef reversecalc(a, b, c, d, y, z, pad):\n    for i in range(32, 0, -1):\n        # print 'Round %d: %d, %d' % (i, y, z)\n        pads = limit(pad * i)\n        paramz = (y*16+c)^(y+pads)^((y>>5)+d)\n        if(z < paramz):\n            z = limit(z - paramz + 0x100000000)\n        else:\n            z = limit(z - paramz)\n        paramy = (z*16+a)^(z+pads)^((z>>5)+b)\n        if(y < paramy):\n            y = limit(y - paramy + 0x100000000)\n        else:\n            y = limit(y - paramy)\n        # print (y, z)\n    return y, z\n\nfor output in outputs:\n    print hex(output)\n    binout = bin(output)[2:]\n    binout = '0'*(84-len(binout))+binout\n    y = int(binout[:32], 2)\n    for i in range(4096):\n        bini = bin(i)[2:]\n        bini = '0'*(12-len(bini))+bini\n        tmpbinpads = bini[0:5] + binout[32:52] + bini[5:12] + '00000'\n        pad = int(tmpbinpads, 2) / 32\n        pads = limit(int(tmpbinpads, 2))\n        z = output ^ (y<<52) ^ (pads<<20)\n        y0, z0 = reversecalc(a, b, c, d, y, z, pad)\n        tmpstr = n2s(y0)+n2s(z0)\n        valid = True\n        for j in tmpstr:\n            if (not j in string.printable)and(j != '\\x00'):\n                valid = False\n                break\n        if(valid):\n            print tmpstr\n```\n\n* 输出结果：\n\n```\n0x65d4ce3b0b1b3f48bb9fdL\nS60 '\\M(\nflag{5fe\n0xf0230f43414a9c9ac0488L\n86c73a3e\n0xbd592ebe04025b783fb5bL\nUs\nNU\\KNP-F\n381ee168\n0x28d194dcd1c79b4bb8074L\n)^C04<b5\nZ\"N*'U_x000C_=\n83c04451\nGNM1!Uyl\n0x7c493be8f0fdbb740ec29L\n9o`YE\n1356f}\nQG_x000C_rVHZo\n7ju-px/_x000C\n```\n\n* 寻找其中看起来像的拼接得到flag\n\n\n","source":"_posts/网鼎杯2020青龙组crypto.md","raw":"title: 网鼎杯2020青龙组crypto\nauthor: 人生若只如初见\ntags: []\ncategories:\n  - ctf\ndate: 2020-06-24 09:06:00\n---\n# Boom\n* IDA打开，发现有三个验证，第一个验证md5值相等，解密得到en5oy,第二个解密三元一次方程，得到x=74,y=68,z=31,第三个解一元二次方程，正整数根x=89127561，得到flag\n\n\n![](/images/pasted-31.png)\n\n\n![](/images/pasted-32.png)\n\n# You raise me up\n\n* sage求离散对数\n* 脚本如下：\n\n```\nimport binascii\nm = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075\nc = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499\nn=2**512\n\na=Mod(m,n)\nb=Mod(c,n)\n\nflag_bin=discrete_log(b,a)\nprint (binascii.unhexlify(hex(flag_bin)[2:].strip(\"L\")))\n```\n\n# easy_ya\n\n* nc每次连接会改变加密方式，直接爆破\n\n\n```\nfrom hashlib import *\nfrom pwn import *\nimport string\nimport itertools\n#context.log_level = \"debug\"\nio = remote(\"39.96.90.217\", \"17497\")\nio.recvuntil(\"= \")\nsuffix = io.recvline().strip().decode(\"utf-8\")\nprint(suffix)\nio.recvuntil(\"openssl_\")\nmode = io.recvuntil(\">\")[:-1].decode(\"utf-8\")\nprint(mode)\npts = itertools.product(string.printable, repeat=4)\nlen = 100**4\ncnt = 0\nfor pt in pts:\n    if cnt % 1000 == 0:\n        print(\"{}%\".format(100*cnt/len))\n    p = \"\".join(list(pt))\n    if mode == \"sha1\":\n        ct = sha1(p.encode()).hexdigest()\n    elif mode == \"sha224\":\n        ct = sha224(p.encode()).hexdigest()\n    elif mode == \"sha256\":\n        ct = sha256(p.encode()).hexdigest()\n    elif mode == \"sha384\":\n        ct = sha384(p.encode()).hexdigest()\n    elif mode == \"sha512\":\n        ct = sha512(p.encode()).hexdigest()\n    elif mode == \"md5\":\n        ct = md5(p.encode()).hexdigest()\n    else:\n        exit(0)\n    if ct[:20] == suffix:\n        print(p)\n        break\n    cnt += 1\nio.interactive()\n\n```\n\n* 提交token之后得到rsa中的n1 c1 n2 c2\n* 找到n1和n2的公约数，侧面分解n1,.n2\n* 解得ek是中文：愿我所爱无忧恙岁长安，根据ek生成规则得到key,算出题目的a,b,c,d\n\n\n* 题目在加密时，每8个字符作为一组，利用该组生成y和z然后对y和z进行运算，返回结果。注意到返回的结果为hex((y << 52) ^ (pads << 20) ^ z)\n* 所以可以知道\n\n```\n\t1.返回结果（视作84位）的前32位是y；\n\t2.返回结果的第33位至第54位为pads的前20位，第55位至第64位为pads的后12位和z的前12位异或的结果。\n```\n    \n* 注意到y和z一共运算了32轮，所以这时pads应该是limit(32*pad)，其后5位是0，所以pads的情况相当于：\n\n```\n????? ******** ******** ****???? ???00000\n```\n\n* 其中 * 代表已知，? 代表未知，0就是0。去掉后边5个0后，另外32位就是pad。\n* 这个pad中，未知的地方只有12位，总计4096种情况，每种情况对应唯一的z。\n* 所以可以通过爆破这4096种情况，逆推32轮得到初始的y和z，再观察其转为字符后是否在string.printable中来确定答案。完整代码如下\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport gmpy2\nfrom libnum import n2s,s2n\nimport string\n\nn1 = 523302236767994199900474363344509016779069116440336509402579663927023212822016176967224920257215697515649639915194389392664393435704126520500342935380422629852958893595198501678886910437288107490865842806189885864227955305292596726620737250011643028592306930279653650874633693082819617471411085797465171317473575199984137570425840763157847215554005503026976635376775672263338018024842152016782550728415532850496820668169596712488535626476321971915772540785626943870257914929277013026283202706480202573253694027965561121582254805059775814137542861056288774182091519461752761702279929984980399296157122817271523455097901334302748985253698791419583126820263035649222528798493821648538568572195005358978375666451378629463679501572550304224399031869931606326980885244883575380615433423693907673692911481956161922234589747374211957098461625670478121184734721478951324090304946630772999533103517416951906651316589244984076827527352185687877958699658011472950078992791104307370649334689901210147765149584862868749574640976109508247204313701721196275177445231013673265642224568068643851710967790673640935447579098048865343477978938147696617434878198467680874826616766904653374028721826187308127128623535689512750830887981058826202565202400511\nc1 = 498116479126828060721351777093052860074248131123861633687756928866328288114135612849582257727497809922257024131348207980532057240060103798568227977564521497134127080257805342446192248133124844549442334197110567598270256443362563074473166503647429611051333058467042150637666479765740465760837773368463067714839472516227071241189038004851446423799255357523722335018334006275302424683874359612832738469924300750750078529793617519763670882091967677827342326944222743651042579235831828367996040140715066967834876505105847352068608085060284716208922782057542541292881761158407247706056426656079240060590899310402168208571288608455268870805780135942398347873755131825844602660879197979908250552518202142180574849619997871142575611493295891685289794234943270549985371377356916876993228441993132176346052582480841840804748103391892367360829385946406970449784716173650039815882209635063166095389007982620077884907738945623441531598991729082106049943909989119158441101967074276580858829052824691525753913860208906309655761578594225039981683717544420716889594252263165426914121554799496094906541367521362681696570717997925590955291849918357945303214885384216817697786187947817980231717851370305526120464677525392225631245022522492166336294567990\nn2 = 536990588699972595171044696252776619032179414787125154102250364726703105272855466989014009336094247702108918440942171080587326115929077717421949560294869471182366684971337895133599697112193778007924450399107079732471847945598232349103839178632745959014098099259478108015237884846605377823461726458684486899249980041743056079896277510838968230729745020510029386228057731944169220820085059789541971092769832034181463596023438597531006332700648910769750936607476390311140301912742677001065893470340950419360642998700303488716826766066363262819042158064398656956185348135880225267894029419814797931720405594656777311094389676998338309809990367862926139317751409984908306801799152005179724137997626023826392780245630698648023945119617679627945415398046106871715475183890738417311925747430222040725394347022734489930069712092197629163647317772330355887387543008085150959104427391942023985298997288368357638062454066636100000548473809891299732343069825793293706407805782587150123342081839983609199059401502925783039760450730519603070519136086703825438807058787688044991172737575437559249668471352046085614345186161595152256193672994722540039920217058451215889862638946510188311582046866299423997659515395934871167522463706085186962242421859\nc2 = 164402111514416870480151927449107349163820084533580709383993929301187569338852498622073106678649496858117593538947720740640339668153033620409471744700183709591276280704323985437330452541949262852531710176243561888397374683972759177181684560891529123569371241980602358823138808014488471284855401456011020109937046905434967828616466812821052222924691090808870700970795942705766163862790406417148540210339722273902825469460099520769061522024042123766536620554426683612099219790921573403278241760344418925630823806366949039901279532624187976211611528860461687073096888450694175459321193571925480949635977079339284905452476161156840739751431793628217796061271713787710176980187083301171958573364765677389306720995362317264018186392366551999368657422142163919262968449796794407119199996178284891867472060688293602896147398028717874542567143635071645595076767066361989345197270110842062044509038468406120271061465308775126927579741460684420290619983532930017201223504143911140388202527374930493248620993306321032961537876323380443523093814730204234290659449391857198796743587265894069493376291713198073023178977070834614584650913597763729414655680380751407408769289343905637501434637829997447542901620528323133332447667258731683700542347651\np = gmpy2.gcd(n1, n2)\nq1 = n1 // p\nq2 = n2 // p\ne = 0x10001\nphi1 = (p-1)*(q1-1)\nd1 = gmpy2.invert(e, phi1)\nm = pow(c1, d1, n1)\nek = n2s(m)\n\nkey = '8891898088b197a0bfa78199b28195bfae89'.decode('hex')\nlimit = lambda n: n & 0xffffffff\n\nKey  = [ord(i) for i in key]\na = limit((Key[0] << 24) | (Key[1] << 16) | (Key[2] << 8) | Key[3])\nb = limit((Key[4] << 24) | (Key[5] << 16) | (Key[6] << 8) | Key[7])\nc = limit((Key[8] << 24) | (Key[9] << 16) | (Key[10] << 8) | Key[11])\nd = limit((Key[12] << 24) | (Key[13] << 16) | (Key[14] << 8) | Key[15])\n\noutputs = [0x65d4ce3b0b1b3f48bb9fdL, 0xf0230f43414a9c9ac0488L, 0xbd592ebe04025b783fb5bL, 0x28d194dcd1c79b4bb8074L, 0x7c493be8f0fdbb740ec29L]\n\ndef reversecalc(a, b, c, d, y, z, pad):\n    for i in range(32, 0, -1):\n        # print 'Round %d: %d, %d' % (i, y, z)\n        pads = limit(pad * i)\n        paramz = (y*16+c)^(y+pads)^((y>>5)+d)\n        if(z < paramz):\n            z = limit(z - paramz + 0x100000000)\n        else:\n            z = limit(z - paramz)\n        paramy = (z*16+a)^(z+pads)^((z>>5)+b)\n        if(y < paramy):\n            y = limit(y - paramy + 0x100000000)\n        else:\n            y = limit(y - paramy)\n        # print (y, z)\n    return y, z\n\nfor output in outputs:\n    print hex(output)\n    binout = bin(output)[2:]\n    binout = '0'*(84-len(binout))+binout\n    y = int(binout[:32], 2)\n    for i in range(4096):\n        bini = bin(i)[2:]\n        bini = '0'*(12-len(bini))+bini\n        tmpbinpads = bini[0:5] + binout[32:52] + bini[5:12] + '00000'\n        pad = int(tmpbinpads, 2) / 32\n        pads = limit(int(tmpbinpads, 2))\n        z = output ^ (y<<52) ^ (pads<<20)\n        y0, z0 = reversecalc(a, b, c, d, y, z, pad)\n        tmpstr = n2s(y0)+n2s(z0)\n        valid = True\n        for j in tmpstr:\n            if (not j in string.printable)and(j != '\\x00'):\n                valid = False\n                break\n        if(valid):\n            print tmpstr\n```\n\n* 输出结果：\n\n```\n0x65d4ce3b0b1b3f48bb9fdL\nS60 '\\M(\nflag{5fe\n0xf0230f43414a9c9ac0488L\n86c73a3e\n0xbd592ebe04025b783fb5bL\nUs\nNU\\KNP-F\n381ee168\n0x28d194dcd1c79b4bb8074L\n)^C04<b5\nZ\"N*'U_x000C_=\n83c04451\nGNM1!Uyl\n0x7c493be8f0fdbb740ec29L\n9o`YE\n1356f}\nQG_x000C_rVHZo\n7ju-px/_x000C\n```\n\n* 寻找其中看起来像的拼接得到flag\n\n\n","slug":"网鼎杯2020青龙组crypto","published":1,"updated":"2020-06-24T01:16:23.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi5r18t002ovcu99gmg325e","content":"<h1 id=\"Boom\"><a href=\"#Boom\" class=\"headerlink\" title=\"Boom\"></a>Boom</h1><ul>\n<li>IDA打开，发现有三个验证，第一个验证md5值相等，解密得到en5oy,第二个解密三元一次方程，得到x=74,y=68,z=31,第三个解一元二次方程，正整数根x=89127561，得到flag</li>\n</ul>\n<p><img src=\"/images/pasted-31.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-32.png\" alt=\"\"></p>\n<h1 id=\"You-raise-me-up\"><a href=\"#You-raise-me-up\" class=\"headerlink\" title=\"You raise me up\"></a>You raise me up</h1><ul>\n<li>sage求离散对数</li>\n<li>脚本如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import binascii</span><br><span class=\"line\">m &#x3D; 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075</span><br><span class=\"line\">c &#x3D; 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499</span><br><span class=\"line\">n&#x3D;2**512</span><br><span class=\"line\"></span><br><span class=\"line\">a&#x3D;Mod(m,n)</span><br><span class=\"line\">b&#x3D;Mod(c,n)</span><br><span class=\"line\"></span><br><span class=\"line\">flag_bin&#x3D;discrete_log(b,a)</span><br><span class=\"line\">print (binascii.unhexlify(hex(flag_bin)[2:].strip(&quot;L&quot;)))</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"easy-ya\"><a href=\"#easy-ya\" class=\"headerlink\" title=\"easy_ya\"></a>easy_ya</h1><ul>\n<li>nc每次连接会改变加密方式，直接爆破</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from hashlib import *</span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\">import string</span><br><span class=\"line\">import itertools</span><br><span class=\"line\">#context.log_level &#x3D; &quot;debug&quot;</span><br><span class=\"line\">io &#x3D; remote(&quot;39.96.90.217&quot;, &quot;17497&quot;)</span><br><span class=\"line\">io.recvuntil(&quot;&#x3D; &quot;)</span><br><span class=\"line\">suffix &#x3D; io.recvline().strip().decode(&quot;utf-8&quot;)</span><br><span class=\"line\">print(suffix)</span><br><span class=\"line\">io.recvuntil(&quot;openssl_&quot;)</span><br><span class=\"line\">mode &#x3D; io.recvuntil(&quot;&gt;&quot;)[:-1].decode(&quot;utf-8&quot;)</span><br><span class=\"line\">print(mode)</span><br><span class=\"line\">pts &#x3D; itertools.product(string.printable, repeat&#x3D;4)</span><br><span class=\"line\">len &#x3D; 100**4</span><br><span class=\"line\">cnt &#x3D; 0</span><br><span class=\"line\">for pt in pts:</span><br><span class=\"line\">    if cnt % 1000 &#x3D;&#x3D; 0:</span><br><span class=\"line\">        print(&quot;&#123;&#125;%&quot;.format(100*cnt&#x2F;len))</span><br><span class=\"line\">    p &#x3D; &quot;&quot;.join(list(pt))</span><br><span class=\"line\">    if mode &#x3D;&#x3D; &quot;sha1&quot;:</span><br><span class=\"line\">        ct &#x3D; sha1(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha224&quot;:</span><br><span class=\"line\">        ct &#x3D; sha224(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha256&quot;:</span><br><span class=\"line\">        ct &#x3D; sha256(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha384&quot;:</span><br><span class=\"line\">        ct &#x3D; sha384(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha512&quot;:</span><br><span class=\"line\">        ct &#x3D; sha512(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;md5&quot;:</span><br><span class=\"line\">        ct &#x3D; md5(p.encode()).hexdigest()</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        exit(0)</span><br><span class=\"line\">    if ct[:20] &#x3D;&#x3D; suffix:</span><br><span class=\"line\">        print(p)</span><br><span class=\"line\">        break</span><br><span class=\"line\">    cnt +&#x3D; 1</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提交token之后得到rsa中的n1 c1 n2 c2</li>\n<li>找到n1和n2的公约数，侧面分解n1,.n2</li>\n<li>解得ek是中文：愿我所爱无忧恙岁长安，根据ek生成规则得到key,算出题目的a,b,c,d</li>\n</ul>\n<ul>\n<li>题目在加密时，每8个字符作为一组，利用该组生成y和z然后对y和z进行运算，返回结果。注意到返回的结果为hex((y &lt;&lt; 52) ^ (pads &lt;&lt; 20) ^ z)</li>\n<li>所以可以知道</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.返回结果（视作84位）的前32位是y；</span><br><span class=\"line\">2.返回结果的第33位至第54位为pads的前20位，第55位至第64位为pads的后12位和z的前12位异或的结果。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意到y和z一共运算了32轮，所以这时pads应该是limit(32*pad)，其后5位是0，所以pads的情况相当于：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">????? ******** ******** ****???? ???00000</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其中 * 代表已知，? 代表未知，0就是0。去掉后边5个0后，另外32位就是pad。</li>\n<li>这个pad中，未知的地方只有12位，总计4096种情况，每种情况对应唯一的z。</li>\n<li>所以可以通过爆破这4096种情况，逆推32轮得到初始的y和z，再观察其转为字符后是否在string.printable中来确定答案。完整代码如下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">import gmpy2</span><br><span class=\"line\">from libnum import n2s,s2n</span><br><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">n1 &#x3D; 523302236767994199900474363344509016779069116440336509402579663927023212822016176967224920257215697515649639915194389392664393435704126520500342935380422629852958893595198501678886910437288107490865842806189885864227955305292596726620737250011643028592306930279653650874633693082819617471411085797465171317473575199984137570425840763157847215554005503026976635376775672263338018024842152016782550728415532850496820668169596712488535626476321971915772540785626943870257914929277013026283202706480202573253694027965561121582254805059775814137542861056288774182091519461752761702279929984980399296157122817271523455097901334302748985253698791419583126820263035649222528798493821648538568572195005358978375666451378629463679501572550304224399031869931606326980885244883575380615433423693907673692911481956161922234589747374211957098461625670478121184734721478951324090304946630772999533103517416951906651316589244984076827527352185687877958699658011472950078992791104307370649334689901210147765149584862868749574640976109508247204313701721196275177445231013673265642224568068643851710967790673640935447579098048865343477978938147696617434878198467680874826616766904653374028721826187308127128623535689512750830887981058826202565202400511</span><br><span class=\"line\">c1 &#x3D; 498116479126828060721351777093052860074248131123861633687756928866328288114135612849582257727497809922257024131348207980532057240060103798568227977564521497134127080257805342446192248133124844549442334197110567598270256443362563074473166503647429611051333058467042150637666479765740465760837773368463067714839472516227071241189038004851446423799255357523722335018334006275302424683874359612832738469924300750750078529793617519763670882091967677827342326944222743651042579235831828367996040140715066967834876505105847352068608085060284716208922782057542541292881761158407247706056426656079240060590899310402168208571288608455268870805780135942398347873755131825844602660879197979908250552518202142180574849619997871142575611493295891685289794234943270549985371377356916876993228441993132176346052582480841840804748103391892367360829385946406970449784716173650039815882209635063166095389007982620077884907738945623441531598991729082106049943909989119158441101967074276580858829052824691525753913860208906309655761578594225039981683717544420716889594252263165426914121554799496094906541367521362681696570717997925590955291849918357945303214885384216817697786187947817980231717851370305526120464677525392225631245022522492166336294567990</span><br><span class=\"line\">n2 &#x3D; 536990588699972595171044696252776619032179414787125154102250364726703105272855466989014009336094247702108918440942171080587326115929077717421949560294869471182366684971337895133599697112193778007924450399107079732471847945598232349103839178632745959014098099259478108015237884846605377823461726458684486899249980041743056079896277510838968230729745020510029386228057731944169220820085059789541971092769832034181463596023438597531006332700648910769750936607476390311140301912742677001065893470340950419360642998700303488716826766066363262819042158064398656956185348135880225267894029419814797931720405594656777311094389676998338309809990367862926139317751409984908306801799152005179724137997626023826392780245630698648023945119617679627945415398046106871715475183890738417311925747430222040725394347022734489930069712092197629163647317772330355887387543008085150959104427391942023985298997288368357638062454066636100000548473809891299732343069825793293706407805782587150123342081839983609199059401502925783039760450730519603070519136086703825438807058787688044991172737575437559249668471352046085614345186161595152256193672994722540039920217058451215889862638946510188311582046866299423997659515395934871167522463706085186962242421859</span><br><span class=\"line\">c2 &#x3D; 164402111514416870480151927449107349163820084533580709383993929301187569338852498622073106678649496858117593538947720740640339668153033620409471744700183709591276280704323985437330452541949262852531710176243561888397374683972759177181684560891529123569371241980602358823138808014488471284855401456011020109937046905434967828616466812821052222924691090808870700970795942705766163862790406417148540210339722273902825469460099520769061522024042123766536620554426683612099219790921573403278241760344418925630823806366949039901279532624187976211611528860461687073096888450694175459321193571925480949635977079339284905452476161156840739751431793628217796061271713787710176980187083301171958573364765677389306720995362317264018186392366551999368657422142163919262968449796794407119199996178284891867472060688293602896147398028717874542567143635071645595076767066361989345197270110842062044509038468406120271061465308775126927579741460684420290619983532930017201223504143911140388202527374930493248620993306321032961537876323380443523093814730204234290659449391857198796743587265894069493376291713198073023178977070834614584650913597763729414655680380751407408769289343905637501434637829997447542901620528323133332447667258731683700542347651</span><br><span class=\"line\">p &#x3D; gmpy2.gcd(n1, n2)</span><br><span class=\"line\">q1 &#x3D; n1 &#x2F;&#x2F; p</span><br><span class=\"line\">q2 &#x3D; n2 &#x2F;&#x2F; p</span><br><span class=\"line\">e &#x3D; 0x10001</span><br><span class=\"line\">phi1 &#x3D; (p-1)*(q1-1)</span><br><span class=\"line\">d1 &#x3D; gmpy2.invert(e, phi1)</span><br><span class=\"line\">m &#x3D; pow(c1, d1, n1)</span><br><span class=\"line\">ek &#x3D; n2s(m)</span><br><span class=\"line\"></span><br><span class=\"line\">key &#x3D; &#39;8891898088b197a0bfa78199b28195bfae89&#39;.decode(&#39;hex&#39;)</span><br><span class=\"line\">limit &#x3D; lambda n: n &amp; 0xffffffff</span><br><span class=\"line\"></span><br><span class=\"line\">Key  &#x3D; [ord(i) for i in key]</span><br><span class=\"line\">a &#x3D; limit((Key[0] &lt;&lt; 24) | (Key[1] &lt;&lt; 16) | (Key[2] &lt;&lt; 8) | Key[3])</span><br><span class=\"line\">b &#x3D; limit((Key[4] &lt;&lt; 24) | (Key[5] &lt;&lt; 16) | (Key[6] &lt;&lt; 8) | Key[7])</span><br><span class=\"line\">c &#x3D; limit((Key[8] &lt;&lt; 24) | (Key[9] &lt;&lt; 16) | (Key[10] &lt;&lt; 8) | Key[11])</span><br><span class=\"line\">d &#x3D; limit((Key[12] &lt;&lt; 24) | (Key[13] &lt;&lt; 16) | (Key[14] &lt;&lt; 8) | Key[15])</span><br><span class=\"line\"></span><br><span class=\"line\">outputs &#x3D; [0x65d4ce3b0b1b3f48bb9fdL, 0xf0230f43414a9c9ac0488L, 0xbd592ebe04025b783fb5bL, 0x28d194dcd1c79b4bb8074L, 0x7c493be8f0fdbb740ec29L]</span><br><span class=\"line\"></span><br><span class=\"line\">def reversecalc(a, b, c, d, y, z, pad):</span><br><span class=\"line\">    for i in range(32, 0, -1):</span><br><span class=\"line\">        # print &#39;Round %d: %d, %d&#39; % (i, y, z)</span><br><span class=\"line\">        pads &#x3D; limit(pad * i)</span><br><span class=\"line\">        paramz &#x3D; (y*16+c)^(y+pads)^((y&gt;&gt;5)+d)</span><br><span class=\"line\">        if(z &lt; paramz):</span><br><span class=\"line\">            z &#x3D; limit(z - paramz + 0x100000000)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            z &#x3D; limit(z - paramz)</span><br><span class=\"line\">        paramy &#x3D; (z*16+a)^(z+pads)^((z&gt;&gt;5)+b)</span><br><span class=\"line\">        if(y &lt; paramy):</span><br><span class=\"line\">            y &#x3D; limit(y - paramy + 0x100000000)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y &#x3D; limit(y - paramy)</span><br><span class=\"line\">        # print (y, z)</span><br><span class=\"line\">    return y, z</span><br><span class=\"line\"></span><br><span class=\"line\">for output in outputs:</span><br><span class=\"line\">    print hex(output)</span><br><span class=\"line\">    binout &#x3D; bin(output)[2:]</span><br><span class=\"line\">    binout &#x3D; &#39;0&#39;*(84-len(binout))+binout</span><br><span class=\"line\">    y &#x3D; int(binout[:32], 2)</span><br><span class=\"line\">    for i in range(4096):</span><br><span class=\"line\">        bini &#x3D; bin(i)[2:]</span><br><span class=\"line\">        bini &#x3D; &#39;0&#39;*(12-len(bini))+bini</span><br><span class=\"line\">        tmpbinpads &#x3D; bini[0:5] + binout[32:52] + bini[5:12] + &#39;00000&#39;</span><br><span class=\"line\">        pad &#x3D; int(tmpbinpads, 2) &#x2F; 32</span><br><span class=\"line\">        pads &#x3D; limit(int(tmpbinpads, 2))</span><br><span class=\"line\">        z &#x3D; output ^ (y&lt;&lt;52) ^ (pads&lt;&lt;20)</span><br><span class=\"line\">        y0, z0 &#x3D; reversecalc(a, b, c, d, y, z, pad)</span><br><span class=\"line\">        tmpstr &#x3D; n2s(y0)+n2s(z0)</span><br><span class=\"line\">        valid &#x3D; True</span><br><span class=\"line\">        for j in tmpstr:</span><br><span class=\"line\">            if (not j in string.printable)and(j !&#x3D; &#39;\\x00&#39;):</span><br><span class=\"line\">                valid &#x3D; False</span><br><span class=\"line\">                break</span><br><span class=\"line\">        if(valid):</span><br><span class=\"line\">            print tmpstr</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>输出结果：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x65d4ce3b0b1b3f48bb9fdL</span><br><span class=\"line\">S60 &#39;\\M(</span><br><span class=\"line\">flag&#123;5fe</span><br><span class=\"line\">0xf0230f43414a9c9ac0488L</span><br><span class=\"line\">86c73a3e</span><br><span class=\"line\">0xbd592ebe04025b783fb5bL</span><br><span class=\"line\">Us</span><br><span class=\"line\">NU\\KNP-F</span><br><span class=\"line\">381ee168</span><br><span class=\"line\">0x28d194dcd1c79b4bb8074L</span><br><span class=\"line\">)^C04&lt;b5</span><br><span class=\"line\">Z&quot;N*&#39;U_x000C_&#x3D;</span><br><span class=\"line\">83c04451</span><br><span class=\"line\">GNM1!Uyl</span><br><span class=\"line\">0x7c493be8f0fdbb740ec29L</span><br><span class=\"line\">9o&#96;YE</span><br><span class=\"line\">1356f&#125;</span><br><span class=\"line\">QG_x000C_rVHZo</span><br><span class=\"line\">7ju-px&#x2F;_x000C</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>寻找其中看起来像的拼接得到flag</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Boom\"><a href=\"#Boom\" class=\"headerlink\" title=\"Boom\"></a>Boom</h1><ul>\n<li>IDA打开，发现有三个验证，第一个验证md5值相等，解密得到en5oy,第二个解密三元一次方程，得到x=74,y=68,z=31,第三个解一元二次方程，正整数根x=89127561，得到flag</li>\n</ul>\n<p><img src=\"/images/pasted-31.png\" alt=\"\"></p>\n<p><img src=\"/images/pasted-32.png\" alt=\"\"></p>\n<h1 id=\"You-raise-me-up\"><a href=\"#You-raise-me-up\" class=\"headerlink\" title=\"You raise me up\"></a>You raise me up</h1><ul>\n<li>sage求离散对数</li>\n<li>脚本如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import binascii</span><br><span class=\"line\">m &#x3D; 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075</span><br><span class=\"line\">c &#x3D; 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499</span><br><span class=\"line\">n&#x3D;2**512</span><br><span class=\"line\"></span><br><span class=\"line\">a&#x3D;Mod(m,n)</span><br><span class=\"line\">b&#x3D;Mod(c,n)</span><br><span class=\"line\"></span><br><span class=\"line\">flag_bin&#x3D;discrete_log(b,a)</span><br><span class=\"line\">print (binascii.unhexlify(hex(flag_bin)[2:].strip(&quot;L&quot;)))</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"easy-ya\"><a href=\"#easy-ya\" class=\"headerlink\" title=\"easy_ya\"></a>easy_ya</h1><ul>\n<li>nc每次连接会改变加密方式，直接爆破</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from hashlib import *</span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\">import string</span><br><span class=\"line\">import itertools</span><br><span class=\"line\">#context.log_level &#x3D; &quot;debug&quot;</span><br><span class=\"line\">io &#x3D; remote(&quot;39.96.90.217&quot;, &quot;17497&quot;)</span><br><span class=\"line\">io.recvuntil(&quot;&#x3D; &quot;)</span><br><span class=\"line\">suffix &#x3D; io.recvline().strip().decode(&quot;utf-8&quot;)</span><br><span class=\"line\">print(suffix)</span><br><span class=\"line\">io.recvuntil(&quot;openssl_&quot;)</span><br><span class=\"line\">mode &#x3D; io.recvuntil(&quot;&gt;&quot;)[:-1].decode(&quot;utf-8&quot;)</span><br><span class=\"line\">print(mode)</span><br><span class=\"line\">pts &#x3D; itertools.product(string.printable, repeat&#x3D;4)</span><br><span class=\"line\">len &#x3D; 100**4</span><br><span class=\"line\">cnt &#x3D; 0</span><br><span class=\"line\">for pt in pts:</span><br><span class=\"line\">    if cnt % 1000 &#x3D;&#x3D; 0:</span><br><span class=\"line\">        print(&quot;&#123;&#125;%&quot;.format(100*cnt&#x2F;len))</span><br><span class=\"line\">    p &#x3D; &quot;&quot;.join(list(pt))</span><br><span class=\"line\">    if mode &#x3D;&#x3D; &quot;sha1&quot;:</span><br><span class=\"line\">        ct &#x3D; sha1(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha224&quot;:</span><br><span class=\"line\">        ct &#x3D; sha224(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha256&quot;:</span><br><span class=\"line\">        ct &#x3D; sha256(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha384&quot;:</span><br><span class=\"line\">        ct &#x3D; sha384(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;sha512&quot;:</span><br><span class=\"line\">        ct &#x3D; sha512(p.encode()).hexdigest()</span><br><span class=\"line\">    elif mode &#x3D;&#x3D; &quot;md5&quot;:</span><br><span class=\"line\">        ct &#x3D; md5(p.encode()).hexdigest()</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        exit(0)</span><br><span class=\"line\">    if ct[:20] &#x3D;&#x3D; suffix:</span><br><span class=\"line\">        print(p)</span><br><span class=\"line\">        break</span><br><span class=\"line\">    cnt +&#x3D; 1</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提交token之后得到rsa中的n1 c1 n2 c2</li>\n<li>找到n1和n2的公约数，侧面分解n1,.n2</li>\n<li>解得ek是中文：愿我所爱无忧恙岁长安，根据ek生成规则得到key,算出题目的a,b,c,d</li>\n</ul>\n<ul>\n<li>题目在加密时，每8个字符作为一组，利用该组生成y和z然后对y和z进行运算，返回结果。注意到返回的结果为hex((y &lt;&lt; 52) ^ (pads &lt;&lt; 20) ^ z)</li>\n<li>所以可以知道</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.返回结果（视作84位）的前32位是y；</span><br><span class=\"line\">2.返回结果的第33位至第54位为pads的前20位，第55位至第64位为pads的后12位和z的前12位异或的结果。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意到y和z一共运算了32轮，所以这时pads应该是limit(32*pad)，其后5位是0，所以pads的情况相当于：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">????? ******** ******** ****???? ???00000</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其中 * 代表已知，? 代表未知，0就是0。去掉后边5个0后，另外32位就是pad。</li>\n<li>这个pad中，未知的地方只有12位，总计4096种情况，每种情况对应唯一的z。</li>\n<li>所以可以通过爆破这4096种情况，逆推32轮得到初始的y和z，再观察其转为字符后是否在string.printable中来确定答案。完整代码如下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">import gmpy2</span><br><span class=\"line\">from libnum import n2s,s2n</span><br><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">n1 &#x3D; 523302236767994199900474363344509016779069116440336509402579663927023212822016176967224920257215697515649639915194389392664393435704126520500342935380422629852958893595198501678886910437288107490865842806189885864227955305292596726620737250011643028592306930279653650874633693082819617471411085797465171317473575199984137570425840763157847215554005503026976635376775672263338018024842152016782550728415532850496820668169596712488535626476321971915772540785626943870257914929277013026283202706480202573253694027965561121582254805059775814137542861056288774182091519461752761702279929984980399296157122817271523455097901334302748985253698791419583126820263035649222528798493821648538568572195005358978375666451378629463679501572550304224399031869931606326980885244883575380615433423693907673692911481956161922234589747374211957098461625670478121184734721478951324090304946630772999533103517416951906651316589244984076827527352185687877958699658011472950078992791104307370649334689901210147765149584862868749574640976109508247204313701721196275177445231013673265642224568068643851710967790673640935447579098048865343477978938147696617434878198467680874826616766904653374028721826187308127128623535689512750830887981058826202565202400511</span><br><span class=\"line\">c1 &#x3D; 498116479126828060721351777093052860074248131123861633687756928866328288114135612849582257727497809922257024131348207980532057240060103798568227977564521497134127080257805342446192248133124844549442334197110567598270256443362563074473166503647429611051333058467042150637666479765740465760837773368463067714839472516227071241189038004851446423799255357523722335018334006275302424683874359612832738469924300750750078529793617519763670882091967677827342326944222743651042579235831828367996040140715066967834876505105847352068608085060284716208922782057542541292881761158407247706056426656079240060590899310402168208571288608455268870805780135942398347873755131825844602660879197979908250552518202142180574849619997871142575611493295891685289794234943270549985371377356916876993228441993132176346052582480841840804748103391892367360829385946406970449784716173650039815882209635063166095389007982620077884907738945623441531598991729082106049943909989119158441101967074276580858829052824691525753913860208906309655761578594225039981683717544420716889594252263165426914121554799496094906541367521362681696570717997925590955291849918357945303214885384216817697786187947817980231717851370305526120464677525392225631245022522492166336294567990</span><br><span class=\"line\">n2 &#x3D; 536990588699972595171044696252776619032179414787125154102250364726703105272855466989014009336094247702108918440942171080587326115929077717421949560294869471182366684971337895133599697112193778007924450399107079732471847945598232349103839178632745959014098099259478108015237884846605377823461726458684486899249980041743056079896277510838968230729745020510029386228057731944169220820085059789541971092769832034181463596023438597531006332700648910769750936607476390311140301912742677001065893470340950419360642998700303488716826766066363262819042158064398656956185348135880225267894029419814797931720405594656777311094389676998338309809990367862926139317751409984908306801799152005179724137997626023826392780245630698648023945119617679627945415398046106871715475183890738417311925747430222040725394347022734489930069712092197629163647317772330355887387543008085150959104427391942023985298997288368357638062454066636100000548473809891299732343069825793293706407805782587150123342081839983609199059401502925783039760450730519603070519136086703825438807058787688044991172737575437559249668471352046085614345186161595152256193672994722540039920217058451215889862638946510188311582046866299423997659515395934871167522463706085186962242421859</span><br><span class=\"line\">c2 &#x3D; 164402111514416870480151927449107349163820084533580709383993929301187569338852498622073106678649496858117593538947720740640339668153033620409471744700183709591276280704323985437330452541949262852531710176243561888397374683972759177181684560891529123569371241980602358823138808014488471284855401456011020109937046905434967828616466812821052222924691090808870700970795942705766163862790406417148540210339722273902825469460099520769061522024042123766536620554426683612099219790921573403278241760344418925630823806366949039901279532624187976211611528860461687073096888450694175459321193571925480949635977079339284905452476161156840739751431793628217796061271713787710176980187083301171958573364765677389306720995362317264018186392366551999368657422142163919262968449796794407119199996178284891867472060688293602896147398028717874542567143635071645595076767066361989345197270110842062044509038468406120271061465308775126927579741460684420290619983532930017201223504143911140388202527374930493248620993306321032961537876323380443523093814730204234290659449391857198796743587265894069493376291713198073023178977070834614584650913597763729414655680380751407408769289343905637501434637829997447542901620528323133332447667258731683700542347651</span><br><span class=\"line\">p &#x3D; gmpy2.gcd(n1, n2)</span><br><span class=\"line\">q1 &#x3D; n1 &#x2F;&#x2F; p</span><br><span class=\"line\">q2 &#x3D; n2 &#x2F;&#x2F; p</span><br><span class=\"line\">e &#x3D; 0x10001</span><br><span class=\"line\">phi1 &#x3D; (p-1)*(q1-1)</span><br><span class=\"line\">d1 &#x3D; gmpy2.invert(e, phi1)</span><br><span class=\"line\">m &#x3D; pow(c1, d1, n1)</span><br><span class=\"line\">ek &#x3D; n2s(m)</span><br><span class=\"line\"></span><br><span class=\"line\">key &#x3D; &#39;8891898088b197a0bfa78199b28195bfae89&#39;.decode(&#39;hex&#39;)</span><br><span class=\"line\">limit &#x3D; lambda n: n &amp; 0xffffffff</span><br><span class=\"line\"></span><br><span class=\"line\">Key  &#x3D; [ord(i) for i in key]</span><br><span class=\"line\">a &#x3D; limit((Key[0] &lt;&lt; 24) | (Key[1] &lt;&lt; 16) | (Key[2] &lt;&lt; 8) | Key[3])</span><br><span class=\"line\">b &#x3D; limit((Key[4] &lt;&lt; 24) | (Key[5] &lt;&lt; 16) | (Key[6] &lt;&lt; 8) | Key[7])</span><br><span class=\"line\">c &#x3D; limit((Key[8] &lt;&lt; 24) | (Key[9] &lt;&lt; 16) | (Key[10] &lt;&lt; 8) | Key[11])</span><br><span class=\"line\">d &#x3D; limit((Key[12] &lt;&lt; 24) | (Key[13] &lt;&lt; 16) | (Key[14] &lt;&lt; 8) | Key[15])</span><br><span class=\"line\"></span><br><span class=\"line\">outputs &#x3D; [0x65d4ce3b0b1b3f48bb9fdL, 0xf0230f43414a9c9ac0488L, 0xbd592ebe04025b783fb5bL, 0x28d194dcd1c79b4bb8074L, 0x7c493be8f0fdbb740ec29L]</span><br><span class=\"line\"></span><br><span class=\"line\">def reversecalc(a, b, c, d, y, z, pad):</span><br><span class=\"line\">    for i in range(32, 0, -1):</span><br><span class=\"line\">        # print &#39;Round %d: %d, %d&#39; % (i, y, z)</span><br><span class=\"line\">        pads &#x3D; limit(pad * i)</span><br><span class=\"line\">        paramz &#x3D; (y*16+c)^(y+pads)^((y&gt;&gt;5)+d)</span><br><span class=\"line\">        if(z &lt; paramz):</span><br><span class=\"line\">            z &#x3D; limit(z - paramz + 0x100000000)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            z &#x3D; limit(z - paramz)</span><br><span class=\"line\">        paramy &#x3D; (z*16+a)^(z+pads)^((z&gt;&gt;5)+b)</span><br><span class=\"line\">        if(y &lt; paramy):</span><br><span class=\"line\">            y &#x3D; limit(y - paramy + 0x100000000)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            y &#x3D; limit(y - paramy)</span><br><span class=\"line\">        # print (y, z)</span><br><span class=\"line\">    return y, z</span><br><span class=\"line\"></span><br><span class=\"line\">for output in outputs:</span><br><span class=\"line\">    print hex(output)</span><br><span class=\"line\">    binout &#x3D; bin(output)[2:]</span><br><span class=\"line\">    binout &#x3D; &#39;0&#39;*(84-len(binout))+binout</span><br><span class=\"line\">    y &#x3D; int(binout[:32], 2)</span><br><span class=\"line\">    for i in range(4096):</span><br><span class=\"line\">        bini &#x3D; bin(i)[2:]</span><br><span class=\"line\">        bini &#x3D; &#39;0&#39;*(12-len(bini))+bini</span><br><span class=\"line\">        tmpbinpads &#x3D; bini[0:5] + binout[32:52] + bini[5:12] + &#39;00000&#39;</span><br><span class=\"line\">        pad &#x3D; int(tmpbinpads, 2) &#x2F; 32</span><br><span class=\"line\">        pads &#x3D; limit(int(tmpbinpads, 2))</span><br><span class=\"line\">        z &#x3D; output ^ (y&lt;&lt;52) ^ (pads&lt;&lt;20)</span><br><span class=\"line\">        y0, z0 &#x3D; reversecalc(a, b, c, d, y, z, pad)</span><br><span class=\"line\">        tmpstr &#x3D; n2s(y0)+n2s(z0)</span><br><span class=\"line\">        valid &#x3D; True</span><br><span class=\"line\">        for j in tmpstr:</span><br><span class=\"line\">            if (not j in string.printable)and(j !&#x3D; &#39;\\x00&#39;):</span><br><span class=\"line\">                valid &#x3D; False</span><br><span class=\"line\">                break</span><br><span class=\"line\">        if(valid):</span><br><span class=\"line\">            print tmpstr</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>输出结果：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x65d4ce3b0b1b3f48bb9fdL</span><br><span class=\"line\">S60 &#39;\\M(</span><br><span class=\"line\">flag&#123;5fe</span><br><span class=\"line\">0xf0230f43414a9c9ac0488L</span><br><span class=\"line\">86c73a3e</span><br><span class=\"line\">0xbd592ebe04025b783fb5bL</span><br><span class=\"line\">Us</span><br><span class=\"line\">NU\\KNP-F</span><br><span class=\"line\">381ee168</span><br><span class=\"line\">0x28d194dcd1c79b4bb8074L</span><br><span class=\"line\">)^C04&lt;b5</span><br><span class=\"line\">Z&quot;N*&#39;U_x000C_&#x3D;</span><br><span class=\"line\">83c04451</span><br><span class=\"line\">GNM1!Uyl</span><br><span class=\"line\">0x7c493be8f0fdbb740ec29L</span><br><span class=\"line\">9o&#96;YE</span><br><span class=\"line\">1356f&#125;</span><br><span class=\"line\">QG_x000C_rVHZo</span><br><span class=\"line\">7ju-px&#x2F;_x000C</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>寻找其中看起来像的拼接得到flag</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckfi5r1760000vcu90xn9c09c","category_id":"ckfi5r17c0002vcu9cqwy6xy7","_id":"ckfi5r17i0009vcu95r4084l5"},{"post_id":"ckfi5r17b0001vcu9g07q6et6","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17t000qvcu9fami8yyg"},{"post_id":"ckfi5r17b0001vcu9g07q6et6","category_id":"ckfi5r17p000ivcu93j31gc2w","_id":"ckfi5r17u000tvcu93qxs1jwx"},{"post_id":"ckfi5r17s000nvcu9b0f534v6","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17v000vvcu9ebu98rv7"},{"post_id":"ckfi5r17s000nvcu9b0f534v6","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r17v000xvcu9hou1e04n"},{"post_id":"ckfi5r17h0008vcu93zsa5yvn","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17v000yvcu9e3oje2ac"},{"post_id":"ckfi5r17h0008vcu93zsa5yvn","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r17v0010vcu922mdcodm"},{"post_id":"ckfi5r17l000cvcu93j7928jl","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17w0011vcu97k2d2egf"},{"post_id":"ckfi5r17l000cvcu93j7928jl","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r17w0013vcu9h0b248oq"},{"post_id":"ckfi5r17u000uvcu9268r8exx","category_id":"ckfi5r17c0002vcu9cqwy6xy7","_id":"ckfi5r17w0014vcu9bzon0vga"},{"post_id":"ckfi5r17e0004vcu96enl2ss9","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17w0016vcu9fyt60b4p"},{"post_id":"ckfi5r17e0004vcu96enl2ss9","category_id":"ckfi5r17v000wvcu9c3fq1njx","_id":"ckfi5r17x0017vcu9hivvh9n3"},{"post_id":"ckfi5r17m000dvcu9622l57s0","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17x0019vcu931ofhads"},{"post_id":"ckfi5r17m000dvcu9622l57s0","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r17x001avcu9bhvj7lqz"},{"post_id":"ckfi5r17o000fvcu969d226ta","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17x001cvcu970dy4bwc"},{"post_id":"ckfi5r17o000fvcu969d226ta","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r17y001dvcu91cochak5"},{"post_id":"ckfi5r17f0005vcu97ywc284t","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17y001fvcu9fi4w6gg5"},{"post_id":"ckfi5r17f0005vcu97ywc284t","category_id":"ckfi5r17w0015vcu9d5v4byma","_id":"ckfi5r17y001gvcu947yndvvb"},{"post_id":"ckfi5r17p000hvcu91ocwcrha","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17z001ivcu91f2ehop3"},{"post_id":"ckfi5r17p000hvcu91ocwcrha","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r17z001jvcu94nar7kly"},{"post_id":"ckfi5r17q000jvcu9hpav4r76","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17z001lvcu9eqcqg03d"},{"post_id":"ckfi5r17q000jvcu9hpav4r76","category_id":"ckfi5r17v000wvcu9c3fq1njx","_id":"ckfi5r17z001mvcu95xzn4jmg"},{"post_id":"ckfi5r17r000kvcu9284ydgz3","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r17z001nvcu99nl2hql0"},{"post_id":"ckfi5r17r000kvcu9284ydgz3","category_id":"ckfi5r17v000wvcu9c3fq1njx","_id":"ckfi5r17z001ovcu9hzly1g5d"},{"post_id":"ckfi5r17s000pvcu9doyzdw6r","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r180001pvcu9himm4d6d"},{"post_id":"ckfi5r17s000pvcu9doyzdw6r","category_id":"ckfi5r17v000wvcu9c3fq1njx","_id":"ckfi5r180001qvcu9hswcb2hg"},{"post_id":"ckfi5r17t000svcu9e8hh8n0t","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r180001rvcu958kxh6u0"},{"post_id":"ckfi5r17t000svcu9e8hh8n0t","category_id":"ckfi5r17z001kvcu9847a2wmn","_id":"ckfi5r180001svcu9erun8ws7"},{"post_id":"ckfi5r18e001tvcu9a9sxfw5o","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18h001xvcu9665dh2mq"},{"post_id":"ckfi5r18e001tvcu9a9sxfw5o","category_id":"ckfi5r17p000ivcu93j31gc2w","_id":"ckfi5r18i001zvcu97cjt6m63"},{"post_id":"ckfi5r18f001uvcu99lhghgpv","category_id":"ckfi5r17c0002vcu9cqwy6xy7","_id":"ckfi5r18j0021vcu93na44ms0"},{"post_id":"ckfi5r18g001vvcu917pjcyhd","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18k0023vcu90v025i7z"},{"post_id":"ckfi5r18g001vvcu917pjcyhd","category_id":"ckfi5r17w0015vcu9d5v4byma","_id":"ckfi5r18k0025vcu9d5sn6rgy"},{"post_id":"ckfi5r18i001yvcu9guxy5ej0","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18l0027vcu97xncfdrk"},{"post_id":"ckfi5r18i001yvcu9guxy5ej0","category_id":"ckfi5r17v000wvcu9c3fq1njx","_id":"ckfi5r18m0029vcu9hfqkh9en"},{"post_id":"ckfi5r18j0020vcu94wd7ah15","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18n002cvcu9fs6o3uak"},{"post_id":"ckfi5r18j0020vcu94wd7ah15","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r18o002fvcu94cwwavg0"},{"post_id":"ckfi5r18j0022vcu911dw6r4s","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18p002hvcu90knn6pv9"},{"post_id":"ckfi5r18j0022vcu911dw6r4s","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r18r002jvcu91siwg5o8"},{"post_id":"ckfi5r18k0024vcu9dnezfpgg","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18s002lvcu9hk4t25qb"},{"post_id":"ckfi5r18k0024vcu9dnezfpgg","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r18t002nvcu9gagzaj2i"},{"post_id":"ckfi5r18l0028vcu9gs6xgudc","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18u002pvcu9bwwf9ml7"},{"post_id":"ckfi5r18l0028vcu9gs6xgudc","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r18u002qvcu9gf154xkx"},{"post_id":"ckfi5r18m002bvcu93iu39n88","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18u002rvcu9fz3b7f1v"},{"post_id":"ckfi5r18m002bvcu93iu39n88","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r18u002svcu9agrqg6gl"},{"post_id":"ckfi5r18n002evcu9gl93gakf","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18v002tvcu95psnat3a"},{"post_id":"ckfi5r18n002evcu9gl93gakf","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5r18v002uvcu9h9c5gle3"},{"post_id":"ckfi5r18o002gvcu9e1l223u2","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18v002vvcu99m875s9b"},{"post_id":"ckfi5r18o002gvcu9e1l223u2","category_id":"ckfi5r17v000wvcu9c3fq1njx","_id":"ckfi5r18v002wvcu9boc8glbg"},{"post_id":"ckfi5r18r002ivcu99mjkboaf","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18v002xvcu9c81q23oa"},{"post_id":"ckfi5r18r002ivcu99mjkboaf","category_id":"ckfi5r17v000wvcu9c3fq1njx","_id":"ckfi5r18w002yvcu98qvphof6"},{"post_id":"ckfi5r18r002kvcu9hke9aqwz","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18w002zvcu93xtc2w3r"},{"post_id":"ckfi5r18r002kvcu9hke9aqwz","category_id":"ckfi5r17z001kvcu9847a2wmn","_id":"ckfi5r18w0030vcu967dm9miy"},{"post_id":"ckfi5r18s002mvcu96tex1v2k","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5r18w0031vcu9dpjhad8m"},{"post_id":"ckfi5r18s002mvcu96tex1v2k","category_id":"ckfi5r17v000wvcu9c3fq1njx","_id":"ckfi5r18x0032vcu907wnbue9"},{"post_id":"ckfi5r18t002ovcu99gmg325e","category_id":"ckfi5r17c0002vcu9cqwy6xy7","_id":"ckfi5r18x0033vcu9383adcwf"},{"post_id":"ckfi5r17d0003vcu992fh02iu","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5vkgj0000aku9aywe18l2"},{"post_id":"ckfi5r17d0003vcu992fh02iu","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5vkgj0001aku9c8ih2wbj"},{"post_id":"ckfi5r18h001wvcu95mp2b3lj","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi5zcwo0000sku9empc4tjz"},{"post_id":"ckfi5r18h001wvcu95mp2b3lj","category_id":"ckfi5r17r000mvcu97qiwh28z","_id":"ckfi5zcwo0001sku95gk7cltc"},{"post_id":"ckfi5r17g0007vcu92ci46d9o","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi64cg30000ccu9bygkhapr"},{"post_id":"ckfi5r17g0007vcu92ci46d9o","category_id":"ckfi5tbdm000004u9b56sd38e","_id":"ckfi64cg30001ccu99z091wan"},{"post_id":"ckfi5r18l0026vcu96gnsbxi6","category_id":"ckfi5r17g0006vcu93u09h45j","_id":"ckfi66hvb0000ngu9hiqt1ddb"},{"post_id":"ckfi5r18l0026vcu96gnsbxi6","category_id":"ckfi5tbdm000004u9b56sd38e","_id":"ckfi66hvc0001ngu9anmueho7"}],"PostTag":[],"Tag":[{"name":"密码学","_id":"ckfi5r17j000bvcu9fbct11av"},{"name":"填充方式","_id":"ckfi5r17o000gvcu9hwun9qxb"}]}}